<h1 class="title">
    Desarrollo de clases
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        <strong>
            María
        </strong>
        está convencida de que es el momento de empezar a escribir el
        código de sus propias
        clases
        para, a
        continuación, pasarlas a otros compañeros que las puedan usar. Una vez que otras
        personas reciban esas clases, podrán desentenderse de cómo están hechas por dentro
        (principios de
        encapsulamiento
        y
        ocultación
        de información) y
        limitarse únicamente a utilizarlas a través de los
        métodos
        que conforman su
        interfaz, la manera de comunicarse con el exterior, definiendo su comportamiento.
    </p>
    <p>
        Para llevar a cabo esta labor
        <strong>
            Juan
        </strong>
        va a proseguir con las explicaciones
        sobre objetios y clases:
    </p>
    <p>
          <span class="st">
           —
          </span>
        Ha llegado el momento de empezar a desarrollar nuestras propias
        clases
        <span class="st">
           —
          </span>
        le dice
        <strong>
            Juan
        </strong>
        .
    </p>
    <p>
          <span class="st">
           —
          </span>
        Genial, vamos a comenzar a desarrollar la
        <strong>
            primera
            biblioteca
        </strong>
        de clases para
        <strong>
            BK Programación
        </strong>
        , ¿no es así?
    </p>
    <p>
          <span class="st">
           —
          </span>
        Bueno, ésa es la idea. A ver si tenemos nuestro primer paquete
        de clases, que podríamos llamar com.bkprogramacion.
    </p>
    <p>
          <span class="st">
           —
          </span>
        Pues venga... ¡Vamos allá!
    </p>
    <div class="exe-tooltip-text" id="ta1055294-f6be-8ba1-9795-8431e4b6c00e">
        <p>
            Un objeto es un caso individual, una instancia, de un elemento creada a partir de
            una
            definición (clase).
        </p>
    </div>
    <div class="exe-tooltip-text" id="t6e73c1a0-d1e5-0d23-db63-ff17a9cbcdfc">
        <p>
            Componente software reutilizable expresado en términos de atributos (propiedades o
            características) y métodos (comportamiento). Los programadores pueden usar sus
            propias clases o las incluidas la biblioteca del lenguaje o de una biblioteca creada
            por terceros.
        </p>
    </div>
    <div class="exe-tooltip-text" id="t7998e41b-1343-5201-ea53-1c473563052d">
        <p>
            Consiste en el ocultamiento del estado de un objeto (de sus datos miembro o
            atributos) de manera que sólo se puede cambiar mediante las operaciones (métodos)
            definidas para ese objeto. Cada objeto está aislado del exterior de manera que se
            protegen los datos contra su modificación por quien no tenga derecho a acceder a
            ellos, eliminando efectos secundarios y colaterales no deseados. Este modo de
            proceder permite que el usuario de una clase pueda obviar la implementación de los
            métodos y propiedades para concentrarse sólo en cómo usarlos. Por otro lado se evita
            que el usuario pueda cambiar su estado de manera imprevista e incontrolada.
        </p>
    </div>
    <div class="exe-tooltip-text" id="t7a5ba693-49bc-e467-a330-be119df09373">
        <p>
            Es el efecto que se consigue gracias a la encapsulación: se evita la visibilidad de
            determinados miembros de un objeto al resto del código del programa. De ese modo la
            única manera de acceder al contenido del objeto (atributos) es mediante el uso de su
            interfaz (métodos).
        </p>
    </div>
    <div class="exe-tooltip-text" id="t076c3961-fc22-b213-a045-3a9599538b73">
        <p>
            Elemento de una clase u objeto compuesto por una serie de sentencias que sirven para
            describir las acciones a realizar con esa clase u objeto.
        </p>
    </div>
</div><h1 class="title">
    1.- Concepto de clase
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-left license-CC-BY-SA" style="width: 320px;">
    </div>
    <p>
        Una empresa de logística, antiguo cliente de
        <strong>
            BK Programación
        </strong>
        ha
        manifestado su inquietud respecto a la posibilidad de automatizar la gestión de sus
        vehículos de transporte terrestre. Para ello será necesario desarrollar un prototipo de
        simulación del comportamiento de sus vehículos.
    </p>
    <p>
        El equipo de trabajo que han formado
        <strong>
            María
        </strong>
        y
        <strong>
            Juan
        </strong>
        parece funcionar bastante bien, así que cuando
        <strong>
            Ada
        </strong>
        ha repartido el
        trabajo entre los distintos componentes de la empresa, a ellos les ha tocado evaluar la
        posibilidad de crear un simulador para observar cómo funcionan los vehículos. Se
        trataría de una aplicación muy sencilla que permitiera crear vehículos para observar su
        comportamiento respecto al consumo, recorridos,
        <abbr title="etcétera">
            etc
        </abbr>
        .
    </p>
    <p>
        Es el momento de que empiecen a pensar en los distintos objetos con los que pueden
        modelar la información cuyo tratamiento desean automatizar. Muchos de estos objetos no
        van a ser proporcionados por las bibliotecas de
        <span lang="en">
           Java
          </span>
        , de manera
        que habrá que "fabricarlos", es decir, van a tener que diseñar e implementar las clases
        (los "moldes" o "plantillas") que les permitirán crear los objetos que van a necesitar.
        Ha llegado el momento de enfrentarse seriamente con la
        <strong>
            implementación de
            una clase
        </strong>
        .
    </p>
    <p>
        <strong>
            Juan
        </strong>
        está dándole vueltas a la idea pensando en la información que habrá
        que almacenar y el comportamiento que habrá que implementar para modelar un vehículo de
        la manera más simple posible:
    </p>
    <p>
          <span>
           — Habría que disponer de atributos para almacenar el
           <strong>
            tamaño del depósito
           </strong>
           y el
           <strong>
            consumo medio
           </strong>
           , y éstos atributos ya serán inmutables a lo largo de la vida de todo el objeto. Sin embargo, otros atributos como la
           <strong>
            distancia recorrida
           </strong>
           o el
           <strong>
            consumo producido
           </strong>
           , estarán más relacionados con el estado del objeto y podrán ir cambiando a lo largo de la vida de éste, ¿no crees?
          </span>
    </p>
    <p>
          <span>
           <span>
            — Sí. Parece bastante razonable. Además también vendría bien disponer de atributos que sean independientes de los objetos, que dependan directamente de la clase, aunque incluso no existieran aún objetos creados. — le contesta
           </span>
           <strong>
            María
           </strong>
           <span>
            , que está echándole una mano.
           </span>
          </span>
    </p>
    <p>
        — ¡Claro! Imagina que queremos almacenar en alguna parte
        <strong>
            el total de kilómetros
            recorridos por todos los coches de la empresa
        </strong>
        . ¿Qué mejor forma de
        representarlo que utilizando
        <strong>
            atributos estáticos
        </strong>
        para ello? ¡Buena
        idea!
        <span>
           — le interpela
          </span>
        <strong>
            Juan
        </strong>
        <span>
           , mientras sigue dibujando un pequeño esquema de cómo podría quedar la clase que representa a los vehículos.
          </span>
    </p>
</div><h1 class="title">
    1.1.- Repaso del concepto de objeto
</h1>
<div class="iDevice_content">
    <p>
        Desde el comienzo del módulo llevas utilizando el concepto de
        <strong>
            objeto
        </strong>
        para
        desarrollar tus programas de ejemplo. En las unidades anteriores se ha descrito un objeto como
        una entidad que contiene
        <strong>
            información
        </strong>
        (atributos) y que es capaz de llevar a
        cabo ciertas
        <strong>
            operaciones
        </strong>
        (métodos) con esa información más algunos estímulos
        externos (parámetros de entrada de los métodos). Según la información que contengan esos
        atributos el objeto tendrá un
        <strong>
            estado
        </strong>
        determinado y según las operaciones que se
        puedan llevar a cabo con esos datos será responsable de un
        <strong>
            comportamiento
        </strong>
        concreto.
    </p>
    <div class="destacado">
        <p>
            <strong>
                Recuerda que entre las características fundamentales de un objeto se encontraban la
                <em>
                    identidad
                </em>
                (los objetos son únicos y por tanto distinguibles entre sí, aunque pueda
                haber objetos exactamente iguales), un
                <em>
                    estado
                </em>
                (los atributos que describen al
                objeto y que tendrán cierto valor en cada momento) y un determinado
                <em>
                    comportamiento
                </em>
                (acciones que se pueden realizar sobre el objeto).
            </strong>
        </p>
    </div>
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Algunos ejemplos de objetos que podríamos imaginar podrían ser:
    </p>
    <ul class="lista_verificacion">
        <li>
            Un vehículo de tipo turismo, de color rojo, marca
            <abbr title="Sociedad Española de Automóviles de Turismo.">
                SEAT
            </abbr>
            , modelo Toledo, del
            año 2020. En este ejemplo tenemos una serie de atributos, como el color (en este caso rojo),
            la marca, el modelo, el año,
            <abbr title="etcétera.">
                etc
            </abbr>
            . Así mismo también podríamos
            imaginar determinadas características como la cantidad de combustible que le queda, o el
            número de kilómetros recorridos hasta el momento.
        </li>
        <li>
            Otro vehículo de color amarillo, marca Opel, modelo Astra, del año 2018.
        </li>
        <li>
            Otro vehículo más de color amarillo, marca Opel, modelo Astra y también del año 2018. Se
            trataría de otro objeto (otro vehículo) con las mismas propiedades que el anterior (es
            idéntico pero no es el mismo). Sería otro objeto diferente con características idénticas,
            casi como un clon.
        </li>
        <li>
            Un cocodrilo de cuatro metros de longitud y de veinte años de edad.
        </li>
        <li>
            Un círculo de radio 2 centímetros, con centro en las coordenadas (0,0) y relleno de color
            amarillo.
        </li>
        <li>
            Otro círculo de radio 3 centímetros, con centro en las coordenadas (1,2) y relleno de color
            verde.
        </li>
        <li>
            Una persona con nombre "Juan", apellidos "Torres Waxman" y fecha de nacimiento 01/01/1990.
        </li>
        <li>
            Otra persona con nombre "Ana", apellidos "Castillo Gil" y fecha de nacimiento 04/07/1992.
        </li>
    </ul>
    <p>
        Si observas los ejemplos anteriores podrás distinguir sin demasiada dificultad al menos cuatro
        familias de objetos diferentes, que no tienen nada que ver una con otra:
    </p>
    <ul class="lista_verificacion">
        <li>
            Los vehículos.
        </li>
        <li>
            Los círculos.
        </li>
        <li>
            Los cocodrilos.
        </li>
        <li>
            Las personas.
        </li>
    </ul>
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Es de suponer entonces que cada objeto tendrá determinadas posibilidades de
        <strong>
            comportamiento
        </strong>
        (
        <strong>
            acciones
        </strong>
        ) dependiendo de la familia a la que pertenezcan. Por ejemplo, en el
        caso de los
        <strong>
            vehículos
        </strong>
        podríamos imaginar acciones como:
        <strong>
            arrancar
        </strong>
        ,
        <strong>
            apagar
        </strong>
        ,
        <strong>
            repostar
        </strong>
        ,
        <strong>
            frenar
        </strong>
        ,
        <strong>
            acelerar
        </strong>
        ,
        <strong>
            cambiar de marcha
        </strong>
        ,
        <abbr title="etcétera.">
            etc
        </abbr>
        . En el caso de los
        <strong>
            cocodrilos
        </strong>
        podrías
        imaginar otras acciones como:
        <strong>
            desplazarse
        </strong>
        ,
        <strong>
            comer
        </strong>
        ,
        <strong>
            dormir
        </strong>
        ,
        <strong>
            cazar
        </strong>
        ,
        <abbr title="etcétera.">
            etc
        </abbr>
        . Para el caso del
        <strong>
            círculo
        </strong>
        se podrían plantear acciones como:
        <strong>
            cálculo de la superficie del
            círculo
        </strong>
        ,
        <strong>
            cálculo de la longitud de la circunferencia que lo rodea
        </strong>
        ,
        <abbr title="etcétera.">
            etc
        </abbr>
        .
    </p>
    <p>
        Por otro lado, también podrías imaginar algunos
        <strong>
            atributos
        </strong>
        cuyos valores podrían
        ir cambiando en función de las acciones que se realizaran sobre el objeto: ubicación del
        vehículo (coordenadas), velocidad instantánea, kilómetros recorridos, velocidad media, cantidad
        de combustible en el depósito,
        <abbr title="etcétera.">
            etc
        </abbr>
        . En el caso de los cocodrilos
        podrías imaginar otros atributos como: peso actual, el número de dientes actuales (irá perdiendo
        algunos a lo largo de su vida), el número de presas que ha cazado hasta el momento,
        <abbr title="etcétera.">
            etc
        </abbr>
        .
    </p>
    <p>
        Como puedes ver, un
        <strong>
            objeto
        </strong>
        puede ser cualquier cosa que puedas describir en
        términos de
        <strong>
            atributos
        </strong>
        y
        <strong>
            acciones
        </strong>
        . Dependerá de la aplicación
        que tengas que desarrollar para que tu objeto contenga unos u otros atributos y/o acciones. El
        límite estará en las necesidades de la aplicación y tu imaginación a la hora de "inventar"
        objetos.
    </p>
</div><h1 class="title">
    1.2.- El concepto de clase
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Está claro que dentro de un mismo programa tendrás la oportunidad de encontrar decenas, cientos
        o
        incluso miles de objetos. En algunos casos no se parecerán en nada unos a otros, pero también
        podrás observar que habrá muchos que tengan un gran parecido, compartiendo un mismo
        comportamiento y unos mismos atributos. Habrá muchos objetos que sólo se diferenciarán por los
        valores que toman algunos de esos atributos.
    </p>
    <p>
        Es aquí donde entra en escena el concepto de
        <strong>
            clase
        </strong>
        . Está claro que no podemos
        definir la estructura y el comportamiento de cada objeto cada vez que va a ser utilizado dentro
        de un programa, pues la escritura del código sería una tarea interminable y redundante. La idea
        es poder disponer de una
        <strong>
            plantilla
        </strong>
        o
        <strong>
            modelo
        </strong>
        para cada conjunto
        de objetos que sean del mismo tipo, es decir, que tengan los mismos atributos y un
        comportamiento similar.
    </p>
    <div class="destacado">
        <p>
            <strong>
                Una clase consiste en la definición de un tipo de objeto. Se trata de una descripción
                detallada de cómo van a ser los objetos que pertenezcan a esa clase, indicando qué tipo
                de
                información contendrán (atributos) y cómo se podrá interactuar con ellos
                (comportamiento).
            </strong>
        </p>
    </div>
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Como ya has visto anteriormente, una clase consiste en un plantilla en la que se especifican:
    </p>
    <ul class="lista_verificacion">
        <li>
            Los
            <strong>
                atributos
            </strong>
            que van a ser comunes a todos los objetos que pertenezcan a
            esa clase (información).
        </li>
        <li>
            Los
            <strong>
                métodos
            </strong>
            que permiten interactuar con esos objetos (comportamiento).
        </li>
    </ul>
    <p>
        A partir de este momento podrás hablar ya sin confusión de objetos y de clases, sabiendo que los
        primeros son instancias concretas de las segundas, que no son más que una abstracción o
        definición.
    </p>
    <p>
        Si nos volvemos a fijar en los ejemplos de objetos del apartado anterior podríamos observar que
        las clases serían lo que clasificamos como "familias" de objetos (Vehiculo,
        <code>
            Cocodrilo
        </code>
        , Circulo,
        <code>
            Persona
        </code>
        ). Por ejemplo, podríamos hablar de la
        clase&nbsp;Vehiculo y de varios objetos de esa clase: el Seat Toledo rojo de 2020, el primer
        Opel Astra amarillo de 2018 y el segundo Opel Astra amarillo de 2018.
    </p>
    <div class="destacado">
        <p>
            <strong>
                En el lenguaje cotidiano de muchos programadores puede ser habitual la confusión
                entre los términos clase y objeto. Aunque normalmente el contexto nos permite distinguir
                si
                nos estamos refiriendo realmente a una clase (definición abstracta) o a un objeto
                (instancia
                concreta), hay que tener cuidado con su uso para no dar lugar a interpretaciones
                erróneas,
                especialmente durante el proceso de aprendizaje.
            </strong>
        </p>
    </div>
</div><h1 class="title">
    2.- Empaquetado de clases
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        <strong>
            María
        </strong>
        y
        <strong>
            Juan
        </strong>
        ya han terminado por ahora de escribir
        todas las clases que habían diseñado. Es el momento de organizar adecuadamente todo el
        código que tienen implementado a lo largo de todas esas clases.
        <strong>
            María
        </strong>
        recuerda que hace algunos días
        <strong>
            Juan
        </strong>
        ya le habló de la posibilidad de
        organizar las clases en paquetes:
    </p>
    <p>
        Este sería un buen momento para poner en práctica todo aquello que me enseñaste sobre
        los
        paquetes, ¿no?
    </p>
    <p>
          <span class="st">
           —
          </span>
        La verdad es que tienes razón. Esto hay que organizarlo un poco
        <span class="st">
           —
          </span>
        le contesta
        <strong>
            Juan
        </strong>
        .
    </p>
</div><h1 class="title">
    2.1.- Jerarquía de paquetes
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 250px;">
    </div>
    <p>
        Los
        <strong>
            paquetes en
            <span lang="en">
          Java
         </span>
        </strong>
        pueden organizarse
        <strong>
            jerárquicamente
        </strong>
        de manera similar a lo que puedes encontrar en la estructura de carpetas en un dispositivo de
        almacenamiento, donde:
    </p>
    <ul class="lista_verificacion">
        <li>
            las clases serían como los archivos,
        </li>
        <li>
            cada paquete sería como una carpeta que contiene archivos (clases).,
        </li>
        <li>
            cada paquete puede además contener otros paquetes (como las carpetas que pueden contener
            otras carpetas),
        </li>
        <li>
            para poder hacer referencia a una clase dentro de una estructura de paquetes, habrá que
            indicar la
            <strong>
                trayectoria completa
            </strong>
            desde el paquete raíz de la jerarquía hasta
            el paquete en el que se encuentra la clase, indicando por último el nombre de la clase (como
            el
            <span lang="en">
          path
         </span>
            absoluto de un archivo).
        </li>
    </ul>
    <p>
        La estructura de paquetes en
        <span lang="en">
         Java
        </span>
        permite organizar y clasificar las
        clases, evitando conflictos de nombres y facilitando la ubicación de una clase dentro de una
        estructura jerárquica.
    </p>
    <p>
        Por otro lado, la organización en paquetes permite también el
        <strong>
            control de acceso
        </strong>
        a miembros de las clases desde otras clases que estén en el mismo paquete gracias a los
        <strong>
            modificadores
            de acceso
        </strong>
        . Los modificadores de acceso se van a ver en detalle dentro de un par de
        apartados en esta misma unidad, aunque ya han aparecido en algunos ejemplos anteriores.
        ¿Recuerdas el modificador public?
    </p>
    <p>
        Las clases que forman parte de la jerarquía de clases de
        <span lang="en">
         Java
        </span>
        se
        encuentran organizadas en diversos paquetes.
    </p>
    <p>
        Todas las clases proporcionadas por
        <span lang="en">
         Java
        </span>
        en sus bibliotecas son miembros
        de distintos paquetes y se encuentran organizadas jerárquicamente. Dentro de cada paquete habrá
        un conjunto de clases con algún tipo de relación entre ellas. Se dice que todo ese conjunto de
        paquetes forman la
        API
        <span lang="en">
         Java
        </span>
        . Por ejemplo, las
        clases básicas del lenguaje se encuentran en el paquete java.lang, las clases de entrada/salida
        las podrás encontrar en el paquete java.io y en el paquete java.math podrás observar algunas
        clases para trabajar con números grandes y de gran precisión.
    </p>
    <div class="elemento_centrado">
        <div class="elemento_centrado">
            <div class="elemento_centrado">
                <div class="elemento_centrado">
                    <div class="elemento_centrado">
                        <div class="elemento_centrado">

                        </div>

                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="exe-tooltip-text" id="tcd4d5a88-026c-b47b-35c7-12341f12ac1e">
        <p>
            Una interfaz de programación de aplicaciones o
            <abbr title="Application Programming Interface">
                API
            </abbr>
            (del inglés
            Application Programming Interface) consiste en el conjunto de clases, interfaces, métodos,
            funciones, constantes, etcétera, que ofrece cierta biblioteca para ser utilizado por otro
            <span lang="en">
          software
         </span>
            como una capa de abstracción.
        </p>
    </div>
</div><h1 class="title">
    2.2.- Utilización de los paquetes
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="exe-figure exe-image float-right license-pd" style="width: 180px;">
        </div>
    </div>
    <p>
        Es posible acceder a cualquier clase de cualquier paquete (siempre que ese paquete esté
        disponible en nuestro sistema, obviamente) mediante la
        <strong>
            calificación completa
        </strong>
        de
        la clase dentro de la estructura jerárquica de paquete. Es decir indicando la trayectoria
        completa de paquetes desde el paquete raíz hasta la propia clase. Eso se puede hacer utilizando
        el operador
        <strong>
            punto
        </strong>
        : "&lt;abbr title="Punto."&gt;.&lt;/abbr&gt;") para
        especificar cada subpaquete:
    </p>
    <div class="highlighted-code language-java">
        <pre>paquete_raiz.subpaquete1.subpaquete2. ... .subpaquete_n.NombreClase
</pre>
    </div>
    <p>
        Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <pre>java.lang.String
</pre>
    </div>
    <p>
        En este caso se está haciendo referencia a la clase String que se encuentra dentro del paquete
        java.lang. Este paquete contiene las clases elementales para poder desarrollar una aplicación
        <span lang="en">
         Java
        </span>
        .
    </p>
    <p>
        Otro ejemplo podría ser:
    </p>
    <div class="highlighted-code language-java">
        <pre>java.util.regex.Pattern
</pre>
    </div>
    <p>
        En este otro caso se hace referencia a la clase Pattern ubicada en el paquete java.util.regex,
        que contiene clases para trabajar con expresiones regulares.
    </p>
    <p>
        Dado que puede resultar bastante tedioso tener que escribir la trayectoria completa de una clase
        cada vez que se quiera utilizar, existe la posibilidad de indicar que se desea trabajar con las
        clases de uno o varios paquetes. De esa manera cuando se vaya a utilizar una clase que
        pertenezca a uno de esos paquetes no será necesario indicar toda su trayectoria. Para ello se
        utiliza la sentencia import (importar):
    </p>
    <div class="highlighted-code language-java">
        <pre>import paquete_raiz.subpaquete1.subpaquete2. ... .subpaquete_n.NombreClase;
</pre>
    </div>
    <p>
        De esta manera a partir de ese momento podrá utilizarse directamente NombreClase en lugar de
        toda
        su trayectoria completa.
    </p>
    <p>
        Los ejemplos anteriores quedarían entonces:
    </p>
    <div class="highlighted-code language-java">
        <pre>import java.lang.String;
import java.util.regex.Pattern;
</pre>
    </div>
    <p>
        Si suponemos que vamos a utilizar varias clases de un mismo paquete, en lugar de hacer un import
        de cada una de ellas, podemos utilizar el
        <strong>
            comodín
        </strong>
        (símbolo
        <strong>
            asterisco
        </strong>
        : "&lt;abbr title="Asterisco."&gt;*&lt;/abbr&gt;") para indicar que
        queremos importar todas las clases de ese paquete y no sólo una determinada:
    </p>
    <div class="highlighted-code language-java">
        <pre>import java.lang.*;
import java.util.regex.*;
</pre>
    </div>
    <p>
        Si un paquete contiene subpaquetes, el comodín no importará las clases de los subpaquetes, tan
        solo las que haya en el paquete. La importación de las clases contenidas en los subpaquetes
        habrá que indicarla explícitamente. Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <pre>import java.util.*;
import java.util.regex.*;

</pre>
    </div>
    <p>
        En este caso se importarán todas las clases del paquete java.util (clases Date, Calendar, Timer,
        <abbr title="etcétera.">
            etc
        </abbr>
        .) y de su subpaquete java.util.regex (
        <code>
            Matcher
        </code>
        y
        Pattern), pero NO las de otros subpaquetes como java.util.concurrent o
        <code>
            java.util.jar
        </code>
        .
    </p>
    <p>
        Por último tan solo indicar que
        <span class="destacado_inline">
         <strong>
          en el caso del paquete java.lang, no es necesario realizar importación.
         </strong>
        </span>
        El compilador, dada la importancia de este paquete, permite el uso de sus clases sin necesidad
        de indicar su trayectoria (es como si todo archivo
        <span lang="en">
         Java
        </span>
        incluyera en su
        primera línea la sentencia import java.lang.* aunque no se escriba). El motivo, recordamos, es
        que este paquete contiene toda una serie de clases fundamentales para el buen funcionamiento del
        lenguaje, incluyendo la propia clase Object, de la que heredan todas las demás, por lo que no
        sería posible hacer nada sin disponer de ese paquete.
    </p>
</div><h1 class="title">
    2.3.- Inclusión de una clase en un paquete
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 180px;">
    </div>
    <p>
        Al principio de cada archivo .java se puede indicar a qué paquete pertenece mediante la palabra
        reservada package seguida del nombre del paquete:
    </p>
    <div class="highlighted-code language-java">
        <pre>package nombrepaquete;
</pre>
    </div>
    <p>
        Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <pre>package packejemplo;
class ClaseEjemplo &#123;

...

&#125;
</pre>
    </div>
    <p>
        La sentencia package debe ser incluida en cada archivo fuente de cada clase que quieras incluir
        ese paquete. Si en un archivo fuente hay definidas más de una clase, todas esas clases formarán
        parte del paquete indicado en la sentencia package.
    </p>
    <p>
        Si al comienzo de un archivo
        <span lang="en">
         Java
        </span>
        no se incluye ninguna sentencia package,
        el compilador considerará que las clases de ese archivo formarán parte del paquete por omisión
        (un paquete sin nombre asociado al proyecto), aunque se recomienda siempre usar algún paquete
        para el proyecto, distinto de paquete por defecto o por omisión.
    </p>
    <p>
        Para evitar la ambigüedad,
        <strong>
            dentro de un mismo paquete no puede haber dos clases con el
            mismo nombre,
        </strong>
        aunque sí pueden existir clases con el mismo nombre si están en paquetes
        diferentes. El compilador será capaz de distinguir una clase de otra gracias a que pertenecen a
        paquetes distintos.
    </p>
    <p>
        Como ya has visto en unidades anteriores, el nombre de un archivo fuente en
        <span lang="en">
         Java
        </span>
        se construye utilizando el nombre de la clase pública que contiene
        junto con la extensión .java, pudiendo haber únicamente una clase pública por cada archivo
        fuente. El nombre de la clase debía coincidir (en mayúsculas y minúsculas) exactamente con el
        nombre del archivo en el que se encontraba definida. Así, si por ejemplo tenías una clase Punto
        dentro de un archivo Punto.java, la compilación daría lugar a un archivo Punto.class.
    </p>
    <p>
        En el caso de los paquetes, la correspondencia es a nivel de directorios o carpetas. Es decir,
        si
        la clase Punto se encuentra dentro del paquete prog.figuras, el archivo Punto.java debería
        encontrarse en la carpeta prog\figuras. Para que esto funcione correctamente el compilador ha de
        ser capaz de localizar todos los paquetes (tanto los estándar de
        <span lang="en">
         Java
        </span>
        como
        los definidos por otros programadores). Es decir, que el compilador debe tener conocimiento de
        dónde comienza la estructura de carpetas definida por los paquetes y en la cual se encuentran
        las clases. Para ello se utiliza el ClassPath cuyo funcionamiento hemos estudiado en las
        primeras unidades de este módulo. Se trata de una variable de entorno que contiene todas las
        rutas en las que comienzan las estructuras de directorios (distintas jerarquías posibles de
        paquetes) en las que están contenidas las clases.
    </p>
</div><h1 class="title">
    2.4.- Proceso de creación de un paquete
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="exe-figure exe-image float-right license-pd" style="width: 180px;">
        </div>
    </div>
    <p>
        Para crear un paquete en
        <span lang="en">
         Java
        </span>
        te recomendamos seguir los siguientes pasos:
    </p>
    <ol class="lista_esquema">
        <li>
            <strong>
                Poner un nombre al paquete
            </strong>
            . Suele ser habitual utilizar el dominio de
            Internet de la empresa que ha creado el paquete. Por ejemplo, para el caso de
            <strong>
                miempresa.com
            </strong>
            ,
            podría utilizarse un nombre de paquete
            <strong>
                com.miempresa
            </strong>
            .
        </li>
        <li>
            <strong>
                Crear una estructura jerárquica de carpetas equivalente a la estructura de
                subpaquetes
            </strong>
            . La ruta de la raíz de esa estructura jerárquica deberá estar
            especificada en el
            <strong>
                ClassPath
            </strong>
            de
            <span lang="en">
          Java
         </span>
            .
        </li>
        <li>
            <strong>
                Especificar a qué paquete pertenece la clase
            </strong>
            (o clases) del archivo .java
            mediante el uso de la sentencia
            <strong>
                package
            </strong>
            tal y como has visto en el apartado
            anterior.
        </li>
    </ol>
    <p>
        Este proceso ya lo has debido llevar a cabo en unidades anteriores al compilar y ejecutar clases
        con paquetes. Estos pasos simplemente son para que te sirvan como recordatorio del procedimiento
        que debes seguir a la hora de clasificar, jerarquizar y utilizar tus propias clases.
    </p>
</div><h1 class="title">
    3.- Estructura y miembros de una clase
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
          <span class="st">
           —
          </span>
        De acuerdo, ya hemos pensado en la clase principal que va a
        tener nuestra aplicación: la clase Vehiculo. Pero, ¿cómo escribimos eso en
        <span lang="en">
           Java
          </span>
        ? ¿Cómo declaramos o definimos una clase en
        <span lang="en">
           Java
          </span>
        ? ¿Qué palabras reservadas hay que utilizar? ¿Qué partes
        tiene esa definición?
        <span class="st">
           —
          </span>
        pregunta
        <strong>
            María
        </strong>
        con
        interés.
    </p>
    <p>
          <span class="st">
           —
          </span>
        Bien, es el momento de ver cómo es la estructura de una clase y
        cómo podemos escribirla en
        <span lang="en">
           Java
          </span>
        para luego poder fabricar objetos
        que sean instancias de esa clase
        <span class="st">
           —
          </span>
        le responde
        <strong>
            Juan
        </strong>
        .
    </p>
</div><h1 class="title">
    3.1.- Declaración de una clase
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="exe-figure exe-image float-left license-pd" style="width: 240px;">
        </div>
    </div>
    <p>
        La declaración de una clase en
        <span lang="en">
         Java
        </span>
        está basada en la palabra reservada&nbsp;class
        y tiene la siguiente estructura general:
    </p>
    <div class="highlighted-code language-java">
        <pre>// Cabecera de la clase
[modificadores] class  <NombreClase> [herencia][interfaces] &#123;

// Cuerpo de la clase

  // Atributos
  <strong>[Declaración de los atributos]</strong>

  // Métodos
  <strong>[Declaración de los métodos]</strong>

&#125;</pre>
    </div>
    <p>
        <strong>
            Todo lo que está entre corchetes es opcional
        </strong>
        . Por tanto, lo mínimo e
        imprescindible que necesitamos para declarar una clase en
        <span lang="en">
         Java
        </span>
        es la
        <strong>
            palabra reservada
        </strong>
        class más en el nombre que le queremos dar a la clase
        junto con las llaves que se abren y se cierran para codificar el cuerpo de la clase. Por el
        momento no necesitaríamos nada más.
    </p>
    <p>
        ¿Cómo podríamos hacerlo para nuestra clase Vehiculo?
    </p>
    <p>
        Lo primero que tendríamos que hacer sería pensar en cómo querríamos llamar la clase (lo tenemos
        claro: Vehiculo).&nbsp; Eso junto con la palabra reservada class y las llaves que engloban al
        cuerpo podrían darnos una primera aproximación a nuestra clase:
    </p>
    <div class="highlighted-code language-java">
        <pre>class Vehiculo &#123;

&#125;
</pre>
    </div>
    <p>
        En este caso se trata de una clase muy sencilla en la que
        <strong>
            el cuerpo de la clase (el área
            entre las llaves) no contiene absolutamente nada
        </strong>
        . Conforme vayamos avanzando habrá que
        ir rellenándola con el código y las declaraciones necesarias para que los objetos que se
        construyan (basándose en esta clase) puedan funcionar apropiadamente en un programa (declaración
        de atributos para contener el estado del objeto y declaración métodos que implementen el
        comportamiento de los objetos creados a partir de ella). Ahora mismo no es más que un
        "envoltorio" vacío. Si queremos añadirle algunos comentarios para que quede más documentada,
        podríamos incluirlos. Aún así, seguiría siendo algo vacío y de poca utilidad. Simplemente hemos
        declarado una clase&nbsp;Vehiculo que no tiene ningún atributo ni ningún método:
    </p>
    <div class="highlighted-code language-java">
        <pre>// Declaración de la clase Vehiculo

// Cabecera de la clase:
  // modificadores de acceso (ninguno),
  // palabra reservada "class"
  // nombre de la clase ("Vehiculo"),
  // herencia (nada),
  // implementación de interfaces (ninguna).
class Vehiculo &#123;

  // Cuerpo de la clase: declaración de atributos e implementación de métodos -> Por ahora vacía

    // 1. Declaración de atributos: por ahora no hay ninguno

    // 2. Implementación de métodos: por ahora no hay ninguno
&#125;
</pre>
    </div>
    <p>
        Si te fijas en los distintos programas que se han desarrollado en los ejemplos y las tareas de
        las unidades anteriores, podrás observar que cada uno de esos programas era en sí mismo una
        clase
        <span lang="en">
         Java
        </span>
        : se declaraban con la palabra reservada class y contenían
        algunos atributos (variables) así como algunos métodos (como mínimo el método main).
    </p>
    <p>
        En el ejemplo anterior hemos visto lo mínimo que se tiene que indicar en la
        <strong>
            cabecera de
            una clase
        </strong>
        (el nombre de la clase y la palabra reservada class). Se puede proporcionar
        bastante más información mediante modificadores y otros indicadores como por ejemplo el nombre
        de su
        <strong>
            superclase
        </strong>
        (si es que esa clase hereda de otra), si implementa alguna
        interfaz
        (en inglés
        <strong>
         <span lang="en">
         </span>
        </strong>
        <span lang="en">
         <strong>
          <span lang="en">
           interface
          </span>
         </strong>
        </span>
        ) y algunas cosas más que irás aprendiendo
        poco a poco.
    </p>
    <p>
        A la hora de implementar
        <strong>
            una clase
            <span lang="en">
          Java
         </span>
        </strong>
        (escribirla en un
        archivo con un editor de textos o con alguna herramienta integrada como por ejemplo
        <strong>
         <span lang="en">
          Netbeans
         </span>
        </strong>
        o
        <span lang="en">
         Eclipse
        </span>
        ) debes tener
        en cuenta:
    </p>
    <ul class="lista_verificacion">
        <li>
            Como debes recordar, por convenio, se ha decidido que en lenguaje
            <span lang="en">
          Java
         </span>
            los nombres de las clases deben de
            <strong>
                empezar por una
                letra mayúscula
            </strong>
            . Así, cada vez que observes en el código una palabra con la primera
            letra en mayúscula sabrás que se trata de una clase sin necesidad de tener que buscar su
            declaración. Además,
            <strong>
                si el nombre de la clase está formado por varias palabras,
                cada una de ellas también tendrá su primera letra en mayúscula
            </strong>
            . No se usarán ni
            el carácter de subrayado también conocido como guión bajo o
            <span lang="en">
          underscore
         </span>
            : '_'), ni separadores como espacios en blanco. Tampoco
            recomendamos utilizar caracteres acentuados, la eñe, ni ningún otro carácter especial
            extraño por facilitar el trabajo a los teclados internacionales (imagina un código plagado
            de eñes y acentos que tenga que ser retocado por alguien que esté usando un teclado
            aglosajón en
            <abbr title="Estados Unidos">
                EEUU
            </abbr>
            , podría ser una auténtica
            pesadilla). Siguiendo esta recomendación, algunos ejemplos de nombres de clases podrían ser
            Circulo,
            <code>
                Rectangulo
            </code>
            , Jugador,
            <code>
                Deposito
            </code>
            , Ticket,
            <code>
                JugadorDeFutbol
            </code>
            ,
            AnimalMarino,
            <code>
                Vehiculo
            </code>
            , VehiculoTerrestre,
            <code>
                Persona
            </code>
            ,
            CuentaBancaria,
            <abbr title="etcétera.">
                etc
            </abbr>
            .
        </li>
        <li>
            <strong>
                El archivo en el que se encuentra una clase
                <span lang="en">
           Java
          </span>
                debe tener
                el mismo nombre que esa clase
            </strong>
            si queremos poder utilizarla desde otras clases que
            se encuentren fuera de ese archivo (
            <strong>
                clase principal del archivo
            </strong>
            ). Por esa
            razón, mientras no se diga lo contrario, siempre tendremos
            <strong>
                un archivo por cada
                clase
            </strong>
            que desarrollemos.
        </li>
        <li>
            <strong>
                Tanto la definición como la implementación de una clase se incluye en el mismo
                archivo
            </strong>
            (archivo ".java"). En otros lenguajes como por ejemplo
            <abbr title="C plus plus, orientado a objetos.">
                C++
            </abbr>
            , definición e implementación
            podrían ir en archivos separados (por ejemplo en
            <abbr title="C plus plus, orientado a objetos.">
                C++
            </abbr>
            , serían sendos archivos con
            extensiones ".h" y ".cpp").
        </li>
    </ul>
    <div class="exe-tooltip-text" id="t1d4c5257-b5c2-a695-0b89-9b801b455dec">
        Una interfaz (o interface)
        en
        <span lang="en">
         Java
        </span>
        es una clase donde todos sus métodos son implícitamente
        declarados como abstract (métodos abstractos), que son métodos sin cuerpo, sin implementación.
        Es misión del programador implementar los métodos del
        <span lang="en">
         interface
        </span>
        en
        cualquier clase que lo use.
    </div>
</div><h1 class="title">
    3.2.- Cabecera de una clase
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="exe-figure exe-image position-center license-pd" style="width: 200px;">
        </div>
    </div>
    <p>
        En general, la declaración de una clase puede incluir los siguientes elementos y en el siguiente
        orden:
    </p>
    <ol class="lista_esquema">
        <li>
            <strong>
                Modificadores
            </strong>
            tales como public,
            <code>
                abstract
            </code>
            o final. No es
            obligatorio indicar ninguno.
        </li>
        <li>
            El
            <strong>
                nombre
            </strong>
            de la clase (con la primera letra de cada palabra en mayúsculas,
            por convenio).
        </li>
        <li>
            El nombre de su
            <strong>
                clase padre
            </strong>
            (
            <strong>
                superclase
            </strong>
            ), si es que se
            especifica, precedido por la palabra reservada extends ("extiende" o "hereda de"). Eso lo
            veremos en la siguiente unidad cuando aprendamos a usar la herencia. No es obligatorio
            indicar ningún tipo de herencia.
        </li>
        <li>
            Una lista separada por comas de
            <strong>
                interfaces
            </strong>
            que son implementadas por la
            clase, precedida por la palabra reservada implements ("implementa"). También lo aprenderemos
            a utilizar en la próxima unidad. No es obligatorio implementar ninguna interfaz.
        </li>
        <li>
            El
            <strong>
                cuerpo
            </strong>
            de la clase, encerrado entre llaves &#123;&#125;.
        </li>
    </ol>
    <p>
        La sintaxis completa de una cabecera (los cuatro primeros puntos) queda de la forma::
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Cabecera de la clase
[modificadores] class  [extends ]
[implements ] [, [], ...,[]] &#123;
</pre>
        </div>
    </div>
    <p>
        En nuestro ejemplo de la clase Vehiculo teníamos la siguiente cabecera:
    </p>
    <div class="highlighted-code language-java">
        <pre>class Vehiculo &#123;
</pre>
    </div>
    <p>
        En este caso no hay
        <strong>
            modificadores
        </strong>
        , ni indicadores de
        herencia
        ,
        ni implementación de
        <strong>
            interfaces
        </strong>
        . Tan solo la palabra reservada class y el
        nombre de la clase. Es lo mínimo que puede haber en la cabecera de una clase.
    </p>
    <p>
        La
        <strong>
            herencia
        </strong>
        y las
        <strong>
            interfaces
        </strong>
        las verás más adelante. Vamos a
        ver ahora cuáles son los
        <strong>
            modificadores
        </strong>
        que se pueden indicar al crear la clase
        y qué efectos tienen. Los
        <strong>
            modificadores de clase
        </strong>
        son:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>[public] [final | abstract]
</pre>
        </div>
    </div>
    <p>
        Veamos qué significado tiene cada uno de ellos:
    </p>
    <ul class="lista_verificacion">
        <li>
            Modificador public. Indica que la clase es visible (se pueden crear objetos de esa clase)
            desde cualquier otra clase. Es decir, desde cualquier otra parte del programa. Si no se
            especifica este modificador, la clase sólo podrá ser utilizada desde clases que estén en el
            mismo
            <strong>
                paquete
            </strong>
            . Sólo puede haber una clase public (clase principal) en un
            archivo .java. El resto de clases que se definan en ese archivo no serán públicas.
        </li>
        <li>
            Modificador abstract. Indica que la clase es
            <strong>
                abstracta
            </strong>
            . Una clase
            abstracta
            <strong>
                no es
                instanciable
            </strong>
            . Es decir,
            <span class="destacado_inline">
          <strong>
           no es posible crear objetos de una clase abstracta
          </strong>
         </span>
            (habrá que utilizar clases que hereden de ella). En este momento es posible que te parezca
            que no tenga sentido que esto pueda suceder (si no puedes crear objetos de esa clase, ¿para
            qué la quieres?), pero puede resultar muy útil a la hora de crear una jerarquía de clases.
            Esto lo verás también más adelante al estudiar el concepto de
            <strong>
                herencia
            </strong>
            .
        </li>
        <li>
            Modificador final. Indica que no podrás crear clases que hereden de ella. También volverás a
            este modificador cuando estudies el concepto de
            <strong>
                herencia
            </strong>
            . Los modificadores
            final y
            <code>
                abstract
            </code>
            son excluyentes (sólo se puede utilizar uno de ellos al mismo
            tiempo).
        </li>
    </ul>
    <p>
        Todos estos modificadores y palabras reservadas las iremos viendo poco a poco, así que no te
        preocupes demasiado por intentar entender todas ellas en este momento.
    </p>
    <p>
        En el ejemplo anterior de la clase Vehiculo tendríamos una clase que sería sólo visible
        (utilizable) desde el mismo paquete en el que se encuentra la clase (modificador de acceso por
        omisión o de paquete, o package). Desde fuera de ese paquete no sería visible o accesible. Para
        poder utilizarla desde cualquier otra clase desde cualquier paquete bastaría con añadir el
        atributo public:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>public class Vehiculo &#123;
</pre>
        </div>
    </div>
    <div class="exe-tooltip-text" id="t1a331d7b-8e0d-dc71-ab02-f1b12f8bf78f">
        <p>
            Mecanismo mediante el cual una clase puede derivar de otra, a la que llamamos clase base,
            clase padre o superclase, de manera que la clase derivada extiende la funcionalidad de la
            clase base. Se trata de un caso de especialización.
        </p>
    </div>
    <div class="exe-tooltip-text" id="tf00552f3-fa85-f5f6-593a-b1d3ce3a8ba6">
        Una clase abstracta en Java
        es una clase que contiene al menos un método abstracto. Para declarar una clase abstracta en
        <span lang="en">
         Java
        </span>
        se utiliza el modificador abstract.
    </div>
</div><h1 class="title">
    3.3.- Cuerpo de una clase
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
        </div>
    </div>
    <p>
        Como ya has visto anteriormente, el cuerpo de una clase se encuentra encerrado entre llaves y
        contiene la declaración e implementación de sus miembros. Los miembros de una clase pueden
        ser:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                atributos
            </strong>
            , que especifican los datos que podrá contener un objeto de la
            clase,
        </li>
        <li>
            <strong>
                métodos
            </strong>
            , que implementan las acciones que se podrán realizar con un objeto
            de la clase (el comportamiento).
        </li>
    </ul>
    <p>
        Una clase puede no contener en su declaración atributos o métodos, pero debería contener al
        menos
        uno de los dos, pues una clase totalmente vacía no tiene ninguna utilidad.
    </p>
    <p>
        Ahora ha llegado el momento de empezar a pensar en qué atributos podría tener nuestra clase
        Vehiculo que estamos construyendo poco a poco. Algunos ejemplos de posibles atributos para
        nuestra clase podrían ser:
    </p>
    <ul class="lista_verificacion">
        <li>
            Nivel del depósito de combustible (un número real que exprese una cantidad en litros).
        </li>
        <li>
            Año de matriculación (un número entero).
        </li>
        <li>
            Estado del motor (si está apagado o arrancado).
        </li>
        <li>
            <abbr title="etcétera">
                etc
            </abbr>
            .
        </li>
    </ul>
    <p>
        Para cada uno de esos posibles atributos habrá que decidir qué
        <strong>
            nombre
        </strong>
        le
        asignamos (identificador) y qué
        <strong>
            tipo
        </strong>
        de
        <span lang="en">
         Java
        </span>
        le vamos a
        asociar (un tipo primitivo o bien algún tipo más complejo, como por ejemplo un String).
    </p>
    <p>
        Por ejemplo, podríamos plantearlo así:
    </p>
    <ul class="lista_verificacion">
        <li>
            Nivel del depósito de combustible: nombre nivelDeposito y tipo double.
        </li>
        <li>
            Año de matriculación: nombre matriculacion y tipo short. Podríamos haber usado int y también
            habría sido correcto, pero teniendo en cuenta va a ser siempre un número de cuatro cifras,
            es suficiente con un entero más pequeño (se utilizan menos
            <span lang="en">
          bytes
         </span>
            y
            por tanto ocupa menos memoria).
        </li>
        <li>
            Estado del motor: nombre estadoMotor y tipo boolean.
        </li>
    </ul>
    <p>
        ¿Y cómo expresaríamos eso en lenguaje
        <span lang="en">
         Java
        </span>
        ? Pues simplemente declarando
        esos atributos dentro del cuerpo de la clase como si fueran variables:
    </p>
    <div class="highlighted-code language-java">
        <pre>public class Vehiculo &#123;
  double  nivelDeposito;
  short   añoMatriculacion;
  boolean estadoMotor;
&#125;
</pre>
    </div>
    <p>
        Sencillo, ¿no? Pero, ¿y los métodos?
    </p>
    <p>
        Eso lo veremos un poco más adelante. Vamos a centrarnos primero en los atributos...
    </p>
</div><h1 class="title">
    4.- Atributos
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        Lo primero que
        <strong>
            María
        </strong>
        ha observado es que al principio suele haber
        algunas declaraciones de variables:
    </p>
    <p>
          <span class="st">
           —
          </span>
        ¿Estas declaraciones de variables son lo que hemos llamado
        atributos?
        <span class="st">
           —
          </span>
        le pregunta a
        <strong>
            Juan
        </strong>
        .
    </p>
    <p>
          <span class="st">
           —
          </span>
        Así es
        <span class="st">
           —
          </span>
        contesta
        <strong>
            Ada
        </strong>
        ,
        que en ese momento acaba de entrar por la puerta con
        <strong>
            Ana
        </strong>
        y con
        <strong>
            Carlos
        </strong>
        .
    </p>
    <p>
          <span class="st">
           —
          </span>
        Ahora que estáis todos juntos, creo que ha llegado el momento&nbsp;
        de que os explique algunas cosas acerca de los miembros de una clase. Vamos a empezar
        por los atributos.
    </p>
</div><h1 class="title">
    4.1.- Declaración de atributos
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
    </div>
    <div class="exe-figure exe-image float-right license-pd" style="width: 240px;">
    </div>
    <p>
        La sintaxis general para la declaración de un atributo en el interior de una clase es:
    </p>
    <div class="highlighted-code language-java">
        <pre>[modificadores] <tipo> <nombreAtributo>;</pre>
    </div>
    <p>
        Ejemplos:
    </p>
    <div class="highlighted-code language-java">
        <pre>int x;                                 // Un atributo de tipo int (entero)
static double descuentoGeneral;        // Un atributo de tipo double (real)
short numeroRuedas;                    // Un atributo de tipo short (entero corto)
float porcentajeDescuento;             // Un atributo de tipo double (real)
final boolean casado;                  // Un atributo de tipo boolean (lógico)
public static final int VALOR_MAXIMO;  // Un atributo de tipo int (entero) y constante
public String nombre;                  // Un atributo de tipo String (cadena de caracteres)
private LocalTime horaDeLlegada;       // Un atributo de tipo LocalTime (hora)
</pre>
    </div>
    <p>
        Te suena bastante, ¿verdad?
    </p>
    <p>
        La declaración de los atributos en una clase
        <strong>
            es exactamente igual a la declaración de
            cualquier variable
        </strong>
        tal y como has estudiado en las unidades anteriores y similar a como
        se hace en cualquier lenguaje de programación no necesariamente orientado a objetos. Es decir,
        mediante la indicación del tipo y a continuación el nombre del atributo.
    </p>
    <p>
        También puedes declarar a la vez varios atributos del mismo tipo mediante una lista de nombres
        separada por comas (exactamente como ya has estudiado al declarar variables). Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <pre>private StringBuilder nombre, apellido1, apellido2;   // Tres atributos de tipo StringBuilder (cadena de caracteres)
private double peso, altura;                          // Dos atributos de tipo double (real)
private final LocalDate fechaInicio, fechaFin;        // Dos atributos de tipo LocalDate (fecha)
</pre>
    </div>
    <p>
        La declaración de un
        <strong>
            atributo
        </strong>
        podría considerarse como la declaración de una
        variable que únicamente existe en el interior del objeto y, por tanto, su vida comenzará cuando
        el objeto comience a existir (el objeto sea creado por un
        <strong>
            constructor
        </strong>
        ). Esto
        significa que cada vez que se cree o instancie un objeto se crearán tantas variables "internas"
        como atributos contenga ese objeto en su interior (definidas en la clase, que es la plantilla o
        "molde" del objeto). Todas esas variables estarán encapsuladas dentro del objeto y solo tendrán
        sentido dentro de él. Podríamos decir que son "locales" al objeto y visibles desde cualquiera de
        sus métodos, pero no necesariamente visibles desde fuera. A los atributos también se les conoce
        con otros nombres como por ejemplo:
        <strong>
            propiedades
        </strong>
        ,
        <strong>
            campos
        </strong>
        ,
        <strong>
            variables miembro
        </strong>
        , o
        <strong>
            variables de objeto
        </strong>
        .
    </p>
    <p>
        <span>
         En el ejemplo de clase que estamos diseñando con objetos de tipo
        </span>
        Vehiculo
        <span>
         (instancias de la clase
        </span>
        Vehiculo
        <span>
         ), cada vez que se cree un nuevo vehículo
        </span>
        v1
        <span>
         , se crearán&nbsp; atributos
        </span>
        nivelDeposito
        <span>
         ,
        </span>
        matriculacion
        <span>
        </span>
        <span>
         y estadoMotor de tipo
        </span>
        double
        <span>
         , short y
         <code>
          boolean
         </code>
         que estarán en el interior de ese vehículo
        </span>
        v1
        <span>
         (algo así como variables "internas" que solo existen en el contexto de ese objeto vehículo v1). Si a continuación se crea un nuevo objeto
        </span>
        Vehiculo
        v2
        <span>
         , se crearán otros tres nuevos atributos
        </span>
        <span>
         nivelDeposito
         <span>
          ,
         </span>
         matriculacion
         <span>
         </span>
         <span>
          y estadoMotor de tipo
         </span>
         double
         <span>
          , short y
          <code>
           boolean
          </code>
         </span>
         que estarán esta vez alojados en el interior de
        </span>
        v2
        <span>
         . Y así con todos los objetos de tipo&nbsp;Vehiculo&nbsp;que instanciemos o creemos. Cada v1
         <span>
         </span>
         , v2
         <span>
         </span>
         , v3
         <span>
         </span>
         ,
         <abbr title="etcétera.">
          etc
         </abbr>
         <span>
         </span>
         ., tendrá sus propios valores para esos atributos (son vehículos independientes, cada uno con sus características específicas).
         <br>
        <br/></span>
    </p>
    <p>
        Dentro de la declaración de un atributo puedes encontrar tres partes:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Modificadores
            </strong>
            . Son palabras reservadas que permiten modificar la
            utilización del atributo (indicar el control de acceso, si el atributo es constante, si se
            trata de un atributo de clase o de objeto,
            <abbr title="etcétera.">
                etc
            </abbr>
            .). Los
            iremos viendo uno a uno. En los ejemplos anteriores ya has tenido la oportunidad de observar
            algunos de ellos como public,
            <code>
                private
            </code>
            ,&nbsp;static,
            <abbr title="etcétera">
                etc
            </abbr>
            .
        </li>
        <li>
            <strong>
                Tipo
            </strong>
            . Indica el tipo del atributo. Puede tratarse de un tipo primitivo (int
            <span>
          ,
         </span>
            char,
            <code>
                boolean
            </code>
            ,&nbsp;double,
            <abbr title="etcétera.">
                etc.
            </abbr>
            ) o bien de uno referenciado (objetos como por ejemplo&nbsp;String,
            <code>
                LocalDate
            </code>
            o StringBuilder, un
            <span lang="en">
          array
         </span>
            , otra clase
            implementada previamente por ti,
            <abbr title="etcétera.">
                etc.
            </abbr>
            ).
        </li>
        <li>
            <strong>
                Nombre
            </strong>
            . Identificador único para el nombre del atributo. Por convenio se
            <strong>
                suelen
                utilizar las minúsculas
            </strong>
            . En caso de que se trate de un identificador que contenga
            varias palabras,
            <strong>
                a partir de la segunda palabra se suele poner la letra de cada
                palabra en mayúsculas
            </strong>
            , tal y como ya hacíamos para declarar las variables
            (notación "
            <em>
          <span lang="en">
           camel case
          </span>
            </em>
            "). Por ejemplo:&nbsp;primerValor,
            <code>
                valor
            </code>
            ,
            puertaIzquierda,
            <code>
                cuartoTrasero
            </code>
            , equipoVecendor,
            <code>
                sumaTotal
            </code>
            ,
            nombreCandidatoFinal,
            <abbr title="etcétera.">
                etc
            </abbr>
            . Cualquier identificador válido de
            <span lang="en">
          Java
         </span>
            será admitido como nombre de atributo válido, pero
            <strong>
                es
                muy importante seguir este convenio
            </strong>
            para facilitar la legibilidad del
            código (todos los programadores de
            <span lang="en">
          Java
         </span>
            lo utilizan y
            nosotros también lo haremos). Si te fijas, es el
            <strong>
                mismo convenio que se utiliza para
                las variables
            </strong>
            . De este modo, cuando veamos un identificador que sigue ese
            convenio en cualquier parte del código sabremos rápidamente que se trata de un atributo o de
            una variable local.
        </li>
    </ul>
    <p>
        Y ahora, antes de seguir avanzando, ha llegado el momento de que nos tomemos unos minutos para
        reflexionar sobre este tema de la declaración de atributos y realicemos un pequeño ejercicio
        para consolidar lo que llevamos aprendido.
    </p>
</div><h1 class="title">
    4.2.- Modificadores de atributo
</h1>
<div class="iDevice_content">
    <div class="block iDevice_content" id="ta132_154">
        <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
        </div>
        <p>
         <span>
          Una vez realizada la reflexión anterior y habiendo resuelto un ejercicio que nos ha ayudado a asimilar las cuestiones más básicas de la declaración de un atributo (
          <strong>
           nombre
          </strong>
          y
          <strong>
           tipo
          </strong>
          ), podemos seguir avanzando y hablar de los
          <strong>
           modificadores para atributos
          </strong>
          . Como ya has visto, los atributos de una clase también pueden contener modificadores en su declaración (como sucedía al declarar la propia clase). Estos modificadores permiten indicar cierto comportamiento de un atributo a la hora de utilizarlo. Entre los modificadores de un atributo podemos distinguir
         </span>
            :
        </p>
        <ul class="lista_verificacion">
            <li>
                <strong>
                    modificadores de acceso
                </strong>
                (public,
                <code>
                    private
                </code>
                y protected).
                Indican la forma de acceso al atributo desde otra clase. Son modificadores excluyentes
                entre sí. Sólo se puede poner uno. De hecho ya estás utilizando el modificador&nbsp;private
                como norma general para la declaración de atributos tal y como te hemos recomendado;
            </li>
            <li>
                <strong>
                    modificadores de contenido
                </strong>
                (static y
                <code>
                    final
                </code>
                ). No son
                excluyentes. Pueden aparecer varios a la vez;
            </li>
            <li>
                <strong>
                    otros modificadores
                </strong>
                : transient y
                <code>
                    volatile
                </code>
                . El primero se
                utiliza para indicar que un atributo es transitorio (no persistente) y el segundo es
                para indicar al compilador que no debe realizar optimizaciones sobre esa variable. Lo
                más probable es que no necesites utilizarlos en este curso de introducción a la
                programación. Puedes olvidarte de ellos por ahora.
            </li>
        </ul>
        <p>
            Aquí tienes la sintaxis completa de la declaración de un atributo teniendo en cuenta la
            lista
            de todos los modificadores e indicando cuáles son compatibles o incompatibles entre
            ellos:
        </p>
        <div class="highlighted-code language-java">
            <pre>[private | protected | public] [static] [final] [transient] [volatile] <tipo> <nombreAtributo>;</pre>
        </div>
        <p>
            En los siguientes apartados estudiaremos con detalle cada uno de ellos.
        </p>
    </div>
</div><h1 class="title">
    4.3.- Modificadores de acceso
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        Los
        <strong>
            modificadores de acceso disponibles
        </strong>
        en
        <span lang="en">
         Java
        </span>
        para un
        atributo son:
    </p>
    <ul class="lista_verificacion">
        <li>
            modificador de acceso
            <strong>
                por omisión
            </strong>
            (o
            <strong>
                de paquete
            </strong>
            o
            <strong>
          <span lang="en">
           package
          </span>
            </strong>
            ). Si
            <strong>
                no se indica ningún modificador de
                acceso
            </strong>
            en la declaración del atributo, se utilizará este tipo de acceso. Se
            permitirá el acceso a este atributo desde todas las clases que estén dentro del
            <strong>
                mismo
                paquete
            </strong>
            (
            <strong>
          <span lang="en">
           package
          </span>
            </strong>
            ) que esta clase (la
            que contiene el atributo que se está declarando). No es necesario escribir ninguna palabra
            reservada. Si no se pone nada se supone que se desea indicar este modo de acceso;
        </li>
        <li>
            modificador de acceso public. Indica que
            <strong>
                cualquier clase
            </strong>
            (por muy ajena o
            lejana que esté) tiene acceso a ese atributo. No es muy habitual declarar atributos públicos
            (public);
        </li>
        <li>
            modificador de acceso private. Indica que sólo se puede acceder al atributo desde
            <strong>
                dentro
                de la propia clase
            </strong>
            . El atributo estará "oculto" para cualquier otra zona de código
            fuera de la clase en la que está declarado. Es lo opuesto a lo que permite public. Será para
            nosotros el
            <strong>
                modificador más habitual
            </strong>
            ;
        </li>
        <li>
            modificador de acceso protected. En este caso se permitirá acceder al atributo desde
            cualquier
            <strong>
                subclase
            </strong>
            (lo verás más adelante al estudiar la
            <strong>
                herencia
            </strong>
            ) de la clase en la que se encuentre declarado el atributo, y
            también desde las clases del
            <strong>
                mismo paquete
            </strong>
            .&nbsp; Es decir, cualquier clase
            del mismo paquete, pero también las subclases aunque estén en distinto paquete. En esta
            unidad no lo vamos a utilizar.
        </li>
    </ul>
    <p>
        A continuación puedes observar un resumen de los distintos niveles accesibilidad que permite
        cada
        modificador:
    </p>
    <table class="tabla">
        <caption>
            Cuadro de niveles accesibilidad a los atributos de una clase.
        </caption>
        <thead>
        <tr>
            <th scope="col">
                <p>
                    Modificador de acceso
                </p>
                <p>
                    (De menos restrictivo a más restrictivo)
                </p>
            </th>
            <th scope="col">
                Misma clase
            </th>
            <th scope="col">
                Cualquier clase
                <br>
                del mismo paquete
                <br/></th>
            <th scope="col">
                Cualquier subclase
                <br>
                de otro paquete
                <br/></th>
            <th scope="col">
                Cualquier clase
                <br>
                de otro paquete
                <br/></th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th id="paquete" scope="row">
                public
            </th>
            <td headers="paquete" style="text-align: center;">
           <span style="font-size: medium;">
            <strong>
             Sí
            </strong>
           </span>
            </td>
            <td style="text-align: center;">
           <span style="font-size: medium;">
            <strong>
             Sí
            </strong>
           </span>
            </td>
            <td headers="paquete" style="text-align: center;">
           <span style="font-size: medium;">
            <strong>
             Sí
            </strong>
           </span>
            </td>
            <td style="text-align: center;">
           <span style="font-size: medium;">
            <strong>
             Sí
            </strong>
           </span>
            </td>
        </tr>
        <tr>
            <th id="public" scope="row">
                &lt;code&gt;&lt;code&gt;protected
            </th>
            <td headers="public" style="text-align: center;">
           <span style="font-size: medium;">
            <strong>
             Sí
            </strong>
           </span>
            </td>
            <td headers="public" style="text-align: center;">
           <span style="font-size: medium;">
            <strong>
             Sí
            </strong>
           </span>
            </td>
            <td headers="public" style="text-align: center;">
           <span style="font-size: medium;">
            <strong>
             Sí
            </strong>
           </span>
            </td>
            <td headers="public" style="text-align: center;">
                No
            </td>
        </tr>
        <tr>
            <th id="private" scope="row">
                &lt;code&gt;Sin modificador (&lt;span lang="en"&gt;package&lt;/span&gt;)
            </th>
            <td headers="private" style="text-align: center;">
           <span style="font-size: medium;">
            <strong>
             Sí
            </strong>
           </span>
            </td>
            <td style="text-align: center;">
           <span style="font-size: medium;">
            <strong>
             Sí
            </strong>
           </span>
            </td>
            <td style="text-align: center;">
                No
            </td>
            <td style="text-align: center;">
                No
            </td>
        </tr>
        <tr>
            <th id="protected" scope="row">
                &lt;code&gt;private
            </th>
            <td headers="protected" style="text-align: center;">
                <strong>
            <span style="font-size: medium;">
             Sí
            </span>
                </strong>
            </td>
            <td headers="protected" style="text-align: center;">
                No
            </td>
            <td headers="protected" style="text-align: center;">
                No
            </td>
            <td style="text-align: center;">
                No
            </td>
        </tr>
        </tbody>
    </table>
</div><h1 class="title">
    4.4.- Modificadores de contenido (I): atributos constantes
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        Continuando con ejemplo de la clase Vehiculo, podríamos llegar a la siguiente conclusión
        respecto
        a los atributos:
    </p>
    <ol class="auto-numbered" style="list-style-type: decimal;">
        <li>
            algunos atributos no van a cambiar nunca de valor una vez se fabrique el vehículo;
        </li>
        <li>
            otros, sin embargo, podrán ir modificando su valor a lo largo del tiempo. En cada momento
            que se consulten, su valor puede ser diferente.
        </li>
    </ol>
    <p>
        En el primer caso estaríamos hablando de datos que una vez creado el objeto ya no tiene sentido
        que se modifique su valor. Es decir, se trata de características del objeto que forman parte de
        su "naturaleza" (podemos considerarlos como información "estructural" del objeto). Es algo que
        no va a cambiar a lo largo del tiempo y que va a permanecer inalterable. Algunos ejemplos
        podrían ser:
    </p>
    <div class="elemento_derecha">
        <div class="exe-figure exe-image position-center license-CC-BY-SA" style="width: 200px;">
        </div>
    </div>
    <ul class="lista_verificacion">
        <li>
            la
            <strong>
                capacidad del depósito de combustible
            </strong>
            del vehículo;
        </li>
        <li>
            la
            <strong>
                matrícula
            </strong>
            del vehículo;
        </li>
        <li>
            el
            <strong>
                año de matriculación
            </strong>
            o, si se prefiere, la
            <strong>
                fecha completa de
                matriculación
            </strong>
            del vehículo;
        </li>
        <li>
            la
            <strong>
                máxima velocidad
            </strong>
            que puede alcanzar el vehículo;
        </li>
        <li>
            el
            <strong>
                número de marchas
            </strong>
            del vehículo (si es que es de cambio manual);
        </li>
        <li>
            <abbr title="etcétera">
                etc
            </abbr>
            .
        </li>
    </ul>
    <p>
        Se trata claramente de valores que jamás van a cambiar para un vehículo concreto una vez
        creado.
    </p>
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        En el segundo caso, se trata de características que sí pueden cambiar con el tiempo y que
        podríamos decir que representarían su "estado". Algunos ejemplos podrían ser:
    </p>
    <ul class="lista_verificacion">
        <li>
            la
            <strong>
                velocidad actual
            </strong>
            a la que va el vehículo,
        </li>
        <li>
            el
            <strong>
                nivel actual de combustible
            </strong>
            en el depósito,
        </li>
        <li>
            la
            <strong>
                distancia recorrida
            </strong>
            hasta el momento,
        </li>
        <li>
            el
            <strong>
                estado del motor
            </strong>
            (si está apagado o encendido),
        </li>
        <li>
            <abbr title="etcétera">
                etc
            </abbr>
            .
        </li>
    </ul>
    <p>
        Cada uno de esos datos podrá ser diferente cada vez que se consulten. Tendrán un valor inicial
        al
        crearse el objeto e irán cambiando a lo largo del tiempo.
    </p>
    <p>
        Para implementar el primer grupo de atributos (atributos de "naturaleza" del objeto,
        inmutables),
        podemos utilizar un modificador de contenido que obligue a que ese valor sea constante, es
        decir, que una vez que se le asigne un valor, éste no pueda ser modificado. Para poder lograr
        esto en
        <span lang="en">
         Java
        </span>
        contamos con el
        <strong>
            modificador de contenido
        </strong>
        final.
    </p>
    <p>
        Para implementar el segundo grupo de atributos (atributos de "estado" del objeto, variables),
        simplemente podemos declararlos como lo hemos hecho hasta ahora. De este modo serán valores
        variables y no constantes.
    </p>
    <p>
        <strong>
            Los modificadores de contenido no son excluyentes
        </strong>
        (pueden aparecer varios para
        un mismo atributo). Son los siguientes:
    </p>
    <ul class="lista_verificacion">
        <li>
            modificador final. Indica que el atributo es una
            <strong>
                constante
            </strong>
            . Su valor no
            podrá ser modificado a lo largo de la vida del objeto. Por convenio, el nombre de los
            <strong>
                atributos constantes
            </strong>
            (final) se escribe con
            <strong>
                todas las letras en
                mayúsculas, separando las palabras con el carácter '_'
            </strong>
            . Aunque ahora vamos a
            ver una excepción;
        </li>
        <li>
            modificador static. Hace que el atributo sea común para todos los objetos de una misma
            clase. Es decir, todos los objetos de la clase compartirán ese mismo atributo con el mismo
            valor. Es un caso de miembro estático o miembro de clase: un
            <strong>
                atributo
                estático
            </strong>
            o
            <strong>
                atributo de clase
            </strong>
            o
            <strong>
                variable de
                clase
            </strong>
            .
        </li>
    </ul>
    <p>
        En el siguiente apartado sobre atributos estáticos verás ejemplos de atributos estáticos
        (static). Veamos ahora un ejemplo de atributos constantes (final).
    </p>
</div><h1 class="title">
    4.5.- Modificadores de contenido (II): atributos estáticos
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        Cada vez que se produce una instancia de una clase (es decir, cada vez que se crea un objeto de
        esa clase), se desencadenan una serie de procesos (construcción del objeto) que dan lugar a la
        reserva en memoria de un espacio físico que alojará al objeto creado (los
        <span lang="en">
         bytes
        </span>
        que ocupan sus atributos) así como a la asignación de valores
        iniciales a esos atributos. De esta manera
        <strong>
            cada objeto tendrá sus propios
            miembros
        </strong>
        a imagen y semejanza de la plantilla propuesta por la clase.
    </p>
    <p>
        En el caso de nuestra clase Vehiculo, cada vez que se instancie un objeto vehículo se ejecutará
        un mecanismo automático (construcción del objeto) que reservará espacio para cada uno de sus
        atributos (ocho
        <span lang="en">
         bytes
        </span>
        para el la capacidad del depósito, que es de tipo
        double; un
        <span lang="en">
         byte
        </span>
        para el estado del motor, que es de tipo boolean,
        <abbr title="etcétera">
            etc.
        </abbr>
        ).
    </p>
    <p>
        Supongamos ahora que nos ha pedido añadir un nuevo atributo a la clase que representa el número
        de vehículos que han sido creados hasta el momento. Podríamos llamarlo, por ejemplo,
        vehiculosCreados y podría ser de tipo entero (por ejemplo short). Ese atributo se incrementará
        en uno cada vez que se construya un nuevo vehículo. Si te fijas, ese valor será siempre el mismo
        para cualquier vehículo, pues en realidad no es una característica específica de cada vehículo
        en particular, sino una característica de todos los vehículos en general. Es decir, podríamos
        hablar de una característica de la propia clase más que de una característica de cada objeto.
        Este tipo de de atributos son conocidos con el nombre de
        <strong>
            atributos estáticos
        </strong>
        o
        <strong>
            atributos de clase
        </strong>
        , o
        <strong>
            variables de clase
        </strong>
        .
    </p>
    <p>
        <strong>
            Un atributo estático o de clase es común (el mismo) para todos los objetos de una misma
            clase
        </strong>
        . Podría decirse que la existencia del atributo no depende de la existencia de
        ningún objeto en particular, sino de la propia clase, y por tanto sólo habrá uno,
        independientemente del número de objetos que se creen, incluso aunque no exista aún ningún
        objeto. El atributo será siempre el mismo para todos los objetos y tendrá un valor único
        independientemente de cada objeto. Aunque no exista ningún objeto de esa clase, ése atributo sí
        existirá y contendrá un valor (pues se trata de un
        <strong>
            atributo de la clase
        </strong>
        más que
        del objeto). Por ejemplo, podríamos estar al inicio de un programa que utiliza vehículos pero
        sin haber creado todavía ninguno y aún así el atributo&nbsp;vehiculosCreados ya tendría un valor
        (valor cero). Puedo querer preguntar por el número de vehículos que se han creado, y asegurar
        que obtendré una respuesta al consultar ese atributo, aunque el número sea cero porque todavía
        no se ha creado ninguno.
    </p>
    <div class="exe-figure exe-image position-center license-CC-BY-NC-SA" style="width: 275px;">

        <div class="figcaption">
         <span class="author">
          Elaboración propia.
         </span>
            <span class="license">
          <span class="sep">
           (
          </span>
          CC BY-NC-SA
          <span class="sep">
           )
          </span>
         </span>
        </div>
    </div>
    <p style="text-align: center;">
        <strong>
         <span class="destacado_inline">
          Para indicar que un atributo es estático o de clase Java proporciona el modificador de contenido static.
         </span>
        </strong>
    </p>
    <p>
        En el caso de nuestro atributo&nbsp;vehiculosCreados para la clase Vehiculo simplemente habría
        que colocar delante el modificador static:
    </p>
    <div class="highlighted-code language-java">
        <pre>public class Vehiculo &#123;
  private static short vehiculosCreados;  // Cantidad de vehículos creados hasta el momento
  ...
  ...
&#125;</pre>
    </div>
    <p>
        De esta manera acabamos de añadir un atributo común (el mismo) para todos los objetos de una
        misma clase. Gracias al modificador static no se creará un atributo vehiculosCreados de tipo
        short cada vez que se instancie un objeto Vehiculo, sino que ese atributo existirá desde antes
        de la creación de ningún objeto (será una atributo de clase y no de instancia) y será compartido
        por todos los objetos&nbsp;Vehiculo que se vayan creando en tu programa.
    </p>
</div><h1 class="title">
    4.6.- Combinando modificadores
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        Una vez que hemos estudiado los modificadores más importantes, y dado que no todos son
        excluyentes entre sí, vamos a ver qué sentido o utilidad práctica podrían tener algunas de sus
        combinaciones. Recordemos la sintaxis completa de la declaración de un atributo teniendo en
        cuenta la lista de todos los modificadores:
    </p>
    <div class="highlighted-code language-java">
        <pre>[private | protected | public] [static] [final] [transient] [volatile];</pre>
    </div>
    <p>
        Quitando transient y
        <code>
            volatile
        </code>
        , que en este curso no los vamos a utilizar, podríamos
        tener a la vez hasta tres modificadores:
    </p>
    <ul class="lista_verificacion">
        <li>
            un
            <strong>
                modificador de acceso
            </strong>
            (según queramos que la visibilidad del atributo
            sea
            <strong>
                de paquete
            </strong>
            ,
            <strong>
                privada
            </strong>
            , "
            <strong>
                protegida
            </strong>
            " o
            <strong>
                pública
            </strong>
            ),
        </li>
        <li>
            un
            <strong>
                modificador de contenido
            </strong>
            final (si queremos que el atributo no pueda
            cambiar de valor, es decir, que sea
            <strong>
                constante
            </strong>
            y no variable),
        </li>
        <li>
            un
            <strong>
                modificador de contenido
            </strong>
            static (si queremos que el atributo sea
            <strong>
                de clase
            </strong>
            y no de objeto).
        </li>
    </ul>
    <p>
        Las combinaciones más habituales de modificadores que nos vamos a encontrar son las
        siguientes:
    </p>
    <table class="tabla">
        <caption>
            Combinación de modificadores en los atributos de una clase
        </caption>
        <tbody>
        <tr>
            <th scope="col">
                Acceso
            </th>
            <th scope="col">
                Mutabilidad
            </th>
            <th scope="col">
                De objeto/de clase
            </th>
            <th scope="col">
                Interpretación
            </th>
        </tr>
        <tr>
            <td>
                private
            </td>
            <td>
                final
            </td>
            <td>
            </td>
            <td>
                Atributo de objeto constante y privado.
            </td>
        </tr>
        <tr>
            <td>
                &lt;code&gt;private
            </td>
            <td>
            </td>
            <td>
            </td>
            <td>
                Atributo de objeto variable y privado.
            </td>
        </tr>
        <tr>
            <td>
                &lt;code&gt;&lt;code&gt;private
            </td>
            <td>
            </td>
            <td>
                static
            </td>
            <td>
                Atributo de clase variable y privado.
            </td>
        </tr>
        <tr>
            <td>
                &lt;code&gt;public
            </td>
            <td>
                final
            </td>
            <td>
                static
            </td>
            <td>
                Atributo de clase constante y público.
            </td>
        </tr>
        </tbody>
    </table>
    <p>
        <span style="font-size: 1em;">
        </span>
    </p>
    <p>
        <span style="font-size: 1em;">
         Salvo el último caso, nosotros ya hemos visto algunos ejemplos de esas combinaciones para nuestra clase
        </span>
        Vehiculo
        <span style="font-size: 1em;">
         :
        </span>
    </p>
    <ol class="auto-numbered" style="list-style-type: decimal;">
        <li>
            <strong>
                atributos de objeto constantes y privados
            </strong>
            : capacidadDeposito,
            <code>
                consumoMedio
            </code>
            ,
            fechaMatriculacion,
            <code>
                matricula
            </code>
            ;
        </li>
        <li>
            <strong>
                atributos de objeto variables y privados
            </strong>
            : nivelDeposito,
            <code>
                estadoMotor
            </code>
            , kilometrosTotales,
            <code>
                kilometrosParciales
            </code>
            ;
        </li>
        <li>
            <strong>
                atributos de clase variables y privados
            </strong>
            : vehiculosCreados,
            <code>
                kilometrosTotalesFlota
            </code>
            ,
            vehiculosArrancados.
        </li>
    </ol>
    <p>
        Si te fijas, la visibilidad de todos esos atributos es
        <strong>
            privada
        </strong>
        . No nos interesa
        que desde fuera de la clase se pueda observar o manipular el valor de esos atributos que
        conforman las caracerísticas de cada objeto vehículo particular (o, en el caso de los estáticos,
        características de la clase en general). Lo habitual, como ya hemos reiterado en varias
        ocasiones, es que los atributos sean privados.
    </p>
    <p>
        El cuarto ejemplo de combinación de modificadores que se propone es el de
        <strong>
            atributos de
            clase constantes
        </strong>
        . ¿Qué utilidad podría tener disponer de atributos de clase constantes?
        Una vez más, volvemos a nuestro modelo de la clase vehículo: por ejemplo, podría interesarnos
        tener almacenada cuál es la
        <strong>
            máxima y mínima capacidad del depósito de
            combustible
        </strong>
        para un vehículo. Está claro que la capacidad no puede ser negativa, ni
        tampoco cero. Nos tocaría a nosotros como diseñadores o como programadores decidir cuál va a ser
        la mínima capacidad que voy a permitir para un depósito de combustible. Y si no se cumple esa
        condición, no deberíamos dejar que construyera ese objeto de tipo depósito (eso veremos cómo
        hacerlo en el apartado de los constructores). Y lo mismo podríamos hacer respecto a la máxima
        capacidad que pueda tener el depósito de combustible de un vehículo. Tendremos que establecer un
        máximo y no es razonable que ese máximo esté definido por el máximo número representable por el
        tipo double, que podrían ser trillones de litros (no tendría mucho sentido).
    </p>
    <p>
        Por tanto, podríamos declarar un par de
        <strong>
            atributos constantes
        </strong>
        que definan la
        <strong>
            máxima y mínima capacidad que puede tener el depósito de combustible para cualquier
            objeto de la clase
        </strong>
        Vehiculo que pretendamos instanciar. Dado que es un valor
        independiente de cualquier objeto (son unos valores límite ya establecidos) parece más que
        justificado que se trate de atributos de clase y no de atributos de objeto. En consecuencia, ya
        tenemos nuestros dos primeros ejemplos de atributos constantes y de clase para nuestra clase
        Vehiculo:
    </p>
    <div class="highlighted-code language-java">
        <pre>final double MINIMA_CAPACIDAD_DEPOSITO;  // Minima capacidad posible de un depósito de combustible (en litros)
final double MAXIMA_CAPACIDAD_DEPOSITO;  // Máxima capacidad posible de un depósito de combustible (en litros)
</pre>
    </div>
    <p>
        Dado que se trata de constantes cuyo valor se conoce ya en tiempo de compilación (no van a
        depender de ningún objeto), podemos asignarles valor a la vez que se realiza la declaración. Por
        ejemplo, podríamos considerar que un vehículo no puede tener un depósito con una capacidad
        inferior a 10.0 litros ni superior a 150.0 litros. En tal caso tendríamos:
    </p>
    <div class="highlighted-code language-java">
        <pre>final double MINIMA_CAPACIDAD_DEPOSITO =  10.0; // Minima capacidad posible de un depósito de combustible (en litros)
final double MAXIMA_CAPACIDAD_DEPOSITO = 150.0; // Máxima capacidad posible de un depósito de combustible (en litros)
</pre>
    </div>
    <p>
        Respecto a la
        <strong>
            visibilidad
        </strong>
        de estos atributos, se ha indicado que podría ser
        <strong>
            pública
        </strong>
        , algo que normalmente evitamos. ¿Por qué en este caso sí podría
        interesarnos que fueran atributos públicos? Pues porque se trata de
        <strong>
            valores límite que
            son de interés para otro programador que vaya a utilizar esta clase
        </strong>
        . De esta manera
        se podrá tener acceso a esos valores para evitar posibles errores a la hora de definir vehículos
        que no cumplan con esas restricciones. Por otro lado, al tratarse de atributos constantes,
        aunque se pueda tener acceso a su valor, no podrán ser modificados, por lo que no se corre
        ningún riesgo de integridad respecto al estado de los objetos. Es uno de los pocos casos en los
        que es positivo evitar la privacidad, pues estamos dando información útil al usuario de esta
        clase y además no pueden ser modificados.
    </p>
    <p>
        Por tanto, la declaración de estos atributos quedará finalmente como
        <strong>
            pública
        </strong>
        :
    </p>
    <div class="highlighted-code language-java">
        <pre>public final double MINIMA_CAPACIDAD_DEPOSITO =  10.0;  // Minima capacidad posible de un depósito de combustible (litros)
public final double MAXIMA_CAPACIDAD_DEPOSITO = 150.0;  // Máxima capacidad posible de un depósito de combustible (litros)</pre>
    </div>
</div><h1 class="title">
    4.7.- Objetos inmutables
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        En algunas ocasiones te has encontrado con clases de la
        <abbr title="Application Programming Interface">
            API
        </abbr>
        de
        <span lang="en">
         Java
        </span>
        que se dice que son "inmutables", es decir, que los objetos instancia
        de esas clases no podían ser modificados. En realidad sería más apropiado hablar de
        <strong>
            objetos
            inmutables
        </strong>
        . Algunos ejemplos podrían ser:
    </p>
    <ul class="lista_verificacion">
        <li>
            la clase String, que almacena cadenas de caracteres,
        </li>
        <li>
            todas las
            <strong>
                clases envoltorio
            </strong>
            ("
            <em>
          <span lang="en">
           wrapper
          </span>
            </em>
            ") de
            los tipos primitivos (Byte,
            <code>
                Short
            </code>
            , Integer,
            <code>
                Long
            </code>
            , String,
            <code>
                Float
            </code>
            ,
            Double,
            <code>
                Boolean
            </code>
            , Character),
        </li>
        <li>
            las clases de manejo del tiempo LocalDate,
            <code>
                LocalTime
            </code>
            y LocalDateTime.
        </li>
    </ul>
    <p>
        En todos esos casos cada vez que se crea un objeto instancia de alguna de esas clases, el objeto
        no puede ser modificado. Si se lleva a cabo alguna operación con ellos que da lugar a alguna
        modificación se obtiene un nuevo objeto con esa modificación pero el objeto original permanece
        inalterado.
    </p>
    <p>
        <strong>
            ¿Cómo podemos nosotros implementar una clase que sea inmutable?
        </strong>
    </p>
    <p>
        Para ello es necesario que absolutamente
        <strong>
            todos sus atributos sean inmutables
        </strong>
        , es
        decir,
        <strong>
            constantes
        </strong>
        . En el caso del lenguaje
        <span lang="en">
         Java
        </span>
        , tendrás
        que declarar todos sus atributos como final.
    </p>
    <p>
        Además, la propia clase deberá ser declarada como final. El significado de que una clase
        sea&nbsp;final
        lo veremos en la próxima unidad cuando estudiemos la herencia. Baste decir por el momento que si
        una clase es final, no se puede implementar otra clase que sea descendiente de ella (no permite
        la herencia).
    </p>
    <p>
        Por tanto, la estructura básica de una clase para que sea inmutable será:
    </p>
    <div class="highlighted-code language-java">
        <pre>public final class <NombreClase> &#123;
  private final <tipoAtributo1> nombreAtributo1;
  private final <tipoAtributo2> nombreAtributo2;
  private final <tipoAtributo3> nombreAtributo3;
  ...
</pre>
    </div>
    <p>
        Todos los atributos&nbsp;final y la propia clase también final.
    </p>
</div><h1 class="title">
    5.- Métodos
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
          <span class="st">
           —
          </span>
        Ya tengo pensadas algunas de las acciones que van a ser
        necesarias para manipular los atributos de los objetos instancias de la clase&nbsp;Vehiculo
        <span class="st">
           —
          </span>
        le dice
        <strong>
            María
        </strong>
        a
        <strong>
            Juan
        </strong>
        .
    </p>
    <p>
          <span class="st">
           —
          </span>
        Muy bien. Entonces es el momento de empezar a definir métodos.
    </p>
    <p>
          <span class="st">
           —
          </span>
        Perfecto. ¿Y cómo lo hacemos? Cuando hemos utilizado objetos de
        clases ya incorporadas en el lenguaje, simplemente he utilizado sus métodos, pero aún no
        he declarado ninguno.
    </p>
    <p>
          <span class="st">
           —
          </span>
        No te preocupes, vamos a ver algunos ejemplos de declaración,
        implementación y utilización de métodos de una clase. Verás como es mucho más sencillo
        de lo que piensas.
    </p>
</div><h1 class="title">
    5.1.- Declaración de un método
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-CC-BY-NC-SA" style="width: 250px;">

        <div class="figcaption">
         <span class="author">
          Elaboración propia.
         </span>
            (

            CC BY-NC-SA

            )
        </div>
    </div>
    <p>
        La definición de un método se compone de dos partes:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                cabecera del método
            </strong>
            , que contiene el
            <strong>
                nombre
            </strong>
            del método
            junto con el
            <strong>
                tipo devuelto
            </strong>
            , (void en caso de que no devuelva nada), un
            conjunto de posibles modificadores y una lista de parámetros o argumentos entre paréntesis
            (si no hay argumentos, se pondrá un paréntesis vacío);
        </li>
        <li>
            <strong>
                cuerpo del método
            </strong>
            , que contiene las sentencias que implementan el
            comportamiento del método.
        </li>
    </ul>
    <p>
        Los
        <strong>
            elementos mínimos
        </strong>
        que deben aparecer en la declaración de un método son:
    </p>
    <ul class="lista_verificacion">
        <li>
            el tipo devuelto por el método;
        </li>
        <li>
            el nombre del método;
        </li>
        <li>
            los paréntesis;
        </li>
        <li>
            el cuerpo del método entre llaves: &#123; &#125;.
        </li>
    </ul>
    <p>
        Veamos un par de ejemplos de posibles métodos para nuestra clase Vehiculo, que venimos modelando
        desde el comienzo de la unidad.
    </p>
    <p>
        <strong>
            Primer ejemplo: método getNivelDeposito
        </strong>
    </p>
    <p>
        Este método podría servirnos para
        <strong>
            obtener la cantidad de combustible que queda en el
            depósito del vehículo
        </strong>
        . En este caso la cabecera debería contener como mínimo:
    </p>
    <ul class="lista_verificacion">
        <li>
            el
            <strong>
                tipo devuelto
            </strong>
            por el método: double;
        </li>
        <li>
            el
            <strong>
                nombre
            </strong>
            del método: getNivelDeposito;
        </li>
        <li>
            no recibe
            <strong>
                ningún parámetro
            </strong>
            : aparece una lista vacía entre paréntesis: ().
        </li>
    </ul>
    <p>
        Esos tres elementos conformarían la cabecera del método, que quedaría más o menos así:
    </p>
    <div class="highlighted-code language-java">
        <pre>double getNivelDepoisto () &#123;
  // Cuerpo del método
  ...
&#125;</pre>
    </div>
    <p>
        El
        <strong>
            cuerpo
        </strong>
        del método sería el código que habría encerrado entre llaves, que aquí
        representamos por un comentario y unos puntos suspensivos dentro de &#123; &#125;. Ya lo "rellenaremos"
        cuando veamos el cuerpo del método.
    </p>
    <p>
        Dentro del cuerpo del método podrás encontrar declaraciones de variables, sentencias y todo tipo
        de estructuras de control (bucles, condiciones,
        <abbr title="etcétera.">
            etc.
        </abbr>
        ) que has
        estudiado en los apartados anteriores. Podemos imaginar el cuerpo de un método como un "mini
        programa".
    </p>
    <p>
        <strong>
            Segundo ejemplo: método arrancar
        </strong>
    </p>
    <p>
        Un método con ese nombre podría servirnos para arrancar el motor del vehículo. En este caso la
        cabecera estaría formada por:
    </p>
    <ul class="lista_verificacion">
        <li>
            el
            <strong>
                tipo devuelto
            </strong>
            por el método: void. (no devolvería nada, simplemente
            llevaría a cabo la acción de arrancar el motor del vehículo);
        </li>
        <li>
            el
            <strong>
                nombre
            </strong>
            del método:
            <strong>
                arrancar
            </strong>
            ;
        </li>
        <li>
            <strong>
                ningún parámetro
            </strong>
            : aparece una lista vacía entre paréntesis: ().
        </li>
    </ul>
    <p>
        La cabecera de este segundo método quedaría entonces más o menos así:
    </p>
    <div class="highlighted-code language-java">
        <pre>void arrancar () &#123;
  // Cuerpo del método
  ...
&#125;</pre>
    </div>
    <p>
        Ahora bien, sabemos que la declaración de un método puede incluir algunos elementos más. Vamos a
        estudiar con detalle cada uno de ellos.
    </p>
</div><h1 class="title">
    5.2.- Cabecera de un método
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        La declaración de un método puede incluir los siguientes elementos:
    </p>
    <ol>
        <li>
            <strong>
                modificadores
            </strong>
            (como por ejemplo los modificadores de acceso ya vistos:
            public, protected o
            <code>
                private
            </code>
            ). No es obligatorio incluir modificadores en la
            declaración;
        </li>
        <li>
            el
            <strong>
                tipo devuelto
            </strong>
            (o tipo de retorno), que consiste en el tipo de dato
            (primitivo o referencia) que el método devuelve tras ser ejecutado. Si eliges void como tipo
            devuelto, el método no devolverá ningún valor;
        </li>
        <li>
            el
            <strong>
                nombre del método
            </strong>
            , aplicándose el mismo convenio que para los atributos
            y las variables (primera palabra con todas las letras en minúscula y el resto de palabras
            con la primera letra en mayúscula);
        </li>
        <li>
            una
            <strong>
                lista de parámetros
            </strong>
            separados por comas y entre paréntesis, donde cada
            parámetro debe ir precedido por su tipo. Si el método no tiene parámetros la lista estará
            vacía y únicamente aparecerán los paréntesis;
        </li>
        <li>
            una
            <strong>
                lista de
            </strong>
            excepciones
            que el método puede lanzar. Se utiliza la palabra reservada throws seguida de una lista de
            nombres de excepciones separadas por comas. No es obligatorio que un método incluya una
            lista de excepciones, aunque muchas veces será conveniente. En unidades anteriores ya has
            trabajado con el concepto de excepción y más adelante volverás a hacer uso de ellas;
        </li>
        <li>
            el
            <strong>
                cuerpo del método
            </strong>
            , encerrado entre llaves. El cuerpo contendrá el código
            del método (una lista sentencias y estructuras de control en lenguaje
            <span lang="en">
          Java
         </span>
            ) así como la posible declaración de variables locales.
        </li>
    </ol>
    <div class="exe-figure exe-image float-right license-CC-BY-NC-SA" style="width: 220px;">

        <div class="figcaption">
         <span class="author">
          Elaboración propia
         </span>
            (

            CC BY-NC-SA

            )
        </div>
    </div>
    <p>
        <br>
        La sintaxis general de la cabecera de un método podría entonces quedar así:
        <br/></p>
    <div class="highlighted-code language-java">
        <pre>[private | protected | public] [static] [abstract] [final] [native] [synchronized]
  ( [] ) [throws ]
</pre>
    </div>
    <p>
        Como sucede con todos los identificadores en
        <span lang="en">
         Java
        </span>
        (variables, clases,
        objetos, métodos,
        <abbr title="etcétera.">
            etc.
        </abbr>
        ), puede usarse cualquier identificador que
        cumpla las normas. Ahora bien, para mejorar la legibilidad del código, se ha establecido el
        siguiente convenio para nombrar los métodos:
        <strong>
            utilizar un verbo en minúscula o bien
            varias palabras comenzando por un verbo en minúscula, seguido por adjetivos, nombres,
            <abbr title="etcétera.">
                etc.
            </abbr>
            , los cuales sí aparecerán comenzando en
            mayúsculas
        </strong>
        .
    </p>
    <p>
        Algunos ejemplos de nombres de métodos que siguen este convenio podrían ser: ejecutar,
        <code>
            romper
        </code>
        ,
        mover,
        <code>
            subir
        </code>
        , responder,
        <code>
            obtenerX
        </code>
        , getX,
        <code>
            establecerValor
        </code>
        ,
        setValor,
        <code>
            estaVacio
        </code>
        , isVacio,
        <code>
            estaLleno
        </code>
        , moverFicha,
        <code>
            subirPalanca
        </code>
        ,
        responderRapido,
        <code>
            girarRuedaIzquierda
        </code>
        , abrirPuertaDelantera,
        <code>
            cambiarMarcha
        </code>
        , getNivelDeposito,
        <code>
            respostar
        </code>
        , arrancar,
        <code>
            parar
        </code>
        , recorrerTrayecto,
        <code>
            reset
        </code>
        ,
        <abbr title="etcétera.">
            etc.
        </abbr>
    </p>
    <p>
        En nuestro proyecto de la clase Vehiculo, podríamos definir algunos métodos como por ejemplo:
    </p>
    <table class="tabla">
        <caption>
            Ejemplos de nombres de métodos para la clase Vehiculo
        </caption>
        <tbody>
        <tr>
            <th scope="col">
                Posible nombre del método
            </th>
            <th scope="col">
                Descripción
            </th>
        </tr>
        <tr>
            <td>
                obtenerNivelDeposito&nbsp;o
                <code>
                    getNivelDeposito
                </code>
            </td>
            <td>
                Devuelve la cantidad de combustible que queda en el depósito del vehículo.
            </td>
        </tr>
        <tr>
            <td>
                arrancar
            </td>
            <td>
                Arranca el motor del vehículo.
            </td>
        </tr>
        <tr>
            <td>
                parar
            </td>
            <td>
                Para el motor del vehículo.
            </td>
        </tr>
        <tr>
            <td>
                repostar
            </td>
            <td>
                Introduce una cantidad determinada de combustible en el depósito del vehículo.
            </td>
        </tr>
        <tr>
            <td>
                estaArrancado o
                <code>
                    isArrancado
                </code>
            </td>
            <td>
                Indica si el vehículo está arrancado o no.
            </td>
        </tr>
        <tr>
            <td>
                recorrerTrayecto
            </td>
            <td>
                Recorre un determinado trayecto con el vehículo.
            </td>
        </tr>
        </tbody>
    </table>
    <p>
    </p>
    <div class="exe-tooltip-text" id="t1ba59861-0c71-44f2-0e33-1cb28ccd5253">
        <p>
            Situación anómala durante la ejecución de un programa. En
            <span lang="en">
          Java
         </span>
            cuando
            se produce algún tipo de error se lanza una excepción.
        </p>
    </div>
</div><h1 class="title">
    5.3.- Modificadores en la declaración de un método
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 250px;">
    </div>
    <p>
        <br>
        En la declaración de un método también pueden aparecer modificadores (como en la declaración
        de la clase o de los atributos). Un método puede tener los siguientes tipos de modificadores:
        <br/></p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                modificadores de acceso
            </strong>
            . Son los mismos que en el caso de los atributos
            (por omisión o de paquete, public,
            <code>
                private
            </code>
            y protected) y tienen el mismo
            cometido (acceso al método sólo por parte de clases del mismo paquete, o por cualquier parte
            del programa, o sólo para la propia clase, o también para las subclases aunque estén en otro
            paquete);
        </li>
        <li>
            <strong>
                modificadores de contenido
            </strong>
            . Son también los mismos que en el caso de los
            atributos (static y
            <code>
                final
            </code>
            ), aunque su significado no es exactamente el mismo;
        </li>
        <li>
            <strong>
                otros modificadores
            </strong>
            (no son aplicables a los atributos, sólo a los
            métodos): abstract,
            <code>
                native
            </code>
            , synchronized.
        </li>
    </ul>
    <div class="elemento_derecha">
    </div>
    <p>
        Un método static&nbsp;(método
        <strong>
            estático
        </strong>
        o
        <strong>
            de clase
        </strong>
        ) es un método
        desde cuya implementación no se accede a atributos de objeto. Desde este tipo de métodos sólo se
        puede acceder a atributos de la clase (estáticos).
        <strong>
         <span class="destacado_inline">
          Estos métodos pueden ser invocados sin necesidad de tener un objeto de la clase instanciado.
         </span>
        </strong>
    </p>
    <p>
        En
        <span lang="en">
         Java
        </span>
        puedes encontrar una gran cantidad de métodos estáticos en la
        clase Math. De hecho, todos sus métodos son todos estáticos (Math.abs,
        <code>
            Math.sin
        </code>
        ,
        Math.cos,
        <abbr title="etcétera.">
            etc.
        </abbr>
        ). La llamada a métodos estáticos se hace
        normalmente usando el nombre de la propia clase y no el de una instancia (objeto), pues se trata
        realmente de un método de clase.
    </p>
    <p>
        Un método final es un método que no permite ser redefinido o sobreescrito por las clases
        descendientes de la clase a la que pertenece el método. Volverás a ver este modificador, así
        como el concepto de redefinición o sobreescritura de métodos cuando estudies en detalle la
        <strong>
            herencia
        </strong>
        .
        <strong>
            En esta unidad no lo vamos a usar
        </strong>
        .
    </p>
    <p>
        El modificador native es utilizado para señalar que un método ha sido implementado en código
        nativo (en un lenguaje que ha sido compilado a lenguaje máquina, como por ejemplo
        <strong>
            C
        </strong>
        o
        <strong>
            <abbr title="C pus plus, C orientado a objetos.">
                C++
            </abbr>
        </strong>
        ). En estos casos
        simplemente se indica la cabecera del método, pues no tiene cuerpo escrito en
        <span lang="en">
         Java
        </span>
        .
        <strong>
            No lo utilizaremos en este curso
        </strong>
        .
    </p>
    <p>
        El modificador abstract sirve para indicar que un método es
        abstracto
        , esto es, un método sin
        implementación (no hay cuerpo, solo la declaración terminada en punto y coma, en lugar de las
        llaves con el cuerpo). Es importante el detalle del punto y coma: un método con un cuerpo vacío,
        es decir, con llaves de apertura y cierre, pero ninguna sentencia entre ellas
        <strong>
            no sería
            un método abstracto
        </strong>
        , simplemente sería un método inútil que no hace nada. La
        implementación será realizada en las clases descendientes. Un método sólo puede ser declarado
        como abstract si se encuentra dentro de una clase abstract. Usarás este modificador en unidades
        posteriores cuando trabajes con la
        <strong>
            herencia
        </strong>
        .
        <strong>
            En esta unidad haremos uso
            de él
        </strong>
        .
    </p>
    <p>
        Por último, si un método ha sido declarado como synchronized, el entorno de ejecución obligará a
        que cuando un proceso esté ejecutando ese método, el resto de procesos que tengan que llamar a
        ese mismo método deberán esperar a que el otro proceso termine. Puede resultar útil si sabes que
        un determinado método va a poder ser llamado concurrentemente por varios procesos a la vez.
        <strong>
            Tampoco lo vamos a utilizar en este curso
        </strong>
        .
    </p>
    <div class="exe-tooltip-text" id="t5259adae-0f41-d59c-07f5-a4d685d20c0a">
        Un método abstracto en
        <span lang="en">
         Java
        </span>
        es aquel para el que la clase en la que se declara no proporciona
        una implementación. Es decir, no tiene cuerpo, sólo cabecera. Si una clase dispone de al menos
        un método abstracto se dice que es una clase abstracta. Toda clase que herede (sea subclase) de
        una clase abstracta debe implementar todos los métodos abstractos de su superclase o bien
        volverlos a declarar como abstractos (y por tanto también sería abstracta). Para declarar un
        método abstracto en
        <span lang="en">
         Java
        </span>
        se utiliza el modificador abstract, al igual que
        para declarar que la propia clase es abstracta también se usa abstract.
    </div>
</div><h1 class="title">
    5.4.- Parámetros en un método
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
    </div>
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        La lista de parámetros de un método se coloca tras el nombre del método. Esta lista estará
        constituida por pares de la forma "&lt;tipoParametro&gt; &lt;nombreParametro&gt;". Cada uno de
        esos pares estará separado por comas y la lista completa estará encerrada entre paréntesis:
    </p>
    <div class="highlighted-code language-java">
        <pre> nombreMetodo (  ,  , ...,   )
</pre>
    </div>
    <p>
        Si se trata de un método que no recibe parámetros, es decir,&nbsp; la lista de parámetros está
        vacía, tan solo aparecerán los paréntesis, pero éstos deben aparecer siempre:
    </p>
    <div class="highlighted-code language-java">
        <pre> nombreMetodo ( )
</pre>
    </div>
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        A la hora de declarar un método, debes tener en cuenta lo siguiente:
    </p>
    <ul class="lista_verificacion">
        <li>
            puedes incluir cualquier cantidad de parámetros. Se trata de una decisión del programador,
            pudiendo ser incluso una lista vacía;
        </li>
        <li>
            los parámetros podrán ser de cualquier tipo (tipos primitivos, referencias, objetos,
            <span lang="en">
          arrays
         </span>
            ,
            <abbr title="etcétera.">
                etc.
            </abbr>
            );
        </li>
        <li>
            no está permitido que el nombre de una variable local del método coincida con el nombre de
            un parámetro;
        </li>
        <li>
            no puede haber dos parámetros con el mismo nombre. Se produciría ambigüedad;
        </li>
        <li>
            si el nombre de algún parámetro coincide con el nombre de un atributo de la clase, éste será
            "ocultado" por el parámetro. Es decir, al indicar ese nombre en el código del método estarás
            haciendo referencia al parámetro y no al atributo. Para poder acceder al atributo tendrás
            que hacer uso del operador de autorreferencia this, que verás un poco más adelante;
        </li>
        <li>
            en
            <span lang="en">
          Java
         </span>
            el
            <strong>
                paso de parámetros es siempre por valor
            </strong>
            ,
            excepto en el caso de los tipos referenciados (por ejemplo los objetos) en cuyo caso se está
            pasando efectivamente una referencia. La referencia (el objeto en sí mismo) no podrá ser
            cambiada pero sí elementos de su interior (atributos) a través de sus métodos o por acceso
            directo si se trata de un miembro público.
        </li>
    </ul>
</div><h1 class="title">
    5.4.1.- Listas de parámetros variables
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="exe-figure exe-image position-right license-pd" style="width: 200px;">
        </div>
    </div>
    <p>
        En el lenguaje
        <span lang="en">
         Java
        </span>
        es posible utilizar una construcción especial llamada
        varargs (
        <strong>
            argumentos variables
        </strong>
        ) que permite que un método pueda tener un número
        variable de parámetros. Para utilizar este mecanismo se coloca un tipo, unos
        <strong>
            puntos
            suspensivos
        </strong>
        (tres puntos: "..."), un espacio en blanco y a continuación el nombre
        del parámetro que aglutinará la lista de argumentos variables.
    </p>
    <div class="highlighted-code language-java">
        <pre>  (... )
</pre>
    </div>
    <p>
        Es posible además mezclar el uso de varargs con parámetros fijos. En tal caso,
        <strong>
            la lista
            de parámetros variables debe aparecer al final (y sólo puede aparecer una).
        </strong>
    </p>
    <p>
        En realidad se trata una manera transparente para el usuario del método de pasar un
        <span lang="en">
         array
        </span>
        con un número variable de elementos para no tener que hacerlo
        manualmente. Dentro del método habrá que ir recorriendo el
        <span lang="en">
         array
        </span>
        para ir
        obteniendo cada uno de los elementos de la lista de argumentos variables. Ya veremos algún caso
        de uso cuando tratemos el cuerpo de los métodos.
    </p>
    <p>
        Veamos ahora un ejemplo. Supongamos que tenemos una clase que contiene un método llamado sumar
        que necesita recibir como parámetros varios elementos de tipo real para ser sumados.
        Inicialmente podríamos pensar en escribir varias versiones de métodos de suma con cada
        posibilidad (un parámetro, dos parámetros, tres parámetros, etc.):
    </p>
    <div class="highlighted-code language-java">
        <pre>public void sumarUnElemento (double elemento)
public void sumarDosElementos (double elemento1, double elemento2)
public void sumarTresElementos (double elemento1, double elemento2, double elemento3)
...
</pre>
    </div>
    <p>
        Lo cual podría ser bastante tedioso y redundante. Para evitar esa situación, podríamos utilizar
        esta construcción, que nos permitiría tener la posibilidad de disponer de un número
        indeterminado de parámetros, todos del mismo tipo:
    </p>
    <div class="highlighted-code language-java">
        <pre>public void sumarElementos (double... elementos)
</pre>
    </div>
    <p>
        Si quisiéramos combinar esa construcción con algún otro parámetro "fijo", tendríamos que colocar
        ese parámetro o parámetros al principio. Por ejemplo si además de los elementos que se desean
        sumar se requieren otros dos parámetros (seccion de tipo String y
        <code>
            unidad
        </code>
        de tipo
        int), habría que ubicarlos delante de la especificación de parámetros variables:
    </p>
    <div class="highlighted-code language-java">
        <pre>public void sumarElementos (String seccion, int unidad, double... elementos)
</pre>
    </div>
    <p>
        De esta manera tendríamos dos parámetros "fijos" (de tipo String e
        <code>
            int
        </code>
        respecitvamente) junto con un número variable de parámetros de tipo double.
    </p>
</div><h1 class="title">
    5.4.2.- Modificador final en los parámetros
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        Ya hemos visto que el modificador final aplicado a variables y atributos significa que su valor
        no puede ser modificado una vez que se realiza una primera asignación.
    </p>
    <p>
        En
        <span lang="en">
         Java
        </span>
        también se permite añadir el modificado&nbsp;final&nbsp;a los
        parámetros de un método y tiene un significado similar: el valor del parámetro no podrá ser
        modificado dentro del método. Si el parámetro no incluye ese modificador, el valor en el
        interior del parámetro podría ser modificado dentro del método si así se decidiera hacer.
    </p>
    <p>
        Es decir, que sería lícito realizar modificaciones de parámetros como por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <pre>private void metodo (int v1, int v2, int v3) &#123;
  v1 += 10;
  v2 += 20;
  v3 += 30;
&#125;
</pre>
    </div>
    <p>
        Ahora bien, eso no suele tener mucho sentido. Si queremos hacer alguna modificación de un
        parámetro de entrada, lo más razonable sería disponer de variables locales que almacenaran el
        resultado de esa modificación y dejar a los parámetros con su valor original por si más
        adelante, dentro del mismo método, volviéramos a necesitar ese valor. Por ejemplo haciendo algo
        así:
    </p>
    <div class="highlighted-code language-java">
        <pre>private void metodo (int v1, int v2, int v3) &#123;
  int x1, x2, x3
  x1= v1 + 10;
  x2= v1 + 20;
  x3= v3 + 30;
&#125;
</pre>
    </div>
    <p>
        Pero, si quisiéramos evitar que todos los parámetros (o bien sólo algunos) pudieran ser
        modificados desde dentro del método para evitar, por ejemplo, una posible confusión por parte
        del programador,
        <span lang="en">
         Java
        </span>
        proporciona la posibilidad de declarar esos
        parámetros como final:
    </p>
    <div class="highlighted-code language-java">
        <pre>private void metodo (final int v1, final  int v2, final int v3) &#123;
  int x1, x2, x3
  x1= v1 + 10;
  x2= v1 + 20;
  x3= v3 + 30;
&#125;
</pre>
    </div>
    <p>
        De ese modo, si se intentara hacer una modificación de algunos de los parámetros como por
        ejemplo
        una asignación del tipo v1 +=10,
        <span lang="en">
         Java
        </span>
        no lo permitiría y se produciría un
        error de compilación.
    </p>
    <p>
        En cualquier caso, dado que en
        <span lang="en">
         Java
        </span>
        el paso de parámetros es siempre por
        valor (también conocido como "por copia") ese cambio sólo afectaría al interior del método y no
        al valor que se pasa como parámetro en la invocación. En ese sentido no hay peligro alguno.
    </p>
</div><h1 class="title">
    5.5.- Cuerpo de un método
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-CC-BY-NC-SA" style="width: 175px;">

        <div class="figcaption">
            <div class="elemento_centrado">
          <span class="author">
           Elaboración propia
          </span>
                <span class="license">
           <span class="sep">
            (
           </span>
           CC BY-NC-SA
           <span class="sep">
            )
           </span>
          </span>
            </div>
        </div>
    </div>
    <p>
        Por fin ha llegado el momento de que empecemos a escribir las líneas de código que conforman un
        método, esto es, el
        <strong>
            cuerpo del método
        </strong>
        .
    </p>
    <p>
        El interior de un método (cuerpo) está compuesto por una serie de sentencias en lenguaje
        <span lang="en">
         Java
        </span>
        :
    </p>
    <ul class="lista_verificacion">
        <li>
            sentencias de
            <strong>
                declaración de variables locales
            </strong>
            al método;
        </li>
        <li>
            sentencias que implementan la
            <strong>
                lógica del método
            </strong>
            (estructuras de control
            como bucles o condiciones; utilización de métodos del propio objeto o de otros objetos;
            cálculo de expresiones matemáticas, lógicas o de cadenas; creación de nuevos objetos,
            <abbr title="etcétera.">
                etc.
            </abbr>
            ). Es decir, todo lo que has visto en las unidades
            anteriores. Se trata de algo así como un "miniprograma" con su entrada, su procesamiento y
            su salida;
        </li>
        <li>
            sentencia de
            <strong>
                devolución del valor de retorno
            </strong>
            (return). Aparecerá al final
            del método y es la que permite devolver la información que se le ha pedido al método. Es la
            última parte del proceso y la forma de comunicarse con la parte de código que llamó al
            método (paso de mensaje de vuelta). Esta sentencia de devolución siempre debe aparecer al
            final del método salvo que el tipo devuelto por el método sea void (vacío), pues en tal caso
            no hay que devolver nada al código que hizo la llamada.
        </li>
    </ul>
    <p>
        Veamos cómo podrían quedar algunos de los métodos de la clase Vehiculo si escribimos el código
        <span lang="en">
         Java
        </span>
        que deberían contener en su interior:
    </p>
    <div class="highlighted-code language-java">
        <pre>public double getNivelDeposito () &#123;
  return nivelDeposito;
&#125;

public LocalDate getFechaMatriculacion () &#123;
  return fechaMatriculacion;
&#125;
</pre>
    </div>
    <p>
        En ambos ejemplos lo único que hacen estos métodos es simplemente devolver un valor (utilización
        de la sentencia&nbsp;return). No recibe parámetros (información de entrada) ni hace cálculos, ni
        obtiene resultados intermedios o finales. Es un
        <strong>
            método de consulta
        </strong>
        que tan solo
        devuelve el contenido de un atributo. Se trata de uno de los métodos más sencillos que se pueden
        implementar: un método que devuelve el valor de un atributo. Se les suele llamar métodos de tipo
        <strong lang="en">
            get
        </strong>
        o
        <strong lang="en">
            getters
        </strong>
        (de
        <strong>
            obtener,
        </strong>
        en
        inglés) y ya los veremos detenidamente más adelante.
    </p>
</div><h1 class="title">
    5.5.1.- Valor devuelto por un método: return
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        En el apartado anterior hemos visto que, desde el punto de vista del valor devuelto por un
        método, puede suceder:
    </p>
    <ol class="auto-numbered" style="list-style-type: decimal;">
        <li>
            que
            <strong>
                no devuelva nada
            </strong>
            , entonces en la cabecera se indica que devuelve el
            tipo void ("vacío");
        </li>
        <li>
            que
            <strong>
                devuelva un determinado valor
            </strong>
            , en tal caso en la cabecera se indica el
            tipo que devuelve (bien un tipo primitivo o bien un tipo referenciado como podría ser un
            array o un objeto de alguna clase).
        </li>
    </ol>
    <p style="text-align: center;">
        <strong>
         <span class="destacado_inline">
          En Java, para devolver un valor desde un método se utiliza la sentencia return.
         </span>
        </strong>
    </p>
    <p>
        <strong>
            El tipo del valor que devuelva la sentencia return debería de ser del mismo tipo o de un
            tipo compatible con el tipo del valor de retorno definido en la cabecera del método
        </strong>
        ,
        pudiendo ser desde un entero a un objeto creado por nosotros. Es decir, que si en la cabecera se
        indica int, se puede devolver un&nbsp;int (o un short o un byte), pero nunca un long , un float,
        un double, un char o un boolean.
    </p>
    <p>
        Veamos algunos ejemplos sencillos:
    </p>
    <ol class="auto-numbered" style="list-style-type: decimal;">
        <li>
            Método que devuelve un valor entero aleatorio entre 1 y 6:
            <div class="highlighted-code language-java">
          <pre>byte valorAzar () &#123;
  return (byte) (Math.random()*6) + 1;
&#125;
</pre>
            </div>
        </li>
        <li>
            Método que recibe dos números reales y devuelve el producto de esos dos números:
            <div class="highlighted-code language-java">
          <pre>double multiplicador (double numero1, double numero2) &#123;
  return numero1 * numero2;
&#125;

</pre>
            </div>
        </li>
        <li>
            Método que devuelve la fecha actual incrementada en tres días:
            <div class="highlighted-code language-java">
          <pre>LocalDate hoyMasTresDias () &#123;
  return LocalDate.now().plusDays(3);
&#125;

</pre>
            </div>
        </li>
        <li>
            Método que incrementa la cantidad de combustible de un vehículo (no devuelve nada y por
            tanto no hay return):
            <div class="highlighted-code language-java">
          <pre>public void repostar (double cantidad) &#123;
  nivelDeposito= nivelDeposito + cantidad;
&#125;

</pre>
            </div>
        </li>
    </ol>
    <p>
        Como puedes observar, sólo en el caso de que el tipo devuelto por el método sea void, se puede
        evitar usar la sentencia&nbsp;return. Si no, es obligatorio introducirla y su ejecución haría
        que el método finalizara en esa línea devolviendo un determinado valor.
    </p>
    <p>
        En algunos lenguajes, a los métodos que devuelven algún valor se les llama
        <strong>
            funciones
        </strong>
        y a los que no devuelven nada
        <strong>
            procedimientos
        </strong>
        .
    </p>
    <p>
        <strong>
            Lo habitual es que la sentencia&nbsp;return esté siempre al final del método
        </strong>
        , de
        este modo se tendrá una entrada y una salida, cumpliendo con uno de los principios de la
        programación estructurada, de forma que la salida natural para cualquier método será ejecutar la
        última sentencia que contiene, y que debe ser un
        <strong>
            return
        </strong>
        . No tiene mucho sentido
        que exista código después de un return, pues el método finaliza su ejecución y se devuelve el
        control a las líneas de código que invocaron al método. Es algo así como una indicación del
        final del "mini programa", culminando con la devolución de algún resultado a la parte de código
        que invocó a ese método. No obstante, también es posible utilizar una sentencia
        <strong>
            return
        </strong>
        en cualquier punto de un método, con lo que éste finalizará en el lugar donde se encuentre dicho
        <strong>
            return
        </strong>
        . Pero de esta forma, estaríamos creando "puertas traseras" que
        complicarían la comprensión del código, y lo harían más difícil de entender y mantener, pudiendo
        generar efectos colaterales oscuros no previstos que deriven en un mal funcionamiento
    </p>
    <p>
        Aunque
        <span lang="en">
         Java
        </span>
        permite incluir más de una sentencia&nbsp;return dentro de un
        método, no es aconsejable, pues dificultaría la legibilidad del código al entenderse que la
        finalización de la ejecución del método puede suceder en distintas partes de éste. En
        conclusión:
    </p>
    <p style="text-align: center;">
        <span class="resaltado_inline">
         Se recomienda NO incluir más de un return en un método, que deberá ir al final del mismo, como salida natural.
        </span>
    </p>
    <p>
        El valor de retorno es opcional, si lo hubiera debería de ser del mismo tipo o de un tipo
        compatible con el tipo del valor de retorno definido en la cabecera del método, pudiendo ser
        desde un entero a un objeto creado por nosotros. Si no lo tuviera, el tipo de retorno sería
        void, y
        <code>
            return
        </code>
        serviría para salir del método sin necesidad de añadirle ningún
        valor ni expresión detrás.
    </p>
    <p>
    </p>
</div><h1 class="title">
    5.5.2.- Variables locales
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        Hemos realizado la comparación del cuerpo de un método con un pequeño programa que en ocasiones
        podrá tener cierta complejidad. En tales casos puede ser habitual que necesitemos algunas
        <strong>
            variables internas o auxiliares
        </strong>
        para realizar cálculos intermedios. Esas
        variables son conocidas con el nombre de
        <strong>
            variables locales
        </strong>
        .
    </p>
    <p>
        La forma de declarar una variable local es exactamente la misma que vimos a principio de curso:
        tipo y nombre de la variable junto con aquellos modificadores que permita el lenguaje. De hecho,
        <strong>
            en
            <span lang="en">
          Java
         </span>
            , las variables que has estado usando hasta ahora ya eran
            locales
        </strong>
        , pues eran variables declaradas
        <strong>
            dentro de un método llamado
            main
        </strong>
        .
    </p>
    <p>
        Por ejemplo, supongamos que vamos a implementar un método (llamado por ejemplo sumaSerie) que
        sume todos los números que hay entre dos enteros que se pasan como parámetros. Para llevar a
        cabo esta tarea necesitaríamos al menos un
        <strong>
            par de variables
        </strong>
        : un
        <strong>
            contador
        </strong>
        para ir desde un número hasta otro y un
        <strong>
            acumulador
        </strong>
        para ir sumando
        sucesivamente cada número.
    </p>
    <div class="highlighted-code language-java">
        <pre>int sumaSerie (int inicio, int fin) &#123;
  int contador;  // Variable local contador
  int suma= 0;   // Variable local acumuladora de la suma de cada número recorrido
  for (contador=inicio; contador<=fin; contador++) &#123;  // Recorremos todos los números desde inicio hasta fin
    suma +=contador;  // Vamos sumando en el acumulador suma cada uno de los números que vamos recorriendo
  &#125;
  return suma; // Devolvemos la suma acumulada
&#125;
</pre>
    </div>
    <p>
        <span class="destacado_inline">
         <strong>
          Debes evitar asignar a las variables locales nombres que coincidan con el de algún parámetro. El compilador no lo permitirá pues se trataría de un identificador duplicado
         </strong>
         .
        </span>
    </p>
</div><h1 class="title">
    5.5.3.- El operador de autorreferencia this
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        Normalmente, en la mayoría de los lenguajes orientados a objetos, se dispone de algún
        <strong>
        </strong>
        <span class="destacado_inline">
         <strong>
          mecanismo de referencia al propio objeto dentro de un método
         </strong>
        </span>
        .
        En el caso específico de
        <span lang="en">
         Java
        </span>
        existe la palabra reservada this, conocida
        como el
        <strong>
            operador de autorreferencia
        </strong>
        . El uso de este operador puede resultar muy
        útil a la hora de
        <strong>
            evitar la ambigüedad que puede producirse entre el nombre de un
            parámetro de un método y el nombre de un atributo cuando ambos tienen el mismo identificador
            (mismo nombre)
        </strong>
        . En tales casos el parámetro "oculta" o se "superpone" al atributo y
        no tendríamos acceso directo a él (al escribir el identificador estaríamos haciendo referencia
        al parámetro y no al atributo). En estos casos la referencia this nos permite acceder a estos
        atributos ocultados por los parámetros.
    </p>
    <p>
        Dado que this es una referencia al propio objeto con el que te encuentras trabajando en ese
        momento, puedes acceder a sus miembros (atributos y métodos) mediante el operador punto (.) como
        sucede con cualquier otro objeto. Por tanto, en lugar de poner el nombre del atributo (que en
        los casos de ambigüedad se haría referencia al parámetro), podrías escribir this.nombreAtributo,
        de manera que el compilador sabrá que te estás refiriendo al atributo y se eliminará la
        ambigüedad.
    </p>
    <p>
        Por ejemplo, si tenemos una clase Persona con atributos nombre,
        <code>
            apellido1
        </code>
        ,
        apellido2,
        <abbr title="etcétera">
            etc.
        </abbr>
        y queremos escribir un método para modificar el
        primer apellido, podríamos escribir un método llamado cambiarApellido1 que hiciera lo siguiente:
    </p>
    <div class="highlighted-code language-java">
        <pre>public class Persona &#123;
  private String nombre;
  private String apellido1;
  private String apellido2;
  ...

  public void cambiarApellido1 (String nuevoApellido1) &#123;
    apellido1= nuevoApellido1;  // Se asigna al atributo apellido1 el valor contenido por el parámetro nuevoApellido1
  &#125;
  ...

&#125;
</pre>
    </div>
    <p>
        Aquí no habría problema, dado que no se produce ambigüedad entre el identificador utilizado para
        el parámetro (nuevoApellido1) y el identificador usado para el atributo (apellido1). Sin
        embargo, si hubiéramos querido utilizar también&nbsp;apellido1 como identificador para el
        parámetro habríamos tenido un problema de
        <strong>
            ambigüedad
        </strong>
        :
    </p>
    <div class="highlighted-code language-java">
        <pre>  public void cambiarApellido1 (String <strong>apellido1</strong>) &#123;
    <strong>apellido1</strong>= <strong>apellido1</strong>; <span style="text-decoration: line-through;">// Se asigna al atributo <strong>apellido1</strong> el valor contenido por el parámetro <strong>apellido1</strong></span> -> No funciona
  &#125;

</pre>
    </div>
    <p>
        Esto no va a funcionar correctamente porque en la asignación&nbsp;apellido1 = apellido1 n
        <span style="font-size: 1em;">
         osotros deseamos que se asigne al atributo
        </span>
        apellido1
        <span style="font-size: 1em;">
         el valor contenido por el parámetro
        </span>
        apellido1
        <span lang="en" style="font-size: 1em;">
         , pero eso no es posible porque el compilador de Java no sabe en qué caso nos estamos refiriendo al atributo y en qué caso nos estamos refiriendo al parámetro. Es imposible saberlo dado que tienen el mismo nombre o identificador. Se trata de una situación ambigua que el compilador resuelve haciendo que el parámetro "oculte" al atributo y siendo por tanto imposible acceder al atributo. Eso haría que esa sentencia simplemente hiciera la asignación al parámetro del propio valor del parámetro, lo cual no tiene mucho sentido, porque lo deja como estaba. De hecho, para evitar que el valor de un parámetro pueda ser modificado se le suele añadir el modificador
        </span>
        <code>
            final
        </code>
        <span style="font-size: 1em;">
         en la declaración del método.
        </span>
    </p>
    <p>
        <strong>
         <span class="destacado_inline" lang="en">
          Recuerda: en un método en Java, en caso de ambigüedad entre el identificador de un parámetro y el identificador de un atributo, el parámetro siempre oculta al atributo.
         </span>
        </strong>
    </p>
    <p>
        ¿Cómo podemos solucionar esto? Podemos hacerlo de dos formas:
    </p>
    <ol>
        <li>
            como se hizo inicialmente: asignando al parámetro un identificador (nombre) diferente al del
            atributo. De este modo no se produce ambigüedad;
        </li>
        <li>
            utilizando el operador de autorreferencia this para indicar cuándo nos estamos refiriendo al
            atributo. De este modo, en lugar de escribir simplemente el nombre del atributo, que se
            podría confundir con el nombre del parámetro, escribimos this.nombreAtributo. En este caso
            this.apellido1.
        </li>
    </ol>
    <p>
        Si utilizamos el operador de autorreferencia this, el método quedaría de la siguiente manera:
    </p>
    <div class="highlighted-code language-java">
        <pre>  public void cambiarApellido1 (String apellido1) &#123;
    this.apellido1= apellido1; // Se asigna al atributo apellido1 el valor contenido por el parámetro apellido1
  &#125;

</pre>
    </div>
    <p>
        De esta manera hemos resuelto el caso de la ambigüedad. Ahora bien, ¿qué hacemos con el resto de
        atributos si no existe el peligro de ambigüedad? Cuando queramos referirnos a ellos, ¿escribimos
        simplemente el nombre del atributo o utilizamos siempre a partir de ahora la referencia
        this?
    </p>
    <p style="text-align: center;">
        <strong>
        </strong>
        <span class="destacado">
         <strong>
          Nuestra recomendación es que que utilicéis siempre la referencia this
         </strong>
         .
        </span>
    </p>
    <p>
        De esa manera en el código de los métodos siempre quedará claro que nos estamos refiriendo a un
        atributo del objeto y no a un parámetro o a una variable local. Será una forma sencilla de
        mejorar la legibilidad del código y de que quede "mejor autodocumentado".
    </p>
    <p>
        Quizá inicialmente nos pueda resultar tedioso tener que escribir&nbsp;this seguido de un punto
        delante de cada atributo cada vez que lo usemos en un método, pero a la larga hará que el cuerpo
        de nuestros métodos sea más legible dado que cuando lo veas sabrás rápidamente que se está
        haciendo referencia a un atributo sin tener que ir a consultar la lista de atributos de la
        clase.
    </p>
    <p>
        En cualquier caso, siempre
        <strong>
            puedes decidir usar la referencia&nbsp;this sólo cuando sea
            imprescindible
        </strong>
        (casos de ambigüedad por coincidir con el nombre de un parámetro). Lo
        que sí te recomendamos en caso de que tomes esa decisión, es que seas coherente y lo hagas
        siempre de la misma manera: no utilices nunca&nbsp;this salvo que sea imprescindible y no de
        manera arbitraria para unos atributos sí y para otros no, o en unos métodos sí y en otros no,
        porque entonces podrías confundir a quien leyera el código. La idea es siempre facilitar al
        máximo la legibilidad del código para comprender qué es lo que se hace en cada método.
    </p>
</div><h1 class="title">
    5.5.4.- Lanzando excepciones desde un método
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 180px;">
    </div>
    <p>
        Habrá ocasiones en las que el intento de ejecución de un método pueda dar lugar a una situación
        no deseable o un error. En tales casos, el método debería avisar de que se ha producido esa
        situación.
    </p>
    <p>
        En algunos lenguajes eso se resuelve devolviendo algún tipo de código de error. Por ejemplo, si
        se espera que un método devuelva un número positivo o cero, puede devolverse un número negativo,
        por ejemplo -1,&nbsp; para indicar que se ha producido un error. Si existen diversas
        posibilidades de error, entonces podrían devolverse distintos números negativos en función del
        tipo de error que se haya producido.
    </p>
    <p>
        Como ya hemos visto en unidades anteriores,
        <span lang="en">
         Java
        </span>
        dispone de un mecanismo
        más sofisticado de comunicación de errores o situaciones no deseables: la gestión de
        <strong>
            excepciones
        </strong>
        .
    </p>
    <p>
        Hasta ahora habías visto cómo tratar posibles excepciones generadas por la ejecución de algún
        método de una clase o por algún operador. Para ello utilizabas la estructura try - catch -
        finally.
    </p>
</div><h1 class="title">
    5.6.- Encapsulación, control de acceso y visibilidad
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        Recuerda que ha estado viendo con
        <strong>
            María
        </strong>
        los distintos modificadores de
        acceso aplicables a las clases, atributos y métodos.&nbsp; Está claro que hasta que no
        empiece a utilizarlos para casos concretos y con aplicación práctica real no terminará
        de comprender exactamente su mecánica de funcionamiento: cuándo interesa ocultar un
        determinado miembro, cuándo interesa que otro miembro sea visible, en qué casos vale la
        pena crear un método para acceder al valor de un atributo,
        <abbr title="etcétera.">
            etc.
        </abbr>
    </p>
</div><h1 class="title">
    5.6.1.- Métodos de acceso(I): getters
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 180px;">
    </div>
    <p>
        Como ya sabemos,
        <strong>
            un método es un fragmento de código con una cabecera que puede ser
            invocado desde fuera de la clase y que puede o no llevar parámetros
        </strong>
        .
        <strong>
            Desde
            fuera de la clase lo único que se conoce de cada método es su cabecera
        </strong>
        , que es la
        interfaz de comunicación entre el código externo a la clase y los objetos de esa clase: nombre
        del método, parámetros, tipo devuelto,
        <abbr title="etcétera">
            etc
        </abbr>
        .
    </p>
    <p>
        Dado que los métodos son escritos por el programador de la clase, éste puede decidir qué
        información se va a proporcionar y cuál no. En principio se podría escribir un método para poder
        obtener el valor de cada uno de los atributos de un objeto, aunque no siempre tiene por qué ser
        así. Estos métodos son conocidos habitualmente con el nombre de métodos de tipo
        <span lang="en">
         get (que en inglés significa
         <strong>
          obtener)
         </strong>
        </span>
        o
        <strong>
         <span lang="en">
          getters
         </span>
        </strong>
        .
    </p>
    <p>
        Por ejemplo, si tenemos una clase Persona con atributos nombre,
        <code>
            apellido1
        </code>
        ,
        apellido2,
        <code>
            dni
        </code>
        ,
        <abbr title="etcétera">
            etc.
        </abbr>
        , podríamos definir
        <strong>
         <span lang="en">
          getters
         </span>
        </strong>
        para cada uno de esos atributos que son privados y por
        tanto no visibles desde fuera de la clase:
    </p>
    <div class="highlighted-code language-java">
        <pre>public class Persona &#123;
  private String nombre;
  private String apellido1;
  private String apellido2;
  private String dni;

  public String getNombre () &#123;
    return this.nombre;
  &#125;

  public String getApellido1 () &#123;
    return this.apellido1;
  &#125;

  public String getApellido2 () &#123;
    return this.apellido2;
  &#125;

  public String getDni () &#123;
    return this.dni;
  &#125;
&#125;
</pre>
    </div>
    <p>
        <span>
         Si te fijas, lo habitual es que estos métodos no tengan parámetros de entrada, pues no necesitan ninguna información extra para poder devolver la información que se les está soclicitando. En este caso no habría necesidad de utilizar la referencia this, pues al no haber parámetros no hay posibilidad ninguna de ambigüedad o confusión entre identificadores de atributos e identificadores de parámetros. Pero si decidimos optar siempre por el uso de
         <span>
          this
         </span>
         , podemos hacerlo en aras de una mayor claridad (saber que nos estamos refiriendo a un atributo y no a un parámetro o a una variable local).
         <br>
        <br/></span>
    </p>
</div><h1 class="title">
    5.6.2.- Métodos de acceso (II): setters
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        De la misma manera que hemos hablado de métodos
        <strong>
         <span lang="en">
          get
         </span>
        </strong>
        o
        <strong>
         <span lang="en">
          getter
         </span>
        </strong>
        para obtener el valor de un atributo también
        podemos hablar de métodos
        <strong>
         <span lang="en">
          set
         </span>
        </strong>
        o
        <strong>
         <span lang="en">
          setter
         </span>
        </strong>
        para establecer o modificar el valor de un atributo.
        Estos métodos normalmente no devolverán ningún valor, sino que asignarán un nuevo valor a un
        atributo (o a un conjunto de atributos).
    </p>
    <p>
        Podremos escribir un método
        <span lang="en">
         set
        </span>
        por cada atributo que queramos que pueda
        ser modificado directamente. Por ejemplo, si tenemos una clase Persona con atributos nombre,
        <code>
            apellido1
        </code>
        , apellido2,
        <abbr title="etcétera">
            etc.
        </abbr>
        podríamos
        definir
        <strong>
         <span lang="en">
          setters
         </span>
        </strong>
        para cada uno de esos atributos si
        se trata de atributos mutables o variables:
    </p>
    <div class="highlighted-code language-java">
        <pre>public class Persona &#123;
  private String nombre;
  private String apellido1;
  private String apellido2;
  private String dni;

  public void setNombre (String nombre) &#123;
    this.nombre= nombre;
  &#125;

  public void setApellido1 (String apellido1) &#123;
    this.apellido1= apellido1;
  &#125;

  public void setApellido2 (String apellido2) &#123;
    this.apellido2= apellido2;
  &#125;

  public void setDni (String dni) &#123;
    this.dni= dni;
  &#125;
&#125;
</pre>
    </div>
    <p>
        Si te fijas, en este caso nos ha venido muy bien disponer de la referencia this para no tener
        que
        utilizar un identificador diferente al del atributo en el parámetro.
    </p>
    <p>
        Lo habitual en estos métodos
        <strong>
         <span lang="en">
          set
         </span>
        </strong>
        es que no devuelvan
        ningún valor, por tanto serán de tipo void, aunque no es algo obligatorio. Por ejemplo en
        algunos casos hay quien devuelve el valor que ha sigo asignado finalmente. En el caso del método
        setNombre podría haber quedado algo así:
    </p>
    <div class="highlighted-code language-java">
        <pre>public String setNombre (String nombre) &#123;
  this.nombre= nombre;
  return this.nombre;
&#125;
</pre>
    </div>
    <p>
        También podría darse el caso de querer implementar un
        <span lang="en">
         setter
        </span>
        que permita
        establecer a la vez el nombre y los dos apellidos. Sería un caso de método
        <span lang="en">
         set
        </span>
        en el cual se establece el valor de varios atributos a la vez. Por
        ejemplo, podría implementarse un método&nbsp;setNombreApellidos de la siguiente manera:
    </p>
    <div class="highlighted-code language-java">
        <pre>public void setNombreApellidos (String nombre, String apellido1, String apellido2) &#123;
  this.nombre= nombre;
  this.apellido1= apellido1;
  this.apellido2= apellido2;
&#125;
</pre>
    </div>
    <p>
        Otra posibilidad que se nos podría ocurrir es que el método&nbsp;setNombre pudiera admitir varios
        nombres (para el caso de personas con nombre compuesto) y que internamente el método los uniera
        separándolos por espacios asignándolo finalmente a un único atributo nombre. Para ello podríamos
        modificar el método&nbsp;setNombre para que admitiera un número variable de parámetros (tantos
        nombres como se desea) utilizando el mecanismo varags que ya se mencionó pero del que aún no
        hemos visto ningún ejemplo. También podríamos dejar el método&nbsp;setNombre sin modificar e
        implementar otro método llamado&nbsp;setNombreCompuesto que sería el que podría recibir un
        número indeterminado de parámetros:
    </p>
    <div class="highlighted-code language-java">
        <pre>public void setNombreCompuesto (String ... nombre) &#123; // Número indeterminado de parámetros String
  String acumuladorNombres= nombre[0];  // Variable local donde iremos concatenando los nombres, empezando por el primero

  for (int i=1; i<nombre.length; i++) &#123;
    acumuladorNombres= acumuladorNombres + " " + nombre[i]; // Concatenamos nombres separados por espacios
  &#125;
  this.nombre= acumuladorNombres; // Asignamos al atributo la cadena creada con todos los nombres concatenados
&#125;
</pre>
    </div>
    <p>
        Para aquellos atributos que no sean variables, no tiene sentido implementar
        <strong>
         <span lang="en">
          setters
         </span>
        </strong>
        . Por ejemplo, para el caso de la clase Vehiculo, no tiene
        sentido dotarla de métodos
        <strong>
         <span lang="en">
          set
         </span>
        </strong>
        para los atributos
        capacidadDeposito,
        <code>
            matricula
        </code>
        , consumoMedio, o
        <code>
            fechaMatriculacion
        </code>
        pues
        esos atributos no van a poder ser modificados una vez que se construya el objeto y se les asigne
        un valor inicial (y definitivo).
    </p>
    <p>
        Sí podríamos plantearnos en principio implementar
        <span lang="en">
         setters
        </span>
        para atributos
        como nivelDeposito o
        <code>
            kilometrosParciales
        </code>
        . Pero fíjate que, aunque se trata de
        atributos mutables o variables, no tiene mucho sentido hacerlo, pues si permitimos que desde
        fuera se pueda asignar un valor "arbitrario" a esos atributos podría desvirtuarse el
        funcionamiento interno de los objetos.
    </p>
    <p>
        Por ejemplo, podríamos implementar un método setNivelDeposito con un parámetro que fuera la
        nueva
        cantidad de combustible del vehículo. Pero los vehículos en realidad no funcionan así, lo que se
        hace es verter en el depósito una determinada cantidad de combustible haciendo que el nivel del
        depósito aumente. Para ello tenemos un método repostar cuyo funcionamiento es más fiel al
        comportamiento real de un vehículo. Podríamos decir que&nbsp;repostar es una especie de método
        <span lang="en">
         set
        </span>
        dado que su ejecución da lugar a que algunos atributos del objeto
        cambien de valor, pero no se están cambiando directamente con un valor que se proporciona, sino
        de manera indirecta mediante cálculos que influyen en el valor final de uno o más atributos.
    </p>
</div><h1 class="title">
    5.6.3.- Métodos privados
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Normalmente los métodos de una clase pertenecen a su interfaz y por tanto parece lógico que sean
        declarados como públicos. Pero también es cierto que pueden darse casos en los que exista la
        necesidad de disponer de algunos métodos privados a la clase. Se trata de métodos que realizan
        operaciones intermedias o auxiliares y que son utilizados por los métodos que sí forman parte de
        la interfaz. Ese tipo de métodos (de comprobación, de adaptación de formatos, de cálculos
        intermedios,
        <abbr title="etcétera.">
            etc.
        </abbr>
        ) suelen declararse como privados pues no son de
        interés (o no es apropiado que sean visibles) fuera del contexto del interior del objeto.
    </p>
    <p>
        Por ejemplo, imagina la clase&nbsp;Persona con la que ya hemos trabajado anteriormente a la cual
        le vamos a añadir un atributo que contenga el
        <abbr title="Documento Nacional de Identidad">
            DNI
        </abbr>
        (con letra). Podríamos disponer de
        un método "interno" que permitiera comprobar que ese
        <abbr title="Documento Nacional de Identidad">
            DNI
        </abbr>
        es válido. Para ello será
        necesario calcular la letra correspondiente a un determinado número de
        <abbr title="Documento Nacional de Identidad">
            DNI
        </abbr>
        y comprobar si una determinada
        combinación de número y letra forman un
        <abbr title="Documento Nacional de Identidad">
            DNI
        </abbr>
        válido. Este tipo de cálculos y comprobaciones podrían ser implementados en métodos privados o
        auxiliares de la clase.
    </p>
    <p>
        Por ejemplo podríamos implementar un método llamado isDniValido que recibiera como parámetro un
        <abbr title="Documento Nacional de Identidad">
            DNI
        </abbr>
        y devolviera un&nbsp;boolean que
        indicara si ese
        <abbr title="Documento Nacional de Identidad">
            DNI
        </abbr>
        es válido en
        función de la letra que contenga. En tal caso se trataría de un método de comprobación "interno"
        que sería invocado desde el método setDni y no sería necesario que fuera visible desde fuera.
        Por tanto el método&nbsp;isDniValido tendría sentido que fuera declarado como privado.
    </p>
    <p>
    </p>
</div><h1 class="title">
    5.7.- Sobrecarga de métodos
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        En principio parece lógico pensar que el nombre de un método sólo puede ser utilizado una vez en
        la declaración de una clase. Es decir, que una clase no podría tener más de un método con el
        mismo nombre. Pero no tiene por qué ser siempre así. Es posible tener varias versiones de un
        mismo método (varios métodos con el mismo nombre) gracias a la
        <strong>
            sobrecarga
        </strong>
        .
    </p>
    <p>
        El lenguaje
        <span lang="en">
         Java
        </span>
        soporta la característica conocida como
        <strong>
            sobrecarga
            de métodos
        </strong>
        . Ésta permite declarar en una misma clase varias versiones del mismo método
        con el mismo nombre. La forma que tendrá el compilador de distinguir entre varios métodos que
        tengan el mismo nombre será mediante la lista de parámetros del método: si el método tiene una
        lista de parámetros diferente, será considerado como un método diferente (aunque tenga el mismo
        nombre) y el analizador léxico no producirá un error de compilación al encontrar dos nombres de
        método iguales en la misma clase.
    </p>
    <p>
        Imagínate que estás desarrollando una clase para escribir sobre un lienzo que permite utilizar
        diferentes tipografías en función del tipo de información que se va a escribir. Es probable que
        necesitemos un método diferente según se vaya a pintar un número entero (int), un número real
        (double) o una cadena de caracteres (String). Una primera opción podría ser definir un nombre de
        método diferente dependiendo de lo que se vaya a escribir en el lienzo.
    </p>
</div><h1 class="title">
    5.7.1.- Sobrecarga de operadores
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-left license-pd" style="width: 180px;">
    </div>
    <p>
        Del mismo modo que hemos visto la posibilidad de sobrecargar métodos (disponer de varias
        versiones de un método con el mismo nombre cambiando su lista de parámetros), podría plantearse
        también la opción de sobrecargar operadores del lenguaje tales como
        <span title="Operadores simbólicos “más”, “menos”, “asterisco”, “paréntesis”, “menor”, “mayor”.">
         +,
         <code>
          -
         </code>
         , *,
         <code>
          ( )
         </code>
         , &lt;, &gt;,
        </span>
        <abbr title="etcétera.">
         <span lang="en">
          etc
         </span>
            .
        </abbr>
        para darles otro significado
        dependiendo del tipo de&nbsp; operandos con los que vaya a operar.
    </p>
    <p>
        En algunos casos puede resultar útil para ayudar a mejorar la legibilidad del código, pues esos
        operadores resultan muy intuitivos y pueden dar una idea rápida de cuál es su
        funcionamiento.
    </p>
    <p>
        Un típico ejemplo podría ser el de la sobrecarga de operadores aritméticos como la suma (+) o el
        producto (*) para operar con fracciones. Si se definen objetos de una clase Fraccion (que
        contendrá los atributos numerador y denominador) podrían sobrecargarse los operadores
        aritméticos (habría que redefinir el operador suma (+) para la suma, el operador asterisco (*)
        para el producto,
        <abbr title="etcétera.">
            etc.
        </abbr>
        ) para esta clase y así podrían utilizarse
        para sumar o multiplicar objetos de tipo&nbsp;Fraccion mediante el algoritmo específico de suma
        o de producto del objeto&nbsp;Fraccion (pues esos operadores no están preparados en el lenguaje
        para operar con esos objetos).
    </p>
    <p>
        Otro ejemplo podríamos verlo en las clases LocalDate y
        <code>
            LocalTime
        </code>
        que disponen de
        elementos como isBefore o
        <code>
            isAfter
        </code>
        para comparar si una fecha o una hora es anterior
        o posterior a otra (por ejemplo t1.isBefore(t2) devuelve true si&nbsp;t1 es anterior a t2). En
        este caso habría estado bien poder sobrecargar los operadores &lt; y &gt; para poder comparar
        fechas u horas directamente con esos operadores en lugar de usando métodos. El ejemplo anterior
        podría entoces quedar como t1 &lt; t2, que sería bastante más compacto e intuitivo que
        t1.isBefore(t2).
    </p>
    <p>
        En algunos lenguajes de programación como por ejemplo
        <abbr lang="en" title="C plus plus">
            C++
        </abbr>
        o
        <abbr title="C sharp.">
            C#
        </abbr>
        se permite la sobrecarga, pero no es algo soportado
        en todos los lenguajes.
    </p>
    <p>
        ¿Qué sucede en el caso concreto de
        <span lang="en">
         Java
        </span>
        ?
    </p>
    <div class="destacado">
        <p style="text-align: center;">
            <strong>
                El lenguaje
                <span lang="en">
           Java
          </span>
                NO soporta la
                sobrecarga de operadores
            </strong>
            .
        </p>
    </div>
    <p>
        En el ejemplo anterior de los objetos de tipo Fraccion, habrá que declarar métodos en la
        clase&nbsp;Fraccion
        que se encarguen de realizar esas operaciones, pero no lo podremos hacer sobrecargando los
        operadores del lenguaje (los símbolos de la suma, resta, producto,
        <abbr title="etcétera.">
            etc.
        </abbr>
        ). Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <pre>public Fraccion sumar (Fraccion sumando)
public Fraccion restar (Fraccion sustraendo)
public Fraccion multiplicar (Fraccion multiplicador)
public Fraccion dividir (Fraccion divisor)
</pre>
    </div>
    <p>
        Y así sucesivamente...
    </p>
    <p>
        Y lo mismo sucede con las clases LocalDate y
        <code>
            Localtime
        </code>
        . Por ello se han tenido que
        implementar métodos como isAfter o
        <code>
            isBefore
        </code>
        .
    </p>
    <p>
        Dado que en este módulo se está utilizando el lenguaje
        <span lang="en">
         Java
        </span>
        para aprender
        a programar, no podremos hacer uso de esta funcionalidad. Más adelante, cuando aprendas a
        programar en otros lenguajes, es posible que sí tengas la posibilidad de utilizar este
        mecanismo.
    </p>
</div><h1 class="title">
    5.8.- Métodos estáticos
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 180px;">
    </div>
    <p>
        Un
        <strong>
            método estático
        </strong>
        puede ser usado directamente desde la clase sin necesidad de
        hacer referencia a ninguna instancia. De hecho son métodos que podrían invocarse sin necesidad
        de que existiera ningún objeto instancia de la clase.
    </p>
    <p>
        Estos métodos también son conocidos como
        <strong>
            métodos de clase
        </strong>
        (como sucedía con los
        <strong>
            atributos de clase
        </strong>
        ), frente a los
        <strong>
            métodos de objeto
        </strong>
        (es
        necesario un objeto para poder invocarlos).
    </p>
    <p>
        Los métodos estáticos no pueden manipular atributos de instancias (objetos), sólo atributos
        estáticos (de clase) y suelen ser utilizados para realizar operaciones comunes a todos los
        objetos de la clase, más que para una instancia concreta.
    </p>
    <p>
        Algunos ejemplos de operaciones que suelen realizarse desde métodos estáticos:
    </p>
    <ul class="lista_verificacion">
        <li>
            acceso a atributos específicos de clase: incremento o decremento de contadores internos de
            la clase (no de instancias), métodos
            <span lang="en">
          getter
         </span>
            de acceso a atributos de
            clase,
            <abbr title="etcétera.">
                etc.;
            </abbr>
        </li>
        <li>
            operaciones genéricas relacionadas con la clase pero que no utilizan atributos de instancia.
            Por ejemplo, para la clase Persona hemos definido anteriormente métodos para calcular y
            comprobar la letra de un
            <abbr title="Documento Nacional de Identidad.">
                DNI
            </abbr>
            .
            Este método podría ser interesante hacerlo público para poder usarlo desde fuera de la
            clase;
        </li>
        <li>
            herramientas de cálculo auxiliar que reciben parámetros, llevan a cabo operaciones con esos
            parámetros y devuelven el resultado obtenido.
        </li>
    </ul>
    <p>
        En la biblioteca de
        <span lang="en">
         Java
        </span>
        es muy habitual encontrarse con clases que
        proporcionan métodos estáticos que pueden resultar muy útiles para cálculos auxiliares,
        conversiones de tipos,
        <abbr title="etcétera.">
            etc.
        </abbr>
        Por ejemplo, la mayoría de las clases
        del paquete java.lang que representan tipos (Integer, String, Float, Double, Boolean,
        <abbr title="etcétera.">
            etc.
        </abbr>
        ) ofrecen métodos estáticos para hacer conversiones. Aquí
        tienes algunos ejemplos:
    </p>
    <ul class="lista_verificacion">
        <li>
            static String valueOf(int i). Devuelve la representación en formato String (cadena) de un
            valor int. Se trata de un método que no tiene que ver nada en absoluto con instancias
            concretas de String, es más bien un método auxiliar que puede servir como herramienta para
            ser usada desde otras clases. Se utilizaría directamente con el nombre de la clase. Por
            ejemplo:
            <br>
            <div class="highlighted-code language-java">
          <pre>String enteroCadena= String.valueOf (23);
</pre>
            </div>
            <br/></li>
        <li>
            static String valueOf(float f)
            <strong>
                .
            </strong>
            Algo similar para un valor de tipo float.
            Ejemplo de uso:
            <div class="highlighted-code language-java">
          <pre>String floatCadena= String.valueOf (24.341f);
</pre>
            </div>
        </li>
        <li>
            static int parseInt (String s). En este caso se trata de un método estático de la clase
            Integer. Analiza la cadena pasada como parámetro y la transforma en un int. Ejemplo de uso:
            <div class="highlighted-code language-java">
          <pre>int cadenaEntero= Integer.parseInt ("-12");
</pre>
            </div>
        </li>
    </ul>
    <p>
        Todos los ejemplos anteriores son casos en los que se utiliza directamente la clase como una
        especie de
        <strong>
            caja de herramientas
        </strong>
        que contiene métodos que pueden ser utilizados
        desde cualquier parte, por eso suelen ser métodos públicos, además de estáticos.
    </p>
    <p>
        Un ejemplo muy habitual en
        <span lang="en">
         Java
        </span>
        de
        <strong>
            clase que sirve como caja de
            herramientas
        </strong>
        es la clase Math, de la cual no tenemos objetos instancias de esa clase y
        sin embargo usamos muchos de sus métodos estáticos para realizar operaciones matemáticas como
        por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <pre>static double abs(double a)  // Calcula y devuelve el valor absoluto del parámetro
static double cos(double a)  // Calcula y devuelve el coseno trigonométrico del parámetro
static double log(double a)  // Calcula y devuelve el logaritmo neperiano del parámetro
static double max(double a, double b)  // Calcula y devuelve el máximo de los dos parámetros
static double pow(double a, double b)  // Calcula y devuelve el valor del primer parámetro elevado al segundo
static double sqrt(double a)  // Calcula y devuelve la raíz cuadrada del parámetro
static double random()  // Devuelve un valor aleatorio mayor o igual que 0.0 y menor que 1.0
</pre>
    </div>
</div><h1 class="title">
    5.8.1.- Método main en Java
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 180px;">
    </div>
    <p>
        En el lenguaje
        <span lang="en">
         Java
        </span>
        , toda aplicación debe contener al menos una clase con
        un método estático&nbsp; main cuya cabecera es:
    </p>
    <div class="highlighted-code language-java">
        <pre>public static void main(String[] args)
</pre>
    </div>
    <p>
        Normalmente suele utilizarse como
        <strong>
            punto de inicio de la ejecución del programa
        </strong>
        a
        partir del cual se comenzarán a crear objetos instancias de clases y a ejecutar métodos. Suele
        incluirse en una clase que normalmente no se instancia y es habitualmente conocida como la clase
        de inicio del programa. Se trata de un método similar a la función&nbsp;main que existe en
        lenguajes como C o
        <abbr title="C plus plus, orientado a objetos.">
            C++
        </abbr>
        .
    </p>
    <p>
        Este método es
        <strong>
            estático
        </strong>
        y puede ser invocado sin necesidad de que exista un
        objeto instancia de la clase. El único
        <strong>
            parámetro de entrada
        </strong>
        que posee (args, un
        <strong>
            array de cadenas
        </strong>
        de tipo String) es el mecanismo a través del cual el sistema
        pasa información desde la consola (línea de órdenes o "
        <em>
        </em>
        <span lang="en">
         <em>
          command line
         </em>
        </span>
        ") hacia la aplicación (argumentos o parámetros
        que acompañan al escribir el nombre de la clase en la consola). Eso significa que si se lanza el
        programa desde consola de la siguiente manera:
    </p>
    <div>
        <pre>java NombreClase uno dos tres 0 1 2</pre>
    </div>
    <p>
        El array&nbsp;args contendría la siguiente información:
    </p>
    <table class="tabla">
        <caption>
            Contenido del array String[] args
        </caption>
        <tbody>
        <tr>
            <th scope="row">
                Posición
            </th>
            <td>
                0
            </td>
            <td>
                1
            </td>
            <td>
                2
            </td>
            <td>
                3
            </td>
            <td>
                4
            </td>
            <td>
                5
            </td>
        </tr>
        <tr>
            <th scope="row">
                Contenido
            </th>
            <td>
                uno
            </td>
            <td>
                dos
            </td>
            <td>
                tres
            </td>
            <td>
                0
            </td>
            <td>
                1
            </td>
            <td>
                2
            </td>
        </tr>
        </tbody>
    </table>
    <p>
    </p>
    <p>
        Aquí tienes un ejemplo de uso el método&nbsp;main y su ejecución enviándole seis parámetros:
    </p>
    <div class="highlighted-code language-java">
        <pre>public class PruebaMain &#123;

  public static void main(String[] args) &#123;

    System.out.printf ("Prueba de ejecución del método main.\n");
    for (int i=0; i< args.length; i++) &#123;
        System.out.printf ("Argumento %d: %s\n", i, args[i]);
    &#125;
  &#125;
&#125;
</pre>
    </div>
    <p>
        Si ejecutáramos esta clase (podemos hacerlo dado que contiene un método main) con los parámetros
        anteriores:
    </p>
    <div>
        <div class="highlighted-code code-style-2 language-latex">
            <div>
                <pre>java PruebaMain uno dos tres 0 1 2</pre>
            </div>
        </div>
    </div>
    <p>
        Se obtendría el siguiente resultado por pantalla:
    </p>
    <div>
        <div class="highlighted-code code-style-2 language-latex">
            <div>
          <pre>Prueba de ejecución del método main.
Argumento 0: uno
Argumento 1: dos
Argumento 2: tres
Argumento 3: 0
Argumento 4: 1
Argumento 5: 2</pre>
            </div>
        </div>
    </div>
    <p>
        En algunos casos podemos incluir un método&nbsp;main en nuestras clases (y no en una clase
        "principal" de comienzo de ejecución del programa) por si queremos probar el funcionamiento de
        los métodos de la clase sin tener que implementar una clase de prueba adicional que incluya ese
        método main. No es lo habitual, pero puedes encontrarlo con cierta frecuencia. Nosotros lo
        haremos en alguna ocasión.
    </p>
</div><h1 class="title">
    5.9.- Método toString en Java
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        En
        <span lang="en">
         Java
        </span>
        , toda clase, por el hecho de ser una clase
        <span lang="en">
         Java
        </span>
        , incluye el método
        <span>
         toString
        </span>
        (esto es porque toda clase
        <span lang="en">
         Java
        </span>
        hereda siempre de la clase
        <span>
         Object
        </span>
        , algo que veremos en
        la siguiente unidad cuando estudiemos la herencia).
    </p>
    <p>
        El propósito de este método es
        <strong>
            asociar a todo objeto un texto representativo de su
            contenido
        </strong>
        . Es decir, que se trata de un método que devuelve una representación
        "textual" del contenido del objeto, de forma que en cualquier&nbsp; sentencia o expresión donde
        se espere un String, y se encuentre un objeto, intentará sustituirlo por su representación como
        String, siguiendo para ello las "instrucciones" del método toString. Ahora bien, ¿qué formato
        debe tener esa representación textual? Esa es una cuestión que deberá decidir el programador.
    </p>
    <p>
        No es obligatorio implementar el método
        <span>
         toString
        </span>
        . Toda clase
        <span lang="en">
         Java
        </span>
        ya dispone de ese método implícitamente. Pero si nosotros no lo
        reescribimos, el resultado textual que devuelve es muy "pobre" y tendrá un aspecto parecido a
        algo como
        <span>
         &lt;nombreClase&gt;&#64;&lt;numero&gt;
        </span>
        (por ejemplo
        <span>
         Persona&#64;1af7ab3
        </span>
        ).
        Esa información devuelta es conocida como "
        <span lang="en">
         hash
        </span>
        " y está relacionada con
        la posición de memoria en la que se almacena el objeto. Si deseamos que la representación
        textual de nuestro objeto sea más explícita y detallada tendremos que implementar nosotros el
        método.
    </p>
    <p>
        Veamos un ejemplo con la clase
        <span>
         Persona
        </span>
        . Si quisiéramos que la representación textual
        de los objeto de tipo
        <span>
         Persona
        </span>
        en la que se obtuviera un texto con el siguiente
        formato:
    </p>
    <div class="highlighted-code language-java">
        <pre>&#123;Nombre: xxx, Apellido1: yyy, Apellido2: zzz, Dni: vvv&#125;
</pre>
    </div>
    <p>
        donde xxx, yyy, zzz, vvv son los valores contenidos en los atributos&nbsp;&nbsp;nombre,
        <code>
            apellido1
        </code>
        ,
        apellido2,
        <code>
            dni
        </code>
        respectivamente, podríamos implementar un método&nbsp;toString de la
        siguiente manera, para que nos mostrara los datos de la persona en una línea, encerraos entre
        llaves, con una etiqueta indicando el nombre del atributo seguido de dos puntos, y separados por
        comas:
    </p>
    <div class="highlighted-code language-java">
        <pre>  public String toString() &#123;
      return String.format ("&#123;Nombre: %s, Apellido1: %s, Apellido2: %s, Dni: %s&#125;",
              this.nombre,
              this.apellido1,
              this.apellido2,
              this.dni);
&#125;
</pre>
    </div>
    <p>
        Si, por ejemplo, el contenido de los atributos de un objeto instancia de la clase
        <span>
         Persona
        </span>
        al que apunta una variable
        <span>
         p1
        </span>
        fuera:
    </p>
    <p>

    </p>
    <p>
        La ejecución de la siguiente línea
        <span>
         System.out.printf ("p1= %s", p1.toString());
        </span>
        mostraría por pantalla lo siguiente:
    </p>
    <div>
        <pre>p1= &#123;Nombre: Juan, Apellido1: Gil, Apellido2: Torres, Dni: 12345678L&#125;
</pre>
    </div>
    <p>
    </p>
    <p>
        Para obtener la representación textual (salida del método
        <span>
         toString
        </span>
        ) de un objeto no
        es necesario llamar explícitamente al método
        <span>
         toString
        </span>
        . Por ejemplo, en el caso
        anterior podrías haber escrito directamente
        <span>
         System.out.printf ("p1: %s", p1)
        </span>
        . Es
        decir, que
        <strong>
            si vamos a interpretar una variable referencia (objeto) como un String, no es
            necesario invocar explícitamente al método&nbsp;toString
        </strong>
        pues
        <span lang="en">
         Java
        </span>
        lo hará implícitamente por nosotros.
    </p>
    <p>
        Si deseamos que el formato de salida sea, por ejemplo, con una línea para cada atributo,
        podríamos hacer entonces:
    </p>
    <div class="highlighted-code language-java">
        <pre>public String toString() &#123;
      return String.format ("Nombre: %s\nApellido1: %s\nApellido2: %s\nDni: %s\n",
              this.nombre,
              this.apellido1,
              this.apellido2,
              this.dni);
  &#125;
</pre>
    </div>
    <p>
        En este caso la salida por pantalla de
        <span>
         System.out.printf ("p1: %s", p1);
        </span>
        tendría el siguiente aspecto:
    </p>
    <div>
        <pre>p1:
Nombre: Juan
Apellido1: Gil
Apellido2: Torres
Dni: 12345678L
</pre>
    </div>
    <p>
        Como puedes observar, el formato de salida del método
        <span>
         toString
        </span>
        puede ser tan
        elaborado como tú decidas a la hora de implementarlo. Por ejemplo, puedes decidir:
    </p>
    <ul>
        <li class="lista_verificacion">
            qué atributos deseas que se muestren (no tienes por qué mostrar
            todos los atributos),
        </li>
        <li class="lista_verificacion">
            número de decimales para los números reales,
        </li>
        <li class="lista_verificacion">
            cómo interpretar el valor de los atributos
            <span>
          boolean
         </span>
            ,
        </li>
        <li class="lista_verificacion">
            longitud máxima para las cadenas de caracteres,
        </li>
        <li class="lista_verificacion">
            si quieres que cada atributo aparezca en una línea diferente o
            todos en la misma línea,
        </li>
        <li class="lista_verificacion">
            si quieres incluir cálculos adicionales,
        </li>
        <li class="lista_verificacion">
            <abbr title="etcétera">
                etc.
            </abbr>
        </li>
    </ul>
    <p>
    </p>
</div><h1 class="title">
    6.- Constructores
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        <strong>
            María
        </strong>
        y
        <strong>
            Juan
        </strong>
        ya han creado y utilizado objetos y
        cuentan con algunos pequeños programas de ejemplo compuestos por varias clases además de
        la clase principal (la que contiene el método main).
    </p>
    <p>
        <strong>
            Ada
        </strong>
        ha estado revisando su trabajo y ha quedado muy satisfecha, aunque
        al observar la estructura de las clases les ha comentado algo que los ha dejado un poco
        despistados:
    </p>
    <p>
          <span class="st">
           —
          </span>
        Estas clases tienen muy buena pinta, aunque faltaría añadirles
        algunos constructores para poder mejorar su flexibilidad a la hora de instanciar
        objetos, ¿no creéis?
    </p>
    <p>
        Ambos han asentido porque eran conscientes de que hasta el momento no habían estado
        incluyendo constructores en sus clases, estaban aprovechando el constructor por omisión
        que añadía el compilador.
    </p>
    <p>
          <span class="st">
           —
          </span>
        Parece que ha llegado el momento de implementar nuestros propios
        constructores
        <span class="st">
           —
          </span>
        le dice
        <strong>
            María
        </strong>
        a
        <strong>
            Juan
        </strong>
        .
    </p>
</div><h1 class="title">
    6.1.- Concepto de constructor
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Un
        <strong>
            constructor
        </strong>
        es un método que tiene el mismo nombre que la clase a la que
        pertenece y que no devuelve ningún valor explícitamente tras su ejecución. Su función es la de
        proporcionar el mecanismo de creación de instancias (objetos) de la clase, siguiendo para ello
        el "molde" que define esa clase.
    </p>
    <p>
        Cuando una variable referencia a objeto es declarada, en realidad aún no existe ningún objeto.
        La
        declaración sólo crea la referencia que más tarde apuntará al objeto. Tan solo se trata de un
        nombre simbólico (una variable) que en el futuro apuntará a una zona de memoria que contendrá la
        información que representa realmente a un objeto (el conjunto de sus atributos). Para que esa
        variable referencia aún "vacía" (se suele decir que es una referencia nula o vacía o que apunta
        a null) apunte a una zona de memoria que represente a una instancia de clase (objeto) existente,
        es necesario "
        <strong>
            construir
        </strong>
        " o "crear" el objeto. Ese proceso se llevará a cabo a
        través del método
        <strong>
            constructor
        </strong>
        de la clase.
    </p>
    <p>
        Por tanto para instanciar un nuevo objeto es necesario realizar una llamada a un método
        constructor de la clase a la que pertenece ese objeto. Ese proceso se realiza mediante la
        utilización del operador new.
    </p>
    <p>
        Hasta el momento ya has utilizado en numerosas ocasiones el operador new para instanciar o crear
        objetos. En realidad lo que estabas haciendo era una llamada al constructor de la clase para que
        reservara memoria para ese objeto y por tanto "crear" físicamente el objeto en la memoria
        (dotarlo de existencia física dentro de la memoria del ordenador). Dado que en esta unidad estás
        ya definiendo tus propias clases, parece que ha llegado el momento de que empieces a escribir
        también los constructores de tus clases.
    </p>
    <p>
        Por otro lado, si un constructor es al fin y al cabo una especie de método (aunque algo
        especial)
        y
        <span lang="en">
         Java
        </span>
        soporta la sobrecarga de métodos, podrías plantearte la siguiente
        pregunta: ¿podrá una clase disponer de más de constructor? En otras palabras, ¿será posible la
        sobrecarga de constructores? La respuesta es afirmativa.
    </p>
    <div class="destacado">
        <p style="text-align: center;">
            <strong>
                Una misma clase puede disponer de varios constructores.
                Los constructores soportan la sobrecarga.
            </strong>
        </p>
    </div>
    <p>
        Es necesario que
        <strong>
            toda clase tenga al menos un constructor
        </strong>
        . Si no se define
        ningún constructor en una clase, el compilador creará por nosotros un
        <strong>
            constructor por
            omisión (o por defecto) vacío y sin parámetros que se encarga de inicializar todos los
            atributos a sus valores por omisión
        </strong>
        (0 para los numéricos y el tipo char,
        <code>
            false
        </code>
        para los boolean,
        <code>
            null
        </code>
        para las referencias,). Que lo cree por nosotros no quiere
        decir que en nuestro código fuente aparezcan añadidas nuevas líneas de código escritas en Java
        para que podamos verlo, sino que lo genera en el código compilado. Por tanto, aunque no lo
        veamos, estará disponible. A este constructor se le suele llamar
        <strong>
            default
            constructor
        </strong>
        (o constructor por omisión, o constructor por defecto).
    </p>
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Algunas analogías que podrías imaginar para representar el constructor de una clase podrían
        ser:
    </p>
    <ul class="lista_verificacion">
        <li>
            los moldes de cocina para flanes, galletas, pastas,
            <abbr title="etcétera.">
                etc
            </abbr>
            .,
        </li>
        <li>
            un cubo de playa para crear castillos de arena,
        </li>
        <li>
            un molde de un lingote de oro,
        </li>
        <li>
            una bolsa para hacer cubitos de hielo.
        </li>
    </ul>
    <p>
        Se trata del "fabricante" que rellena el molde de la clase para crear un objeto real con con
        contenido.
    </p>
</div><h1 class="title">
    6.2.- Implementación de constructores
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 140px;">
    </div>
    <p>
        <br>
        Cuando se escribe el código de una clase normalmente se pretende que los objetos de esa clase
        se instancien de una determinada manera. Para ello se definen uno o más constructores en la
        clase. En la declaración de un constructor se indican:
        <br/></p>
    <ul class="lista_verificacion">
        <li>
            el tipo de acceso,
        </li>
        <li>
            el nombre de la clase (el nombre de un método constructor es siempre el nombre de la propia
            clase),
        </li>
        <li>
            la lista de parámetros que puede aceptar,
        </li>
        <li>
            si lanza o no excepciones,
        </li>
        <li>
            el cuerpo del constructor (un bloque de código como el de cualquier método).
        </li>
    </ul>
    <p>
        Como puedes observar, la estructura de los constructores es similar a la de cualquier método,
        con
        las excepciones de que
        <strong>
            no tiene tipo de dato devuelto
        </strong>
        , ni siquiera void (no
        devuelve ningún valor explícitamente con la sentencia return), y que
        <strong>
            el nombre del
            método constructor debe ser obligatoriamente el nombre de la clase
        </strong>
        .
    </p>
</div><h1 class="title">
    6.3.- Lanzando exepciones desde los constructores
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 100px;">
    </div>
    <p>
        De la misma manera que hemos lanzado
        <strong>
            excepciones
        </strong>
        desde métodos cuando se
        producían
        <strong>
            situaciones no deseadas o erróneas
        </strong>
        interrumpiendo la ejecución del
        método, también puede hacerse desde un constructor. Esto haría que detuviera bruscamente la
        ejecución del constructor y evitaría que se finalizara el proceso de construcción. De esta forma
        se impediría que llegara a instanciarse el objeto devolviéndose el control de la ejecución a
        lugar desde donde se invocó al constructor.
    </p>
    <p>
        <strong>
            ¿En qué casos puede ser conviente impedir que se intancie un objeto?
        </strong>
        Imagina,
        por ejemplo que los parámetros que se han pasado al constructor no son apropiados por no cumplir
        alguna condición. En tal caso no debería poder crearse un objeto con atributos inválidos. Es una
        manera de garantizar que si el objeto ha sido creado es porque ha sido posible hacerlo con todas
        las garantías.
    </p>
    <p>
        Si volvermos a nuestro ejemplo anterior de la clase Persona, podríamos por ejemplo evitar que se
        lleve a cabo la instanciación si los valores que se pasan como parámetros no son adecuados:
    </p>
    <ul>
        <li class="lista_verificacion">
            ninguno de los parámetros nombre,
            <code>
                apellido1
            </code>
            ,
            apellido2,
            <code>
                dni
            </code>
            debería null o vacío (cadena vacía),
        </li>
        <li class="lista_verificacion">
            el parámetro dni, además, debería contener un
            <abbr title="Documento Nacional de Identidad">
                DNI
            </abbr>
            válido (ocho números más una letra
            que corresponda a esos números).
        </li>
    </ul>
    <p>
        Por tanto, el constructor no va a consistir simplemente en la asignación de valores a atributos,
        sino que en muchas ocasiones también contendrá comprobaciones de validez y coherencia como ya
        hemos hecho en muchos otros métodos.
    </p>
    <p>
        Teniendo en cuenta todo eso, un
        <strong>
            constructor con cuatro parámetros
        </strong>
        para nuestra
        clase&nbsp;Persona podría quedar de la sigiente manera:
    </p>
    <div class="highlighted-code language-java">
        <pre>public Persona (String nombre, String apellido1, String apellido2, String dni) throws IllegalArgumentException &#123;
  // Comprobación de que los valores de entrada son válidos
  if (nombre==null || apellido1==null || apellido2==null || dni==null) &#123;  // Comprobación de valores no nulos
    throw new IllegalArgumentException ("alguno de los parámetros de entrada es null");
  &#125; else if (nombre.isEmpty() || apellido1.isEmpty() || apellido2.isEmpty() || dni.isEmpty()) &#123;  // Comprobación valores no vacíos
    throw new IllegalArgumentException ("alguno de los parámetros de entrada es una cadena vacía");
  &#125; else if (!isDniValido(dni)) &#123; // Comprobación de que el DNI es válido
    throw new IllegalArgumentException ("el DNI no es válido");
  &#125;

  // Una vez que se ha garantizado que todos los valores de entrada son apropiados, puede continuar el proceso de instanciación
  // del objeto

  // Asignación de valores iniciales a los atributos a partir de los parámetros de entrada recibidos
  this.nombre= nombre;
  this.apellido1= apellido1;
  this.apellido2= apellido2;
  this.dni= dni;
&#125;
</pre>
    </div>
    <p>
        Si quisiéramos ser más específicos a la hora de indicar el error que se ha producido, siempre
        podemos tratar cada comprobación por separado y generar un texto de error que proporcione
        información más concreta. El precio que tendremos que pagar será escribir más líneas de código
        para comprobar cada posible error por separado. Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <pre>public Persona (String nombre, String apellido1, String apellido2, String dni) throws IllegalArgumentException &#123;
  // Comprobación de que los valores de entrada son válidos
  if (nombre==null || nombre.isEmpty())
    throw new IllegalArgumentException ("el parámetro nombre es null o contiene la cadena vacía");
  if (apellido1==null ||apellido1.isEmpty())
    throw new IllegalArgumentException ("el parámetro apellido1 es null o contiene la cadena vacía");
  if (apellido2==null ||apellido2.isEmpty())
    throw new IllegalArgumentException ("el parámetro apellido2 es null o contiene la cadena vacía");
  if (dni==null ||dni.isEmpty())
    throw new IllegalArgumentException ("el parámetro dni es null o contiene la cadena vacía");
  if (!isDniValido(dni))
    throw new IllegalArgumentException ("el DNI no es válido");
  ...
</pre>
    </div>
    <p>
        Por otro lado, también podría decidirse lo contrario: devolver siempre el mismo mensaje de error
        en caso de que algún parámetro no sea apropiado (un texto de error del estilo "
        <em>
            parámetros no
            válidos
        </em>
        "). Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <pre>public Persona (String nombre, String apellido1, String apellido2, String dni) throws IllegalArgumentException &#123;
  // Comprobación de que los valores de entrada son válidos
  if (nombre==null || nombre.isEmpty()) apellido1==null || apellido1.isEmpty() apellido2==null ||apellido2.isEmpty() ||
    dni==null ||dni.isEmpty() || !isDniValido(dni)) &#123;
      throw new IllegalArgumentException ("parámetros no válidos");
  ...

</pre>
    </div>
    <p>
        Todo dependerá de lo "finos" que queramos ser a la hora de indicar por qué se ha producido un
        error. Cuanto más específicos seamos más información se proporcionará a quien use el constructor
        y mayor será la complejidad de las líneas de código del cuerpo del constructor. Cuanto menos
        específicos seamos, menos información proporcionaremos sobre el error y el código del
        constructor quedará más simple Deberemos decidir en cada caso qué es lo más ventajoso para el
        uso de la clase por parte de otro programador.
    </p>
    <p>
        En cualquier caso, a partir de ahora,
        <strong>
            cada vez que intentemos instanciar un objeto de la
            clase&nbsp;Persona deberíamos hacerlo dentro de un bloque try - catch
        </strong>
        para poder
        capturar los posibles errores que se pudieran producir durante el proceso de construcción o
        instanciación:
    </p>
    <div class="highlighted-code language-java">
        <pre>Persona p1;
try &#123;
  p1= new Persona ("Juan", "Gil", "Torres", "12345678L");
  System.out.printf ("Objeto Persona creado y referenciado desde la variable p1.\n");
  System.out.printf ("Contenido referenciado por p1: %s.\n", p1.toString());
&#125; catch (IllegalArgumentException ex) &#123;
  System.our.printf ("Error al intentar instanciar un objeto persona: %s.\n", ex.getMessage());
&#125;
</pre>
    </div>
</div><h1 class="title">
    6.4.- Sobrecarga de constructores
</h1>
<div class="iDevice_content">
    <p>
        Habrá ocasiones en las que puede que te interese disponer de más de un constructor porque no
        siempre necesitemos pasarle la misma cantidad de parámetros. Imagina por ejemplo el caso de la
        clase Rectangulo que ya hemos usado en ocasiones anteriores. Podríamos definir un primer
        constructor donde se pasaran todos los valores iniciales de los atributos de objeto:
    </p>
    <div class="highlighted-code language-java">
        <pre>public Rectangulo (double x1, double y1, double x2, double y2, String nombre, String color) throws IllegalArgumentException &#123;
  // Comprobación de que los valores de entrada son válidos

  if (x1>=x2 || y1>y2)  // Comprobación de que la ubicación no es inconsistente (x1,y1) debe estar a la izquierda y por debajo de (x2,y2)
      throw new IllegalArgumentException (
	    String.format ("El vértice (x1,y1)=(%.2f,%.2f) debe estar a la izquierda y por debajo del (x2,y2)=(%.2f,%.2f)",
	    x1, y1, x2, y2)
      );
  if ( nombre == null || nombre.isEmpty() )  // Comprobación de que el nombre no es null ni vacío
      throw new IllegalArgumentException ("nombre null o vacío");
  if ( color== null || color.isEmpty() )  // Comprobación de que el color no es null ni vacío
      throw new IllegalArgumentException ("color null o vacío");

  // Una vez que se ha garantizado que todos los valores de entrada son apropiados, puede continuar el proceso de instanciación
  // del objeto

  // Asignación de valores iniciales a los atributos de estado
  this.x1= x1;
  this.y1= y1;
  this.x2= x2;
  this.y2= y2;
  this.nombre= nombre;
  this.color= color;

  // Actualización de atributos de clase por el hecho de crearse un nuevo rectángulo
  Rectangulo.cantidadRectangulos++;  // Incrementamos la cantidad de rectángulos creados
&#125;
</pre>
    </div>
    <div class="exe-figure exe-image license-pd position-center" style="width: 280px;">
    </div>
    <p>
        Sin embargo, puede ser que también nos interesara disponer de un constructor al que sólo le
        pasáramos las coordenadas de ubicación. Pero entonces, ¿qué valor inicial podríamos asignarle al
        nombre y al color? Podría decidirse disponer de unos valores por omisión para esos casos. Si se
        toma esa decisión es recomendable incluir atributos de clase constantes que almacenen esos
        valores para evitar tener que escribir literales dentro de nuestro código. De este modo, si
        algún día se decide modificar esos valores por omisión, tan tolo habrá que cambiarlos en la
        declaración de esos atributos y no habrá que estar realizando cambios el resto del código. Es la
        filosofía conocida como: "
        <em>
            escríbelo una vez, úsalo muchas
        </em>
        " ("
        <em>
        </em>
        <span lang="en">
         <em>
          write it once, use multiple times
         </em>
        </span>
        ").
    </p>
    <p>
        Para ello entonces podríamos definir esos dos nuevos atributos:
    </p>
    <div class="highlighted-code language-java">
        <pre>public class Rectangulo &#123;
  // ATRIBUTOS DE CLASE: sólo habrá un atributo (común para todos los objetos) parar representar estas características
  // -----------------------------------------------------------------------------------------------------------------

  // Atributos de clase constantes. Representan características "inmutables" de la clase,
  // como por ejemplo restricciones, valores informativos, valores por omisión (default), etc.
  public final static String NOMBRE_DEFAULT = "Anónimo";  // Nombre que se asignará por omisión si no se proporciona uno
  public final static double COLOR_DEFAULT =  "negro";    // Color  que se asignará por omisión si no se proporciona uno

  ...

&#125;
</pre>
    </div>
    <p>
        Y usaremos esos valores para asignarlos a los atributos nombre y
        <code>
            color
        </code>
        en la versión
        del constructor que no recibe esos dos parámetros:
    </p>
    <div class="highlighted-code language-java">
        <pre>public Rectangulo (double x1, double y1, double x2, double y2) throws IllegalArgumentException &#123;
  ...

  this.nombre= NOMBRE_DEFAULT;
  this.color= COLOR_DEFAULT;
  ...
&#125;
</pre>
    </div>
    <p>
        Ahora bien, ¿tenemos que escribir otra vez todo el código del constructor cambiando únicamente
        esas dos líneas? ¿Tendremos que escribir otra vez todas las sentencias de comprobación de los
        parámetros y todas las instrucciones de asignación de valores inciales a los atributos? No
        parece muy razonable, ¿verdad? Sobre todo después de haber dicho que íbamos a intentar seguir
        una filosofía del tipo "
        <em>
            escríbelo una vez, úsalo muchas
        </em>
        ". Repetir código en nuestras
        clases para supuestamente hacer lo mismo o algo muy parecido es muy peligroso, pues si más
        adelante hay que realizar algún cambio, tendrás que aplicar esa modificación a todos los sitios
        donde ese cambio afecte.
    </p>
    <p>
        Por ejemplo, imagínate que has escrito tres o cuatro constructores en los cuales repites una y
        otra vez una buena parte de las comprobaciones y las asignaciones con ligeras variaciones y
        posteriormente descubres que te has confundido en alguna de esas comprobaciones. Tendrías que
        corregir ese error en todos los sitios donde aparezca. Si sólo apareciera en un sitio y el resto
        de constructores lo reutilizaran, sólo tendrías que arreglarlo una vez. Esto, además de
        ahorrarte mucho tiempo y dolores de cabeza, te evita el peligro de que no llegues a corregir el
        fallo en todos los lugares donde se ha repetido, quedando en algunas zonas del código arreglado
        y en otras sin arreglar. Imagínate el lío que podría producirse y cómo se incrementaría el
        tiempo que necesitarías para implementar tu clase cada vez que descubrieras un pequeño
        error.
    </p>
    <p>
        Muy bien, una vez que tenemos claro que
        <strong>
            debemos evitar siempre que sea posible el código
            redundante
        </strong>
        , viene el momento de preguntarnos si es posible hacerlo en el caso de los
        constructores en Java. ¿Proporciona el lenguaje algún mecanismo para poder llamar a un
        constructor desde otro constructor?
    </p>
</div><h1 class="title">
    6.4.1.- Uso de la llamada a this() en los constructores
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado titulo">
            Reutilizando el constructor.
        </div>
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        ¿Recuerdas que en un apartado anterior titulado como
        <em>
            "La referencia this"
        </em>
        ,&nbsp; te
        dijimos que no había que confundir el operador this con el método this()?
    </p>
    <p>
        Había un bloque "
        <em>
            Para saber más
        </em>
        " donde se hablaba de usar&nbsp;this en constructores, y
        un bloque "
        <em>
            Reflexiona
        </em>
        " donde te indicábamos que se explicaría con más detalle más
        adelante. Pues bien, ha llegado el momento de desarrollar ese tema.
    </p>
    <p>
        Volviendo al
        <strong>
            constructor
        </strong>
        de nuestra clase Rectangulo, en el apartado anterior
        afirmamos que no era necesario volver a tener que escribir de nuevo todo el código relativo a
        las comprobaciones y asignaciones de atributos a partir de los parámetros recibidos. Dijimos que
        para ello Java nos ofrecía un mecanismo conocido como llamada a this().
    </p>
    <p>
        La llamada a&nbsp;this() consiste en la invocación a un constructor de la clase desde un
        constructor diferente. De esta manera podemos tener un constructor que se encargue de todo el
        "trabajo duro" de comprobaciones y asignaciones y el resto de constructores (que normalmente
        tendrán una menor cantidad de prámetros) harán uso de este constructor más "grande, complejo e
        inteligente" evitando tener que repetir el código que éste contiene.
    </p>
    <p>
        En nuestro ejemplo de constructor de la clase Rectangulo que no recibe como parámetros el nombre
        y el color, podría quedar así:
    </p>
    <div class="highlighted-code language-java">
        <pre>// Constructor con cuatro parámetros: x1,y1,x2,y2
// Los atributos nombre y color tomarán los valores por omisión
public Rectangulo (double x1, double y1, double x2, double y2) throws IllegalArgumentException &#123;
  // Llamada al constructor con seis parámetros
  this (x1, y1, x2, y2, Rectangulo.NOMBRE_DEFAULT, Rectangulo.COLOR_DEFAULT);
&#125;
</pre>
    </div>
    <p>
        De esta manera el cuerpo de esta versión del constructor (con cuatro parámetros) queda reducida
        a
        su mínima expresión haciendo una invocación al constructor con seis parámetros que ya se ha
        implementado anteriormente. Así podemos reutilizar ese constructor y aprovechar todas las
        comprobaciones y asignaciones que se realizan en él sin tener que volver a escribir todo ese
        código. Qué fácil, ¿no?
    </p>
    <p>
        Veamos otro ejemplo más. Supongamos que también nos interesa disponer de un constructor sin
        parámetros donde se establezcan, además del nombre y el color por omisión, también una ubicación
        por omisión definida por los puntos (0.0,0.0) y (1.0,1.0).
    </p>
    <p>
        En tal caso podríamos hacer una llamada al anterior constructor de cuatro parámetros con esos
        valores por omisión:
    </p>
    <div class="highlighted-code language-java">
        <pre>// Constructor sin parámetros
// Todos los atributos tomarán sus valores por omisión
public Rectangulo () &#123;
  // Llamada al constructor con cuatro parámetros con la ubicación (0.0,0.0), (1.0,1.0)
  this (0.0, 0.0, 1.0, 1.0);
&#125;
</pre>
    </div>
    <p>
        Por otro lado, como hemos dicho antes, también es conveniente disponer de los
        <strong>
            valores por
            omisión
        </strong>
        (así como máximos, mínimos,
        <abbr title="etcétera">
            etc.
        </abbr>
        ) en
        <strong>
            constantes
            de clase
        </strong>
        para no tener que escribirlos una y otra vez a lo largo de todo el código:
        X1_DEFAULT,
        <code>
            Y1_DEFAULT
        </code>
        ,
        <abbr title="etcétera">
            etc.
        </abbr>
        En tal caso el
        constructor podría quedar así:
    </p>
    <div class="highlighted-code language-java">
        <pre>public Rectangulo () &#123;
  // Llamada al constructor con cuatro parámetros usando la ubicación por omisión
  this (Rectangulo.X1_DEFAULT, Rectangulo.Y1_DEFAULT, Rectangulo.X2_DEFAULT, Rectangulo.Y2_DEFAULT);
&#125;
</pre>
    </div>
    <p>
        Desde otro punto de vista, podrías haber decidido llamar directamente desde el constructor sin
        parámetros al constructor con seis parámetros y saltarte el "paso" del constructor con cuatro
        parámetros. Podrías haberlo hecho perfectamente:
    </p>
    <div class="highlighted-code language-java">
        <pre>public Rectangulo () &#123;
  // Llamada al constructor con seis parámetros usando todos los valores por omisión
  this (X1_DEFAULT, Y1_DEFAULT, X2_DEFAULT, Y2_DEFAULT, NOMBRE_DEFAULT, COLOR_DEFAULT);
&#125;
</pre>
    </div>
    <p>
        Ahora bien, tendrías que escribir algo más de código, que si algún día se descubre que contiene
        algún error, tendrías que cambiar. Cuanto menos código tengas que escribir, mejor.
    </p>
    <p>
        Además de estos constructores, puedes implementar todos los que quieras y consideres que te
        pueden resultar útiles. Por ejemplo, imagina que te interesa un constructor con dos parámetros
        (nombre y color) que cree un rectángulo con ese nombre y ese color en la ubicación por omisión.
        No habría problema, podrías implementarlo también. La única limitación que vas a tener es la
        propia que impone la sobrecarga de métodos:
        <strong>
            no puede haber constructores que tengan
            exactamente la misma lista de parámetros
        </strong>
        (para evitar la ambigüedad).
    </p>
    <p>
        Teniendo en cuenta esto, ¿podríamos entones declarar ese constructor con dos parámetros de tipo
        String? No habría problema, pues aún no se ha declarado ningún constructor que tenga únicamente
        dos parámetros de tipo String. Nuestro constructor quedaría entonces así:
    </p>
    <div class="highlighted-code language-java">
        <pre>// Constructor con dos parámetros: sólo nombre y color
// Los atributos de ubicación (x1,y1,x2,y2) tomarán sus valores por omisión
public Rectangulo (String nombre, String color) throws IllegalArgumentException &#123;
  // Llamada al constructor con seis parámetros usando la ubicación por omisión
  this (Rectangulo.X1_DEFAULT, Rectangulo.Y1_DEFAULT, Rectangulo.X2_DEFAULT, Rectangulo.Y2_DEFAULT, nombre, color);
&#125;
</pre>
    </div>
</div><h1 class="title">
    6.5.- Constructores de copia
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 160px;">
    </div>
    <p>
        <br>
        Una forma de iniciar un objeto podría ser mediante la copia de los valores de los atributos
        de otro objeto ya existente. Imagina que necesitas varios objetos iguales (con los mismos
        valores en sus atributos) y que ya tienes uno de ellos perfectamente configurado (sus atributos
        contienen los valores que tú necesitas). Estaría bien disponer de un constructor que hiciera
        copias idénticas de ese objeto.
        <br/></p>
    <p>
        Durante el proceso de creación de un objeto puedes generar objetos exactamente iguales (basados
        en la misma clase) que se distinguirán posteriormente porque podrán tener estados distintos
        (valores diferentes en los atributos). La idea es poder decirle a la clase que además de generar
        un objeto nuevo, que lo haga con los mismos valores que tenga otro objeto ya existente. Es
        decir, algo así como si pudieras
        <strong>
            clonar
        </strong>
        el objeto tantas veces como te haga
        falta. A este tipo de mecanismo se le suele llamar
        <strong>
            constructor copia
        </strong>
        o
        <strong>
            constructor
            de copia
        </strong>
        .
    </p>
    <p>
        Un constructor copia es un método constructor como los que ya has utilizado pero con la
        particularidad de que recibe como parámetro una referencia al objeto cuyo contenido se desea
        copiar. Este método revisa cada uno de los atributos del objeto recibido como parámetro y se
        copian todos sus valores en los atributos del objeto que se está creando en ese momento en el
        método constructor.
    </p>
    <p>
        Un ejemplo de constructor copia para la clase Rectangulo podría ser:
    </p>
    <div class="highlighted-code language-java">
        <pre>public Rectangulo (Rectangulo r) &#123;
  // Asignación de valores iniciales a los atributos de estado
  this.x1= r.x1;
  this.y1= r.y1;
  this.x2= r.x2;
  this.y2= r.y2;
  this.nombre= r.nombre;
  this.color= r.color;

  // Actualización de atributos de clase por el hecho de crearse un nuevo rectángulo
  Rectangulo.cantidadRectangulos++;  // Incrementamos la cantidad de rectángulos creados
&#125;
</pre>
    </div>
    <p>
        Además, si nos es posible, deberíamos aprovechar la llamada a this() para no tener que volver a
        escribir todas las líneas de código de asignación de atributos de objeto y de actualización de
        atributos de clase, tal y como ya hemos hecho en otros casos de
        <strong>
            sobrecarga de
            constructores
        </strong>
        :
    </p>
    <div class="highlighted-code language-java">
        <pre>public Rectangulo (Rectangulo r) &#123;
  this (r.x1, r.y1, r.x2, r.y2, r.nombre, r.color);  // Llamada al constructor con seis parámetros
&#125;
</pre>
    </div>
    <p>
        Si te fijas, aquí ya no se puede dar el caso de un parámetro inválido para "rellenar" los
        atributos del objeto, pues estamos pasando un objeto que ya ha sido creado y que por tanto debe
        tener todos sus atributos correctos.
    </p>
    <p>
        Ahora bien, debemos tener cuidado porque podría ser que el parámetro r fuera null. En tal caso
        se
        nos produciría una NullPointerException en cuanto intentaramos realizar cualquier acceso a un
        miembro de&nbsp;r (por ejemplo r.x1). Es decir, que este método, aunque no lance una
        IllegalArgumentException, sí habrá que añadirle que puede lanzar una NullPointerException. Por
        tanto el constructor nos quedaría finalmente:
    </p>
    <div class="highlighted-code language-java">
        <pre>public Rectangulo (Rectangulo r) throws NullPointerException &#123;  // Si r es null se lanzará una NullPointerException
  this (r.x1, r.y1, r.x2, r.y2, r.nombre, r.color);  // Llamada al constructor con seis parámetros
&#125;
</pre>
    </div>
</div><h1 class="title">
    6.6.- Destrucción de objetos
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-left license-pd" style="width: 200px;">
    </div>
    <p>
        <br>
        Como ya has estudiado en unidades anteriores, cuando un objeto deja de ser utilizado, los
        recursos usados por él (memoria, acceso a archivos, conexiones con bases de datos,
        <abbr title="etcétera.">
            etc.
        </abbr>
        ) deberían de ser liberados para que puedan volver a ser
        utilizados por otros procesos (mecanismo de
        <strong>
            destrucción del objeto
        </strong>
        ).
        <br/></p>
    <p>
        En Java, mientras que de la construcción de los objetos se encargan los métodos constructores,
        implementados por el programador, de la destrucción se encarga un proceso del entorno de
        ejecución conocido como
        <strong>
            recolector de basura
        </strong>
        (
        <strong>
         <span lang="en">
          garbage collector
         </span>
        </strong>
        ).
        Este proceso va buscando periódicamente objetos que ya no son referenciados (no hay ninguna
        variable que haga referencia a ellos y por tanto no hay manera de poder llegar a ellos para
        usarlos desde el programa) y los marca para ser eliminados. Posteriormente los irá eliminando de
        la memoria cuando lo considere oportuno (en función de la carga del sistema, los recursos
        disponibles,
        <abbr title="etcétera.">
            etc.
        </abbr>
        ).
    </p>
    <p>
        <span>
         Normalmente se suele decir que en
        </span>
        <span lang="en">
         Java
        </span>
        <span>
         no hay método destructor, mientras que en otros lenguajes orientados a objetos como
        </span>
        <strong>
            <abbr title="C orientado a objetos.">
                C++
            </abbr>
        </strong>
        <span>
         , sí se implementa explícitamente el destructor de una clase de la misma manera que se define el constructor. En realidad en
        </span>
        <span lang="en">
         Java
        </span>
        <span>
         también es posible implementar el método destructor de una clase: se trata del método
        </span>
        finalize()
        <span>
         . Ahora bien, este proceso de destrucción no funciona exactamente de la misma forma que en otros lenguajes, donde el control total de la destrucción se deja en manos del programador. En
        </span>
        <span lang="en">
         Java
        </span>
        <span>
         más bien podemos decidir qué deberá hacerse al destruir un objeto, pero nunca cuándo se destruirá (de eso ya se encargará el recolector de basura)
        </span>
        .
    </p>
    <p>
        Este método finalize() es llamado por el recolector de basura cuando va a destruir el objeto (lo
        cual nunca se sabe cuándo va a suceder exactamente, pues una cosa es que el objeto sea marcado
        para ser borrado y otra que sea borrado efectivamente). Si ese método no existe, se ejecutará un
        destructor por omisión (el método finalize() que contiene la clase Object, de la cual heredan
        todas las clases en
        <span lang="en">
         Java
        </span>
        ) que liberará la memoria ocupada por el objeto.
        Se recomienda por tanto que si un objeto utiliza determinados recursos de los cuales no tienes
        garantía que el entorno de ejecución los vaya a liberar (cerrar archivos, cerrar conexiones de
        red, cerrar conexiones con bases de datos,
        <span lang="en">
         etc.
        </span>
        ), implementes
        explícitamente un método finalize() en tus clases. Si el único recurso que utiliza tu clase es
        la memoria necesaria para albergar sus atributos, eso sí será liberado sin problemas. Pero si se
        trata de algo más complejo, será mejor que te encargues tú mismo de hacerlo implementando tu
        destructor personalizado (finalize()).
    </p>
    <p>
        Por otro lado, esta forma de funcionar del entorno de ejecución de
        <span lang="en">
         Java
        </span>
        (destrucción de objetos no referenciados mediante el recolector de basura) implica que no puedas
        saber exactamente cuándo un objeto va a ser definitivamente destruido, pues si una variable deja
        de ser referenciada (se cierra el ámbito de ejecución donde fue creada) no implica
        necesariamente que sea inmediatamente borrada, sino que simplemente es marcada para que el
        recolector la borre cuando pueda hacerlo.
    </p>
    <p>
        Si en un momento dado fuera necesario garantizar que el proceso de finalización (método
        finalize()) sea invocado, puedes recurrir al método estático runFinalization() de la clase
        System para forzarlo:
    </p>
    <div class="highlighted-code language-java">
        <pre>System.runFinalization();
</pre>
    </div>
    <p>
        Este método se encarga de llamar a todos los métodos finalize() de todos los objetos marcados
        por
        el recolector de basura para ser destruidos.
    </p>
    <p>
        Si necesitas implementar un destructor (normalmente no será necesario), debes tener en cuenta
        que:
    </p>
    <ul class="lista_verificacion">
        <li>
            el nombre del método destructor debe ser finalize(),
        </li>
        <li>
            no puede recibir parámetros,
        </li>
        <li>
            sólo puede haber un destructor en una clase. No es posible la sobrecarga dado que no tiene
            parámetros,
        </li>
        <li>
            no puede devolver ningún valor. Debe ser de tipo void.
        </li>
    </ul>
    <p>
        También existe la posibilidad de invocar al recolector de basura explícitamente, mediante el
        método System.gc() (
        <span lang="en">
         Garbage Collector
        </span>
        ). Pero su invocación no es más que
        una sugerencia a la máquina virtual para que considere la conveniencia de lanzar el recolector
        de basura en ese momento que nosotros estimamos oportuno por algún motivo (haber borrado de
        muchos elementos,
        <abbr title="etcétera.">
            etc.
        </abbr>
        ), pero la máquina virtual podrá atender
        nuestra solicitud o no tenerla en cuenta en función de las necesidades del sistema.
    </p>
</div><h1 class="title">
    6.7.- Métodos "fábrica" o pseudoconstructores
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-left license-pd" style="width: 180px;">
    </div>
    <p class="lista_verificacion">
        En algunos casos podrás encontrarte con métodos de una clase que
        devuelven objetos instancias de esa misma clase. En algunas ocasiones puede deberse a que se
        trata de un método que realiza algún tipo de operación entre el objeto cuyo método se invoca y
        el o los parámetros que recibe, devolviendo un nuevo objeto resultado de esa operación. Algunos
        ejemplos de esto podrían ser los métodos plusDays,
        <code>
            plusMonths
        </code>
        o&nbsp;plusYears
        de la clase LocalDate que devuelven una nueva fecha sumando una determinada cantidad de días,
        meses o años a la fecha objeto original. Son métodos que no modifican el objeto cambiando sus
        atributos de fecha sino que generan una nueva fecha con esos cambios (algo similar sucede con
        los atributos de la clase String).
    </p>
    <p class="lista_verificacion">
        En otros casos se trata de un
        <strong>
            método estático
        </strong>
        que
        genera un nuevo objeto de esa clase a partir de ciertos parámetros, como si fuera un
        constructor. Hay quien llama a estos métodos "pseudoconstructores" o métodos "fábrica" pues se
        trata de métodos que "fabrican" o instancian objetos de una manera similar a como lo hacen los
        constructores.
    </p>
    <p>
        Ya has visto algunas clases de la
        <abbr title="Application Programming Interface">
            API
        </abbr>
        de Java que tienen métodos de este tipo. Por ejemplo la clase LocalTime, que no dispone de
        constructores públicos sino que proporciona tres métodos estáticos para poder obtener un objeto
        de tipo LocalTime:
    </p>
    <ul>
        <li class="lista_verificacion">
            método of, que devuelve un nuevo objeto LocalTime a partir de
            varios números enteros (hora, minutos, segundo). Es muy similar a un constructor;
        </li>
        <li class="lista_verificacion">
            método parse, que devuelve un nuevo objeto LocalTime a partir de
            una cadena de caracteres con formato de de hora (como por ejemplo "09:15");
        </li>
        <li class="lista_verificacion">
            método now, que devuelve un nuevo objeto LocalTime con la hora
            actual del sistema.
        </li>
    </ul>
    <p>
        Esos tres métodos permiten instanciar un nuevo objeto de la clase LocalTime como si fueran
        constructores, aunque formalmente no lo son. ¿Cómo podríamos nosotros implementar métodos de ese
        tipo en nuestras clases? Debemos tener en cuenta lo siguiente:
    </p>
    <ol>
        <li>
            el método debe ser
            <strong>
                estático
            </strong>
            , pues no tiene mucho sentido que sea invocado
            desde un objeto. Debe ser invocado desde la clase;
        </li>
        <li>
            el método debe
            <strong>
                devolver un objeto del mismo tipo que la clase
            </strong>
            a la que
            pertenece;
        </li>
        <li>
            hay que
            <strong>
                llamar a algún constructor de la clase
            </strong>
            con el operador new dentro
            del método;
        </li>
        <li>
            hay que
            <strong>
                devolver la referencia obtenida
            </strong>
            con el operador new mediante una
            sentencia return.
        </li>
    </ol>
    <p>
        Llevando a cabo esos pasos podremos crear nuestro propio "pseudoconstructor" o método "fábrica".
        Si te fijas, en el fondo vamos a necesitar hacer internamente una llamada a un constructor con
        el operador new, pero eso no será percibido desde fuera por quien use el método.
    </p>
    <p>
        Veamos algunos ejemplos de implementación de métodos "pseudoconstructores" para la clase
        Rectangulo.
    </p>
    <p>
        Por ejemplo, podríamos implementar el método llamado crear, que genera un rectángulo de la misma
        manera que lo haría el constructor:
    </p>
    <div class="highlighted-code language-java">
        <pre>public static Rectangulo crear (double x1, double y1, double x2, double y2, String nombre, String color) throws IllegalArgumentException &#123;
  return new Rectangulo (x1, y1, x2, y2, nombre, color);
&#125;
</pre>
    </div>
    <p>
        En este caso no añadimos nada nuevo, pues se trata simplemente una llamada al constructor.
    </p>
    <p>
        Veamos otro ejemplo en el que implementemos un método llamado random, que genere un rectángulo
        con la esquina inferior izquierda en (0,0) y con la
        <strong>
            esquina superior derecha
        </strong>
        en
        un
        <strong>
            punto aleatorio
        </strong>
        entre (1,1) y (10,10).
    </p>
    <div class="highlighted-code language-java">
        <pre>public static Rectangulo random (String nombre, String color) throws IllegalArgumentException &#123;
  Rectangulo r;
  double x2 = 1.0 + (int)(Math.random() * 10);
  double y2 = 1.0 + (int)(Math.random() * 10);
  r = new Rectangulo(Rectangulo.X1_DEFAULT, Rectangulo.Y1_DEFAULT, x2, y2, nombre, color);
  return r;
&#125;
</pre>
    </div>
    <p>
        Este ejemplo sí hace algo nuevo o diferente respecto a un constructor "habitual".
    </p>
    <p>
        Podríamos seguir complicando los ejemplos todo lo que quisiéramos. Imaginemos un método
        buildSampleRectangulos que crea un array con varios rectángulos de ejemplo. En este caso en
        lugar de devolver un único rectángulo se crean y devuelven varios:
    </p>
    <div class="highlighted-code language-java">
        <pre>public static Rectangulo[] buildSampleRectangulos()
&#123;
    return new Rectangulo[]&#123;
        new Rectangulo(0.0, 0.0, 1.0, 1.0, "black", "r1"),
        new Rectangulo(0.0, 0.0, 2.0, 2.0, "white", "r2"),
        new Rectangulo(2.0, 2.0, 5.0, 3.0, "red",   "r3"),
        new Rectangulo(6.0, 6.0, 8.0, 8.0, "black", "r4")
    &#125;;
&#125;
</pre>
    </div>
</div><h1 class="title">
    6.8.- Bloques de inicialización en Java
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 140px;">
    </div>
    <p>
        <br>
        El lenguaje Jave permite especificar bloques de incialización en las clases. Pero,
        <strong>
            ¿qué
            es un bloque de inicialización?
        </strong>
        Se trata de un fragmento de código encerrado entre
        llaves que se ejecuta al inicializar una clase o un objeto. Se puede hablar por tanto de dos
        tipos de bloques de inicialización:
        <br/></p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                bloque de inicialización estático
            </strong>
            . Se ejecuta
            <strong>
                al cargar la
                clase
            </strong>
            en memoria (al inicio del programa) y no tendrá acceso a atributos o métodos
            de objeto. Es lógico pues aún no puede existir ninguna instancia de esa clase;
        </li>
        <li>
            <strong>
                bloque de inicialización de instancia (o de objeto)
            </strong>
            . Se ejecuta
            <strong>
                al
                comienzo del constructor
            </strong>
            , justo después de la llamada al constructor de la
            superclase ("superconstructor") y antes de la ejecución de cualquier otra línea de código
            del constructor.
        </li>
    </ul>
    <p>
        Estos bloques de código pueden resultar de utilidad a la hora realizar inicializaciones tanto de
        la clase (al comienzo de la ejecución del programa) como del objeto (a la hora de ejecutar los
        constructores).
    </p>
    <p>
        El
        <strong>
            bloque de inicialización estático
        </strong>
        , puede ser adecuado para:
    </p>
    <ul class="lista_verificacion">
        <li>
            cargar información de configuración inicial desde un archivo,
        </li>
        <li>
            abrir una conexión de red,
        </li>
        <li>
            establecer una conexión con una base de datos,
        </li>
        <li>
            inicializar atributos estáticos,
        </li>
        <li>
            ejecutar algún otro tipo de código de configuración o inicialización,
        </li>
        <li>
            <abbr title="etcétera">
                etc.
            </abbr>
        </li>
    </ul>
    <p>
        Ese bloque de código sólo se ejecutará una vez (al comenzar la ejecución de un programa en el
        que
        se haga uso de la clase).
    </p>
    <p>
        Un bloque de inicialización estático se indica dentro del cuerpo de la clase mediante un par de
        <strong>
            llaves precedidas del modificador
        </strong>
        static:
    </p>
    <div class="highlighted-code language-java">
        <pre>static &#123;
  // Líneas de código del bloque de inicialización estático
  ...
&#125;
</pre>
    </div>
    <p>
        El
        <strong>
            bloque de inicialización de
        </strong>
        <strong>
            instancia
        </strong>
        puede resultar
        conveniente para llevar a cabo tareas similares a las anteriores pero cada vez que se construya
        un nuevo objeto instancia de la clase (cuando se invoque a un constructor).
    </p>
    <p>
        Un bloque de inicialización de instancia se indica dentro del cuerpo de la clase mediante un par
        de
        <strong>
            llaves
        </strong>
        sin ningún modificador:
    </p>
    <div class="highlighted-code language-java">
        <pre>&#123;
  // Líneas de código del bloque de inicialización de instancia
  ...
&#125;
</pre>
    </div>
    <p>
        Aquí tienes un ejemplo de uso de ambos bloques en una clase:
    </p>
    <div class="highlighted-code language-java">
        <pre>public class PruebaDeBloques &#123;
  private static int atributoClase;
  private int atributoInstancia;


  static &#123;  // Bloque de inicialización estático. Sólo se ejecutará una vez
    System.out.println("Bloque de inicialización estático.");
    atributoClase= 1;
  &#125;

  &#123;  // Bloque de inicialización estático. Se ejecutará tantas veces como objetos se creen
    System.out.println("Bloque de inicialización de instancia.");
    atributoInstancia= atributoClase*10;
    atributoClase *= 2;
  &#125;

  public static void main(String[] args) &#123;
    PruebaDeBloques b1, b2, b3, b4;
    System.out.printf ("Inicio de ejecución del programa...\n");
    System.out.printf ("atributoClase= %d\n", PruebaDeBloques.atributoClase);

    System.out.printf ("\nAsignamos a b1 la referencia de una nueva instancia de PruebaDeBloques.\n");
    b1 = new PruebaDeBloques();
    System.out.printf ("atributoClase= %d\n", PruebaDeBloques.atributoClase);
    System.out.printf ("b1.atributoIntancia= %d\n", b1.atributoInstancia);

    System.out.printf ("\nAsignamos a b2 la referencia de una nueva instancia de PruebaDeBloques.\n");
    b2 = new PruebaDeBloques();
    System.out.printf ("atributoClase= %d\n", PruebaDeBloques.atributoClase);
    System.out.printf ("b2.atributoInstancia= %d\n", b2.atributoInstancia);

    System.out.printf ("\nAsignamos a b3 la referencia almacenada en b1.\n");
    b3 = b1;
    System.out.printf ("atributoClase= %d\n", PruebaDeBloques.atributoClase);
    System.out.printf ("b3.atributoInstancia= %d\n", b3.atributoInstancia);

    System.out.printf ("\nAsignamos a b4 la referencia de una nueva instancia de PruebaDeBloques.\n");
    b4 = new PruebaDeBloques();
    System.out.printf ("atributoClase= %d\n", PruebaDeBloques.atributoClase);
    System.out.printf ("b4.atributoInstancia= %d\n", b4.atributoInstancia);
  &#125;
&#125;
</pre>
    </div>
    <p>
        Si ejecutas esa clase (dispone de método main y por tanto puedes hacerlo) obtendrías por la
        pantalla la siguiente información:
    </p>
    <div>
        <pre>Bloque de inicialización estático.
Inicio de ejecución del programa...
atributoClase= 1

Asignamos a b1 la referencia de una nueva instancia de PruebaDeBloques.
Bloque de inicialización de instancia.
atributoClase= 2
b1.atributoIntancia= 10

Asignamos a b2 la referencia de una nueva instancia de PruebaDeBloques.
Bloque de inicialización de instancia.
atributoClase= 4
b2.atributoInstancia= 20

Asignamos a b3 la referencia almacenada en b1.
atributoClase= 4
b3.atributoInstancia= 10

Asignamos a b4 la referencia de una nueva instancia de PruebaDeBloques.
Bloque de inicialización de instancia.
atributoClase= 8
b4.atributoInstancia= 40

</pre>
    </div>
</div><h1 class="title">
    7.- Documentación de una clase
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        <strong>
            Ada
        </strong>
        está mostrando a
        <strong>
            Juan
        </strong>
        la documentación sobre una
        serie de métodos estándar que van a necesitar para completar el desarrollo de una parte
        de la aplicación. Esta documentación tiene un formato estructurado y puede accederse a
        ella a través del navegador web.
    </p>
    <p>
        -¡Qué útil y fácil está siendo el acceso a esta documentación! La verdad es que los que
        la han generado se lo han currado bastante. Generar esta documentación se llevará mucho
        tiempo, ¿verdad, Ada? -pregunta
        <strong>
            Juan
        </strong>
        mientras recoge de la impresora la
        documentación impresa.
    </p>
    <p>
        <strong>
            Ada
        </strong>
        prepara rápidamente una clase en blanco y comienza a incorporarle
        una serie de comentarios:
    </p>
    <p>
        -Verás,
        <strong>
            Juan
        </strong>
        , documentar el código es vital y si incorporas a tu código
        fuente unos comentarios en el formato que te voy a mostrar, la documentación puede ser
        generada automáticamente a través de la herramienta Javadoc. Observa -responde
        <strong>
            Ada
        </strong>
        .
    </p>
</div><h1 class="title">
    7.1.- Etiquetas y posición
</h1>
<div class="iDevice_content">
    <p align="justify">
        Cuando hemos de incorporar determinadas
        <strong>
            etiquetas
        </strong>
        a nuestros
        <strong>
            comentarios de documentación
        </strong>
        es necesario conocer dónde y qué etiquetas
        colocar, según el tipo de código que estemos documentando en ese momento. Existirán dos tipos
        generales de etiquetas:
    </p>
    <ol>
        <li>
            <strong>
                Etiquetas de bloque:
            </strong>
            son etiquetas que solo pueden ser incluidas en el
            bloque de documentación, después de la descripción principal y comienzan con el símbolo
            <strong>
                &#64;
            </strong>
            .
        </li>
        <li>
            <strong>
                Etiquetas en texto:
            </strong>
            son etiquetas que pueden ponerse en cualquier punto de
            la descripción o en cualquier punto de la documentación asociada a una etiqueta de bloque.
            Son etiquetas definidas entre llaves, de la siguiente forma &#123;&#64;etiqueta&#125;
        </li>
    </ol>
    <p>
        En la siguiente tabla podrás encontrar una referencia sobre las diferentes etiquetas y su ámbito
        de uso.
    </p>
    <p>

    </p>
</div><h1 class="title">
    7.2.- Uso de las etiquetas
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p align="justify">
        ¿Cuáles son las etiquetas típicas y su significado?
    </p>
    <p align="justify">
        Pasaremos seguidamente a enumerar y describir la función de las etiquetas más
        habituales a la hora de generar comentarios de documentación.
    </p>
    <ul class="lista_verificacion">
        <li>
            &#64;author texto con el nombre: esta etiqueta solo se admite en
            <strong>
                clases
            </strong>
            e
            <strong>
                interfaces
            </strong>
            (las interfaces las veremos en la siguiente unidad). El texto
            después de la etiqueta no necesitará un formato especial. Podremos incluir tantas etiquetas
            de este tipo como necesitemos. Por ejemplo:
        </li>
    </ul>
    <div class="highlighted-code language-java">
        <div>
            <pre>&#64;author Profe</pre>
        </div>
    </div>
    <ul class="lista_verificacion">
        <li>
            &#64;version texto de la versión: el texto de la versión no necesitará un formato especial. Es
            conveniente incluir el número de la versión y la fecha de esta. Podremos incluir varias
            etiquetas de este tipo una detrás de otra.
        </li>
        <li>
            &#64;deprecated texto: indica que no debería utilizarse, indicando en el texto las causas de
            ello. Se puede utilizar en todos los apartados de la documentación. Si se ha realizado una
            sustitución debería indicarse qué utilizar en su lugar. Por ejemplo:
        </li>
    </ul>
    <div class="highlighted-code language-java">
        <div>
            <pre>&#64;deprecated El método no funciona correctamente. Se recomienda el uso de &#123;&#64;link metodoCorrecto&#125;</pre>
        </div>
    </div>
    <ul class="lista_verificacion">
        <li>
            &#64;exception nombre-excepción texto: esta etiqueta es equivalente a &#64;throws.
        </li>
        <li>
            &#64;param nombre-atributo texto: esta etiqueta es aplicable a parámetros de constructores y
            métodos. Describe los parámetros del constructor o método. Nombre-atributo es idéntico al
            nombre del parámetro. Cada etiqueta &#64;param irá seguida del nombre del parámetro y después de
            una descripción de este. Por ejemplo:
        </li>
    </ul>
    <div>
        <div class="highlighted-code language-java">
            <div>
                <pre>&#64;param cantidad Cantidad que se desea ingresar (en euros)</pre>
            </div>
        </div>
    </div>
    <ul class="lista_verificacion">
        <li>
            &#64;return texto: esta etiqueta se puede omitir en los métodos que devuelven void. Deberá
            aparecer en todos los métodos que devuelvan algo distinto de void, haciendo explícito qué
            tipo o clase de valor devuelve y sus posibles rangos de valores. Veamos un ejemplo:
        </li>
    </ul>
    <div class="highlighted-code language-java">
        <div>
         <pre>/**
* Chequea si un vector no contiene elementos.
* &#64;return <code>verdaderosi y solo si este vector no contiene componentes, esto es, su tamaño es cero;
* falso en cualquier otro caso.
*/
public boolean VectorVacio() &#123;
   return elementCount == 0;
&#125;</pre>
        </div>
    </div>
    <ul class="lista_verificacion">
        <li>
            &#64;see referencia: se aplica a clases, interfaces, constructores, métodos, atributos y
            paquetes. Añade enlaces de referencia a otras partes de la documentación. Podremos añadir a
            la etiqueta: cadenas de caracteres, enlaces
            <abbr title="HiperText Markup Language">
                HTML
            </abbr>
            a páginas y a
            otras zonas del código. Por ejemplo:
        </li>
    </ul>
    <div class="highlighted-code language-java">
        <div>
         <pre>* &#64;see "Diseño de patrones: La reusabilidad de los elementos de la programación orientada a objetos"
* &#64;see <a href="http://www.w3.org/WAI/">Web Accessibility Initiative</a>
* &#64;see String#equals(Object) equals</pre>
        </div>
    </div>
    <ul class="lista_verificacion">
        <li>
            &#64;throws nombre-excepción texto
            <strong>
                :
            </strong>
            en nombre-excepción tendremos que indicar
            el nombre completo de ésta. Podremos añadir una etiqueta por cada excepción que se lance
            explícitamente con una cláusula throws, pero siguiendo el orden alfabético. Esta etiqueta es
            aplicable a constructores y métodos, describiendo las posibles excepciones del
            constructor/método.
        </li>
    </ul>
</div><h1 class="title">
    7.3.- Orden de las etiquetas
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-CC0" style="width: 180px;">
    </div>
    <p align="justify">
        <br>
        ¿Es importante el orden a la hora de poner las etiquetas en los comentarios
        de documentación, o por el contrario es indiferente?
        <br/></p>
    <p align="justify">
        Las etiquetas
        <strong>
            deben disponerse en un orden determinado
        </strong>
        , ese
        orden es el siguiente:
    </p>
    <table class="tabla">
        <caption>
            Orden de etiquetas de comentarios de documentación.
        </caption>
        <thead>
        <tr>
            <th scope="col">
                Etiqueta.
            </th>
            <th scope="col">
                Descripción.
            </th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th scope="row">
                &#64;author
            </th>
            <td>
                En clases e interfaces. Se pueden poner varios. Es mejor ponerlas en orden
                cronológico.
            </td>
        </tr>
        <tr>
            <th scope="row">
                &#64;version
            </th>
            <td>
                En clases e interfaces.
            </td>
        </tr>
        <tr>
            <th scope="row">
                &#64;param
            </th>
            <td>
                En métodos y constructores. Se colocarán tantos como parámetros tenga el constructor o
                método. Mejor en el mismo orden en el que se encuentren declarados.
            </td>
        </tr>
        <tr>
            <th scope="row">
                &#64;return
            </th>
            <td>
                En métodos.
            </td>
        </tr>
        <tr>
            <th scope="row">
                &#64;exception
            </th>
            <td>
                En constructores y métodos. Mejor en el mismo orden en el que se han declarado, o en
                orden alfabético.
            </td>
        </tr>
        <tr>
            <th scope="row">
                &#64;throws
            </th>
            <td>
                Es equivalente a &#64;exception.
            </td>
        </tr>
        <tr>
            <th scope="row">
                &#64;see
            </th>
            <td>
                Podemos poner varios. Comenzaremos por los más generales y después los más
                específicos.
            </td>
        </tr>
        <tr>
            <th scope="row">
                &#64;deprecated
            </th>
            <td>
                En cualquier parte de la documentación. Marca código que ha pasado a estar obsoleto,
                para el que se recomienda dejar de usarlo y eventualmente, sustituirlo por algún otro
                método, clase,
                <abbr title="etcétera.">
                    etc.
                </abbr>
            </td>
        </tr>
        </tbody>
    </table>
</div><h1 class="title">
    7.4.- Ejemplo práctico
</h1>
<div class="iDevice_content">
    <p>
        Una vez que hemos visto la mayoría de las etiquetas que se pueden colocar en la documentación
        javadoc de una clase Java, vamos a ver un ejemplo práctico de cómo llevar a cabo esta tarea.
    </p>
    <p>
        Aquí tienes una
        <strong>
            guía-resumen
        </strong>
        de todo aquello que debes documentar
        <span>
         :
        </span>
    </p>
    <ul class="lista_verificacion">
        <li style="text-align: justify;">
            <strong>
                documentación de la clase
            </strong>
            . Debes incluir una
            descripción lo más completa y detallada posible de la clase, explicando todo aquello que
            consideres que pueda ser de interés para otros programadores que vayan a utilizarla. Ten en
            cuenta que no tienen por qué conocer cómo está implementada por dentro, sino únicamente cómo
            utilizarla (cómo usar sus miembros que actúan como interfaz con el código externo: métodos y
            atributos públicos). Esta descripción se puede subdividir en:
            <br>
            <ul>
                <li style="text-align: justify;">
                    <strong>
                        descripción corta
                    </strong>
                    o resumen de la
                    clase. Consiste en todo el texto que incluyas hasta el primer punto (".") que
                    contenga el texto. Es el texto que aparecerá en la tabla resumen de clases del
                    paquete en el que se encuentre la clase;
                </li>
                <li style="text-align: justify;">
                    <strong>
                        descripción larga
                    </strong>
                    de la clase. Todo el
                    texto que haya después del primer punto. Ambas descripciones aparecerán en la
                    descripción general de la clase;
                </li>
            </ul>
            <br/></li>
        <li style="text-align: justify;">
            <strong>
                documentación de atributos públicos y
                protegidos
            </strong>
            (los miembros protegidos los verás en la próxima unidad) indicando para
            cada uno de ellos una pequeña descripción;
            <ul>
                <li style="text-align: justify;">
                    si se trata de un
                    <strong>
                        atributo constante
                    </strong>
                    ,
                    incluye su valor usando la etiqueta &#64;value.
                    <strong>
                        Debes usar la etiqueta &#64;value y
                        no escribir un literal en el comentario javadoc
                    </strong>
                    . De esta manera si se
                    modificara el valor de la constante en el código, no habría que modificar el
                    comentario.
                </li>
            </ul>
        </li>
        <li style="text-align: justify;">
            <strong>
                documentación de los métodos públicos y
                protegidos
            </strong>
            , incluyendo para cada método:
            <ul style="list-style-type: disc;">
                <li style="text-align: justify;">
                    <strong>
                        descripción del método
                    </strong>
                    :
                    <ul style="list-style-type: disc;">
                        <li style="text-align: justify;">
                            <strong>
                                descripción corta
                            </strong>
                            o resumen
                            del método. Consiste en todo el texto que incluyas hasta el primer punto. Es
                            el texto que aparecerá en la tabla resumen de métodos;
                        </li>
                        <li style="text-align: justify;">
                            <strong>
                                descripción larga
                            </strong>
                            del método.
                            Todo el texto que haya después del primer punto. Ambas descripciones
                            aparecerán en la descripción detallada del método;
                        </li>
                    </ul>
                </li>
                <li style="text-align: justify;">
                    <strong>
                        descripción del valor devuelto
                    </strong>
                    (etiqueta &#64;return), si es que devuelve algo. Esta información aparecerá en la
                    descripción detallada del método;
                </li>
                <li style="text-align: justify;">
                    <strong>
                        descripción de cada uno de los
                        parámetros
                    </strong>
                    (etiqueta &#64;param);
                </li>
                <li style="text-align: justify;">
                    <strong>
                        descripción de las posibles
                        excepciones
                    </strong>
                    que puede lanzar (etiqueta &#64;throws);
                </li>
            </ul>
        </li>
    </ul>
    <p style="text-align: justify;">
        Es más que recomendable que una vez que hayas terminado de redactar
        todos tus comentarios javadoc generes la documentación para observar en los
        <abbr title="Hyper Text Markup Language">
            HTML
        </abbr>
        obtenidos si están todos tus
        comentarios javadoc y los textos son correctos, apropiados y completos como para poder ser
        utilizados como
        <strong>
            manual de referencia de la biblioteca de clases sobre los elementos que
            puedes encontrar en un juego de tablero
            <span lang="ingles">
         </span>
        </strong>
        .
    </p>
</div><h1 class="title">
    8.- Creación y utilización de objetos
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        Es el momento de crear instancias de esas clases (es decir, objetos) para probar si
        están
        correctamente implementadas. La idea de
        <strong>
            Juan
        </strong>
        es pasar las clases a
        <strong>
            María
        </strong>
        junto con cierta documentación sobre su interfaz para que ella no
        tenga que examinar los detalles de implementación de las clases. De esta manera ella
        escribirá código en el que creará objetos a partir de las clases de
        <strong>
            Juan
        </strong>
        y a continuación comenzará a utilizar sus miembros públicos. Si
        todo ha ido bien,
        <strong>
            María
        </strong>
        habrá hecho uso de las clases de
        <strong>
            Juan
        </strong>
        sin tener que haber participado directamente en su desarrollo. Si
        se producen problemas de ejecución (de compilación no deberían producirse porque ya los
        habría resuelto
        <strong>
            Juan
        </strong>
        ),
        <strong>
            María
        </strong>
        podrá informar de cuáles
        han sido esos errores para que
        <strong>
            Juan
        </strong>
        pueda intentar corregirlos, ya que
        él es quien sabrá en qué parte del código habrá que tocar.
    </p>
</div><h1 class="title">
    8.1.- Declaración de un objeto
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        Como ya has visto en unidades anteriores, la declaración de un objeto se realiza exactamente
        igual que la declaración de una variable de cualquier tipo:
    </p>
    <div class="highlighted-code language-java">
        <pre><tipo> nombreVariable;
</pre>
    </div>
    <p>
        En este caso el tipo será alguna clase que ya hayas implementado (Vehiculo,
        <code>
            Persona
        </code>
        ,
        Rectangulo,
        <code>
            Circulo
        </code>
        , Reloj,
        <abbr title="etcétera">
            etc.
        </abbr>
        ) o bien alguna de
        las proporcionadas por la
        <abbr title="Application Programming Interface">
            API
        </abbr>
        <span lang="en">
         Java
        </span>
        (String,
        <code>
            StringBuilder
        </code>
        , LocalDate,
        <abbr title="etcétera">
            etc.
        </abbr>
        ) o por alguna otra biblioteca escrita por terceros.
    </p>
    <p>
        Por ejemplo, podríamos declarar algunas variables que apuntarían a objetos de diferente tipo
        (clases):
    </p>
    <div class="highlighted-code language-java">
        <pre>Vehiculo v1, v2, v3;
Persona p1, p2, p3;
Reloj r1, r2;
StringBuilder sb1, sb2
LocalDate f1, f2;
</pre>
    </div>
    <div class="exe-figure exe-image float-left license-pd" style="width: 200px;">
    </div>
    <p>
        Esas variables (v1,
        <code>
            v2
        </code>
        , v3,
        <code>
            p1
        </code>
        ,&nbsp;p2,
        <code>
            p3
        </code>
        , r1,
        <code>
            r2
        </code>
        , sb1,
        <code>
            sb2
        </code>
        , f1,
        <code>
            f2
        </code>
        ) en realidad son referencias
        (también conocidas como punteros o direcciones de memoria) que apuntan (hacen "referencia") a un
        objeto (una zona de memoria) de la clase indicada en la declaración.
    </p>
    <p>
        Como ya estudiaste en la unidad dedicada a los objetos, una variable de tipo referencia (objeto)
        recién declarada no apunta a nada. Se dice que la referencia está vacía o que es una referencia
        nula (la variable no contiene ninguna dirección a ninguna zona de memoria). Es decir, la
        variable existe y está preparada para guardar una dirección de memoria (que será la zona donde
        se encuentre el objeto al que hará referencia), pero el objeto aún no existe (no ha sido creado
        o instanciado). Por tanto se dice que apunta a un objeto nulo o inexistente.
    </p>
    <p>
        Para que esa variable (referencia) apunte realmente a un objeto (contenga una referencia o
        dirección de memoria que apunte a una zona de memoria en la que se ha reservado espacio para un
        objeto) es necesario crear o instanciar el objeto. En
        <span lang="en">
         Java
        </span>
        se utiliza
        para ello el operador new.
    </p>
</div><h1 class="title">
    8.2.- Creación de un objeto
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        Para poder crear un objeto (instancia de una clase) es necesario utilizar el operador new,&nbsp;
        con la siguiente sintaxis:
    </p>
    <div class="highlighted-code language-java">
        <pre>nombreObjeto = new <ConstructorClase> ([listaParametros]);
</pre>
    </div>
    <p>
        El constructor de una clase (&lt;ConstructorClase&gt;) es un método especial que tiene toda
        clase
        y
        <strong>
            cuyo nombre coincide con el de la clase
        </strong>
        . Es el encargado de inicializar el
        objeto, llevando a cabo comprobaciones y asignando valores iniciales a los atributos de objeto
        si fuera necesario. Dado que el constructor es un método más de la clase, podrá tener también
        una lista de parámetros como tienen todos los métodos (ya lo hemos visto en el apartado sobre
        constructores).
    </p>
    <p>
        De la tarea de reservar memoria para la estructura del objeto (los
        <span lang="en">
         bytes
        </span>
        ocupados por sus atributos más alguna otra información de carácter interno para el entorno de
        ejecución) se encarga el propio entorno de ejecución de
        <span lang="en">
         Java al usar el operador
        </span>
        new. Es decir, que por el hecho de invocar a
        un método constructor, el entorno sabrá que tiene que realizar una serie de tareas (solicitud de
        una zona de memoria disponible, reserva de memoria para los atributos, obtención de una
        referencia a la dirección de memoria de esa zona,
        <abbr title="etcétera.">
            etc.
        </abbr>
        ) y se
        pondrá inmediatamente a desempeñarlas.
    </p>
    <p>
        Algunos ejemplos de instanciación o creación de objetos podrían ser:
    </p>
    <div class="highlighted-code language-java">
        <pre>v1 = new Vehiculo ("2827KPY", LocalDate.of(2018, 12, 12), 60.0, 5.0);
rectangulo1= new Rectangulo (0.0, 0.0, 5.0, 5.0, "r1", "black");
rectangulo2= new Rectangulo (rectangulo1);
r1= new Reloj ();
p1= new Persona ("Juan", "Gil", "Torres", "12345678L");
sb1= new StringBuilder ("cadena");
</pre>
    </div>
    <p>
        Se puede declarar a la vez una variable referencia e invocar al constructor en la misma línea
        para así llevar a cabo el proceso de declaración y asignación inicial simultáneamente, de manera
        similar a como se hace con cualquier variable en
        <span lang="en">
         Java
        </span>
        . Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <pre>Rectangulo rec1= new Rectangulo (0.0, 0.0, 5.0, 5.0, "r1", "black");
Rectangulo rec2= new Rectangulo (rec1);
</pre>
    </div>
    <p>
        También, como ya hemos visto, podemos obtener nuevas instancias de objetos con:
    </p>
    <ul class="lista_verificacion">
        <li>
            métodos que generen nuevos objetos como resultado de aplicar una operación;
        </li>
        <li>
            métodos "pseudoconstructores", de los que ya hemos hablado.
        </li>
    </ul>
    <p>
        Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <pre>LocalDate f1= LocalDate.of (1944, 6 ,6);  // Genera un nuevo LocalDate con la fecha 6 de junio de 1944
LocalDate f2= LocalDate.now();  // Genera un nuevo LocalDate con la fecha actual del sistema
LocalDate f3= f1.plusDays (3);  // Obtiene un nuevo objeto LocalDate a partir de f1 (f1 + tres días)
Rectangulo recAleatorio= Rectangulo.random ("recRandom", "red");  // Genera un objeto Rectangulo con ubicación aleatoria
Vehiculo v1 = new Vehiculo ("2827KPY", LocalDate.of(2018, 12, 12), 60.0, 5.0);
Vehiculo v2= Vehiculo.clonar (v1);  // Genera un nuevo vehículo "clon" exacto del objeto v1
Rectangulo[] arrayRecMuestra= Rectangulo.buildSampleRectangulos();
</pre>
    </div>
    <p>
        Si te fijas, en alguno de estos casos ha llegado a crearse no sólo una instancia sino todo un
        <span lang="en">
         array
        </span>
        de instancias de rectángulos de muestra.
    </p>
</div><h1 class="title">
    8.3.- Referencias a un objeto
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-left license-pd" style="width: 200px;">
    </div>
    <p>
        Como ya hemos indicado en anteriores ocasiones, lo que contiene una variable de tipo referencia
        (variable que no es de tipo primitivo) es una referencia (algunos lo llaman puntero) a una zona
        de memoria donde se encuentran alojados los atributos de un objeto instancia de una clase.
    </p>
    <p>
        Eso significa que en la variable de tipo "referencia" u "objeto" no está almacenado el objeto en
        sí (la sucesión de todos los
        <span lang="en">
         bytes
        </span>
        que representan la información que
        contienen los atributos), sino un número (que nosotros llamamos referencia, dirección de memoria
        o puntero) que indica dónde están todos esos
        <span lang="en">
         bytes
        </span>
        con los datos de los
        atributos. Una analogía podría ser la de que la variable referencia es un casillero donde se
        guarda la llave de una habitación. La habitación con todo su contenido sería el objeto con sus
        atributos dentro y el casillero sería la variable referencia que contiene la dirección de
        memoria o referencia (llave de la habitación) a donde está el objeto (habitación).
    </p>
    <p>
        Por tanto, cuando se realiza una asignación de un objeto de tipo referencia a otro objeto de
        tipo
        referencia, lo único que estamos haciendo es copiar y asignar referencias (direcciones de
        memoria) pero no haciendo copias de los objetos.
    </p>
    <p>
        Por ejemplo, cuando ejecutábamos la sentencia
    </p>
    <div class="highlighted-code language-java">
        <pre>Persona p1= new Persona ("Juan", "Gil", "Torres", "12345678L");
</pre>
    </div>
    <p>
        Podíamos considerar que se llevaban a cabo tres pasos:
    </p>
    <ol class="auto-numbered" style="list-style-type: decimal;">
        <li>
            se declaraba la variable p1 de tipo referencia a objetos instancia de la clase Persona;
        </li>
        <li>
            se instanciaba un objeto de la clase&nbsp;Persona&nbsp;con las características "Juan",
            "Gil", "Torres", "12345678L" (invocación al constructor a través del operador new);
        </li>
        <li>
            se asignaba a la variable&nbsp;p1 la referencia que devuelve el operador&nbsp;new tras
            ejecutar el código del constructor y reservarse una zona de memoria para almacenar los
            atributos de un nuevo objeto instancia de la clase Persona.
        </li>
    </ol>
    <p>
        Es decir, que hemos hecho un&nbsp;new y por tanto tenemos un nuevo objeto Persona. Y como además
        hemos hecho una asignación a p1, podemos decir que&nbsp;p1 "apunta" a ese objeto recién creado.
        Eso es más correcto que decir que&nbsp;p1 "contiene" al objeto.
    </p>
    <p>

    </p>
    <p>
        Si a continuación hacemos:
    </p>
    <div class="highlighted-code language-java">
        <pre>Persona p2= p1;
</pre>
    </div>
    <p>
        <strong>
            No estaremos creando un nuevo objeto Persona
        </strong>
        , sino que estaremos asignando a&nbsp;p2
        la misma referencia que contiene p1. De este modo, aunque&nbsp;p1 y
        <code>
            p2
        </code>
        son dos
        variables distintas (podemos imaginarlas como dos casilleros distintos) están apuntando al mismo
        objeto (podríamos decir que ambos contienen una llave para una misma habitación). Eso significa
        que cualquier acción que se lleve a cabo sobre el objeto apuntado por p1 también se estará
        llevando a cabo sobre el objeto apuntado por p2, pues no son más que dos referencias al mismo
        objeto. No se trata de objetos diferentes.

    </p>
    <p>
        Si queremos tener un segundo objeto de tipo Persona, tendríamos que hacer un segundo new (o bien
        una invocación a algún método que devuelva un nuevo objeto instancia de la clase Persona como
        por ejemplo un "pseudoconstructor") y asignarlo a alguna variable de tipo referencia a la clase
        Persona. Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <pre>Persona p3= new Persona ("Tania", "Soto", "Leal", "11111111H");
</pre>
    </div>
    <p>
        En este caso la variable&nbsp;p3 apuntaría a un nuevo objeto de tipo&nbsp;Persona diferente al
        que apuntan&nbsp;p1 y
        <code>
            p2
        </code>
        .
    </p>
    <p>

    </p>
    <p>
        ¿Qué sucede si en un momento dado&nbsp;p3 deja de apuntar a su objeto original y se le asigna por
        ejemplo el valor de p2?
    </p>
    <div class="highlighted-code language-java">
        <pre>p3= p2;
</pre>
    </div>
    <div class="elemento_centrado">
        <p>

        </p>
    </div>
    <p>
        No habría problema,&nbsp;p3 cambiará de valor y a partir de ese momento las variables
        p1,
        <code>
            p2
        </code>
        y&nbsp;p3 apuntarían al mismo objeto. Por otro lado, el objeto al que
        apuntaba originalmente&nbsp;p3 se habrá quedado "perdido", no existe ninguna variable referencia
        que apunte a él, y por tanto no hay manera de "alcanzarlo". El recolector de basura de
        <span lang="en">
         Java (garbage collector)
        </span>
        acabará borrándolo de la memoria, pues se
        trata de un elemento irrecuperable desde el programa y por tanto inútil.
    </p>
</div><h1 class="title">
    8.4.- Manipulación de un objeto: utilización de métodos y
    atributos.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Una vez que un objeto ha sido declarado y creado (clase instanciada) ya sí se puede decir que el
        objeto existe en el entorno de ejecución, y por tanto que puede ser manipulado como un objeto
        más en el programa, haciéndose uso de sus atributos y sus métodos públicos.
    </p>
    <p>
        Para acceder a un miembro de un objeto se utiliza el operador
        <strong>
            punto
        </strong>
        (&lt;abbr
        title="Punto."&gt;.&lt;/abbr&gt;) del siguiente modo:
    </p>
    <div class="highlighted-code language-java">
        <pre><nombreObjeto>.<nombreMiembro>
</pre>
    </div>
    <p>
        Donde &lt;nombreMiembro&gt; será el nombre de algún miembro del objeto (atributo o método) al
        cual se tenga acceso.
    </p>
    <p>
        Por ejemplo, en el caso de los objetos de tipo Circulo, podríamos acceder a sus miembros de la
        siguiente manera:
    </p>
    <div class="highlighted-code language-java">
        <pre>Circulo c1, c2, c3;
System.out.printf ("Cantidad de círculos creados hasta el momento: %d.\n", Circulo.numeroCirculos);
c1= new Circulo (0.0, 0.0, 0.25, "c1", "black");
System.out.printf ("Propiedades del círculo c1: %s.\n", c1);
System.out.printf ("Superficie del círculo c1: %.2f.\n", c1.calculaSuperficie());
System.out.printf ("Longitud de la cirunferencia que rodea al círculo c1: %.2f.\n", c1.calculaArea());
System.out.printf ("Cantidad de círculos creados hasta el momento: %d.\n", Circulo.numeroCirculos);
c2= new Circulo();
c2.setX(0.50);
c2.setY(0.25);
System.out.printf ("El centro del círculo c2 está en (%.2f,%.2f).\n", c2.getX(), c2.getY());
System.out.printf ("El nombre y el color del círculo c2 son: \"%s\" y \"%s\".\n", c2.getNombre(), c2.getColor());
Ssytem.out.printf ("Cantidad de círculos creados hasta el momento: %d.\n", Circulo.numeroCirculos);
</pre>
    </div>
    <p>
        Es decir, colocando el operador
        <strong>
            punto
        </strong>
        (.) a continuación del nombre del objeto y
        seguido del nombre del miembro público al que se desea acceder. Obviamente, si se trata de un
        miembro estático (atributo de clase o método de clase como por ejemplo numeroCirculos) entonces
        habrá que escribir el nombre de la clase (Circulo.numeroCirculos) y no del objeto (&lt;span
        style="text-decoration: line-through;"&gt;c1&lt;/span&gt;.numeroCirculos).
    </p>
</div><h1 class="title">
    8.5.- Recogiendo las excepciones lanzadas por un método
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        Cada vez que utilicemos un método de una clase (incluido el constructor) debemos revisar si
        existe la posibilidad de que puedan lanzarse excepciones desde ese método en caso de que se
        produzca alguna situación anómala.
    </p>
    <p>
        Si estamos ante ese caso, habrá que encerrar la llamada a ese método en un bloque&nbsp;try -
        catch (o
        <code>
            try - catch - finally
        </code>
        ).
    </p>
    <p>
        Veamos un ejemplo en el que se intentan crear y manipular algunos objetos instancias de la clase
        Vehiculo:
    </p>
    <div class="highlighted-code language-java">
        <pre>Vehiculo v1, v2, v3;
try &#123;
  v1= new Vehiculo ("4650CKE", LocalDate.now().plusDays(2), 60.0, 5.0); // Fallará por la fecha
  System.out.printf ("Vehículo v1: %s\n", v1);
&#125; catch (IllegalArgumentException ex) &#123;
  System.out.printf ("Error: %s.\n", ex.getMessage());  // Fallo por fecha inválida (fecha futura)
&#125;
try &#123;
  v2= new Vehiculo ("7829KPY", LocalDate.of (2018, 10, 10), 60.0, 5.0);
  v2.arrancar();  // Fallará al intentar arrancar sin combustible
  System.out.printf ("Vehículo v1: %s\n", v1);
&#125; catch (IllegalArgumentException ex) &#123;
  System.out.printf ("Error: %s.\n", ex.getMessage());
&#125; catch (IllegalStateException ex) &#123;
  System.out.printf ("Error: %s.\n", ex.getMessage());  // Fallo por falta de combustible
&#125;
try &#123;
  v3= new Vehiculo ("1221CGW", LocalDate.of (2003, 1, 1), 60.0, 5.0);
  v3.repostar(10.0);
  System.out.printf ("Vehículo v1: %s\n", v1);  //No se producirán fallos
&#125; catch (IllegalArgumentException ex) &#123;
  System.out.printf ("Error: %s.\n", ex.getMessage());
&#125; catch (IllegalStateException ex) &#123;
  System.out.printf ("Error: %s.\n", ex.getMessage());
&#125;
try &#123;
  v4= new Vehiculo ("2128JZP", LocalDate.of (2017, 1, 6), 60.0, 5.0);
  v4.repostar(30.0);
  v4.recorrerTrayecto (100.0);
  v4.parar();
  System.out.printf ("Vehículo v1: %s\n", v1);  // No se producirán fallos
&#125; catch (IllegalArgumentException ex) &#123;
  System.out.printf ("Error: %s.\n", ex.getMessage());
&#125; catch (IllegalStateException ex) &#123;
  System.out.printf ("Error: %s.\n", ex.getMessage());
&#125;
</pre>
    </div>
    <p>
        En general, cada vez que utilices algún mecanismo del vehículo que pueda dar lugar a alguna
        situación "delicada", tendrás que proteger esa sección de código con un bloque&nbsp;try - catch
        para asegurarte de poder tomar el control ante el fallo y decidir qué hacer a partir de ese
        momento. Si tu programa no toma el control (mediante un catch), esa excepción será enviada a
        quien llamó a tu programa (la máquina virtual de
        <span lang="en">
         Java
        </span>
        ) y el programa
        abortará su ejecución interrumpiéndose bruscamente. Eso es una circunstancia nada deseable y que
        debemos evitar por todos los medios.
        <strong>
            Un programa que interrumpe bruscamente su ejecución
            ante un fallo es un programa inestable en el que no podemos confiar
        </strong>
        .
    </p>
</div><h1 class="title">
    Anexo I.- Ejercicios de implementación de clases
</h1>
<div class="iDevice_content">
    <p>
        Una vez que
        <strong>
            María
        </strong>
        y
        <strong>
            Juan
        </strong>
        han comenzado a trabajar en
        serio con la
        <strong>
            Programación Orientada
        </strong>
        <strong>
            a Objetos
        </strong>
        , están
        empezando a desarrollar clases para algunos de los nuevos proyectos en los que su
        empresa se encuentra embarcada. Estas clases representarán todo tipo de elementos que
        puedan resultar de interés para sus aplicaciones.
    </p>
    <div class="exe-figure exe-image position-center license-pd" style="width: 350px;">
    </div>
    <p>
        A continuación se presentan algunos casos prácticos de implementación de clases para que
        puedas seguir trabajando todo lo que has aprendido durante la unidad.
    </p>
</div><h1 class="title">
    I.1.- Clase Bombilla
</h1>
<div class="iDevice_content">
</div><h1 class="title">
    I.2.- Clase Ticket
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 120px;">
    </div>
    <p>
        Nuestro equipo de desarrollo ha recibido instrucciones para implementar una clase Ticket
        cuyos objetos representen un ticket de entrada a un servicio. Se han establecido los
        siguientes requerimientos:
    </p>
    <ul class="lista_verificacion">
        <li>
            todo
            <span lang="en">
            ticket
           </span>
            debe incluir un identificador que tendrá el
            siguiente formato: "NNNN-XXXXXXXX" donde "NNNN" representa las cuatro cifras del año
            en el que se ha generado el
            <span lang="en">
            ticket
           </span>
            y "XXXXXXXX" un número de
            ocho cifras que empezará en "00000001" para cada año;
        </li>
        <li>
            cada vez que se genere un nuevo
            <span lang="en">
            ticket
           </span>
            ese código avanza en
            un número y cada vez que se cambie de año habrá que comenzar de nuevo por
            "00000001". Esto significa que el primer
            <span lang="en">
            ticket
           </span>
            que se genere
            en el año 2021 tendrá el identificador "2021-00000001", el segundo "2021-00000002" y
            así sucesivamente;
        </li>
        <li>
            cuando el último
            <span lang="en">
            ticket
           </span>
            generado tenga el número de secuencia
            "99999999", ya no se podrán generar más
            <span lang="en">
            tickets
           </span>
            para ese año;
        </li>
        <li>
            todo
            <span lang="en">
            ticket
           </span>
            tendrá asociada una fecha (un día, mes y año)
            durante el cual podrá ser utilizado. Fuera de esa fecha no podrá usarse;
        </li>
        <li>
            los
            <span lang="en">
            tickets
           </span>
            sólo pueden usarse una vez. Una vez usados quedan
            marcados con la hora en la que han sido utilizados y no podrán volver a usarse.
        </li>
    </ul>
    <p>
    </p>
</div><h1 class="title">
    I.3.- Clase Dado
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        Hemos recibido el encargo de implementar una clase que represente a los
        <strong>
            dados de
            un juego de mesa
        </strong>
        . Los posibles dados para estos juegos son todos aquellos
        poliedros que tengan todas las caras iguales. Matemáticamente existen cinco tipos
        diferentes (con cuatro, seis, ocho, doce o veinte caras). Son conocidos como los sólidos
        platónicos.
    </p>
    <p>
        Para
        <strong>
            cada dado
        </strong>
        queremos registrar la siguiente información:
    </p>
    <ul class="lista_verificacion">
        <li>
            el
            <strong>
                número de caras
            </strong>
            que tiene;
        </li>
        <li>
            la
            <strong>
                cantidad de lanzamientos
            </strong>
            que se han realizado con él.
        </li>
    </ul>
    <p>
    </p>
</div><h1 class="title">
    I.4.- Clase Bombo
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 100px;">
    </div>
    <p>
        Nuestra empresa ha entrado en contacto con un posible cliente dedicado a los juegos de
        azar tradicionales que quiere lanzar una nueva línea de productos digitales. Uno de los
        primeros productos será un
        <strong>
            bingo digital
        </strong>
        .
    </p>
    <p>
        El equipo de desarrollo ha recibido el encargo de representar un
        <strong>
            bombo de un
            bingo
        </strong>
        . Para ello habrá que implementar una clase Bombo cuyos objetos contendrán
        una serie de bolas que podrán ir extrayéndose una a una con la particularidad de que una
        vez que se extraiga una bola ya no podrá volver a salir.
    </p>
    <p>
        El
        <strong>
            número de bolas
        </strong>
        con el que podemos configurar los bombos estará entre
        <strong>
            9 y 90
        </strong>
        .
    </p>
</div><h1 class="title">
    Anexo II.- Implementación de la clase Vehiculo
</h1>
<div class="iDevice_content">
    <p>
        A continuación te ofrecemos una tarea original propuesta hace algunos años para ver qué tal te
        desenvuelves a la hora de resolverla. Seguro que hay muchos elementos que te suenan a todo lo
        que hemos estado haciendo durante la unidad. ¡Suerte!
    </p>
    <p>
        <strong>
            NOTA
        </strong>
        : debes tener en cuenta que no todos los métodos o los atributos que aquí se
        propongan para la implementación de una clase&nbsp;Vehiculo tienen por qué coincidir exactamente
        con los ejemplos que se han ido planteando a lo largo del contenido la unidad. En este ejercicio
        tendrás que atenerte a lo que se indique en las especificaciones concretas del enunciado de esta
        tarea.
    </p>
</div><h1 class="title">
    II.1.- Descripción de la tarea
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 350px;">
    </div>
    <ol>
        <li>
            Usando el
            <abbr title="Integrated Development Environment">
                IDE
            </abbr>
            <span lang="en">
          NetBeans
         </span>
            , crea un proyecto con dos clases: la clase&nbsp;Vehiculo y la
            clase de pruebas (llamada Principal) que se proporciona con esta tarea. En la clase&nbsp;Vehiculo
            se definirán los atributos necesarios para representar las siguientes características de un
            vehículo:
            <ul class="lista_verificacion">
                <li>
                    estos dos primeros atributos tendrán un valor que se definirá al crearse el objeto y
                    ya nunca cambiarán su valor durante toda la vida del objeto:
                    <ul>
                        <li>
                            <strong>
                                capacidad del depósito
                            </strong>
                            de combustible (en litros);
                        </li>
                        <li>
                            <strong>
                                consumo medio
                            </strong>
                            del vehículo (en
                            <abbr title="litros a los 100 kilómetros">
                                litros/100 km
                            </abbr>
                            );
                        </li>
                    </ul>
                </li>
                <li>
                    estos otros atributos sí irán cambiando a lo largo de la vida del objeto y de alguna
                    manera representarán el estado del objeto en cada momento:
                    <ul>
                        <li>
                            si el vehículo tiene el
                            <strong>
                                motor encendido o apagado;
                            </strong>
                        </li>
                        <li>
                            el
                            <strong>
                                nivel actual del depósito
                            </strong>
                            de combustible (en litros);
                        </li>
                        <li>
                            la
                            <strong>
                                cantidad de kilómetros recorridos
                            </strong>
                            desde que se ha
                            arrancado por última vez (en kilómetros);
                        </li>
                        <li>
                            el
                            <strong>
                                consumo realizado
                            </strong>
                            desde que se ha arrancado por última
                            vez (en litros);
                        </li>
                        <li>
                            la
                            <strong>
                                cantidad total de kilómetros recorridos
                            </strong>
                            desde que se
                            fabricó el vehículo (en kilómetros);
                        </li>
                        <li>
                            el
                            <strong>
                                consumo total realizado
                            </strong>
                            desde que se ha arrancado por
                            última vez (en litros).
                        </li>
                    </ul>
                </li>
                <li>
                    por último, también habrá otros atributos que pertenecerán a la clase, más que a un
                    objeto en particular, y tendrán sentido siempre, independientemente de que existan o
                    no instancias de la clase (atributos estáticos):
                    <ul>
                        <li>
                            <strong>
                                distancia recorrida total por todos los vehículos
                            </strong>
                            que se
                            hayan ido creando hasta el momento (kilómetros);
                        </li>
                        <li>
                            <strong>
                                combustible total consumido por todos los vehículos
                            </strong>
                            que se
                            hayan ido creando hasta el momento (litros);
                        </li>
                        <li>
                            <strong>
                                número de vehículos con el motor encendido
                            </strong>
                            en el momento
                            actual.
                        </li>
                    </ul>
                </li>
                <li>
                    además de esos atributos variables, la clase también va a contener
                    <strong>
                        constantes
                    </strong>
                    que serán de utilidad a la hora de realizar comprobaciones o asignaciones por
                    defecto:
                    <ul>
                        <li>
                            <strong>
                                mínimo consumo medio
                            </strong>
                            permitido a la hora de crear un nuevo
                            vehículo (
                            <strong>
                                2,0
                                <abbr title="litros a los 100 kilómetros">
                                    litros/100
                                    km
                                </abbr>
                            </strong>
                            );
                        </li>
                        <li>
                            <strong>
                                máximo consumo medio
                            </strong>
                            permitido a la hora de crear un nuevo
                            vehículo (
                            <strong>
                                20,0
                                <strong>
                                    <abbr title="litros a los 100 kilómetros">
                                        litros/100 km
                                    </abbr>
                                </strong>
                                );
                            </strong>
                        </li>
                        <li>
                            <strong>
                                mínima capacidad del depósito
                            </strong>
                            permitida a la hora de crear
                            nuevo vehículo (
                            <strong>
                                10,0 litros
                            </strong>
                            ).
                        </li>
                        <li>
                            <strong>
                                máxima capacidad del depósito
                            </strong>
                            permitida a la hora de crear
                            nuevo vehículo (
                            <strong>
                                120,0 litros
                            </strong>
                            ).
                        </li>
                        <li>
                            <strong>
                                consumo
                            </strong>
                            que se produce
                            <strong>
                                al arrancar un
                                vehículo
                            </strong>
                            (siempre será el mismo:
                            <strong>
                                0,02 litros
                            </strong>
                            ).
                        </li>
                        <li>
                            <strong>
                                valor por omisión para el consumo medio
                            </strong>
                            de un vehículo
                            (
                            <strong>
                                5,0
                                <abbr title="litros a los 100 kilómetros">
                                    litros/100 km
                                </abbr>
                            </strong>
                            ).
                        </li>
                        <li>
                            <strong>
                                valor por omisión para la capacidad del depósito
                            </strong>
                            de un
                            vehículo (
                            <strong>
                                50,0 litros
                            </strong>
                            ).
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            Implementa
            <strong>
                dos métodos constructores
            </strong>
            para la clase Vehiculo:
            <ul class="lista_verificacion">
                <li>
                    uno
                    <strong>
                        sin parámetros
                    </strong>
                    que crearía una instancia de un vehículo con un
                    <strong>
                        depósito de tamaño 50,0 litros
                    </strong>
                    y un
                    <strong>
                        consumo medio de 5,0
                        <span title="litros a los 100 kilómetros">
             <abbr title="litros a los 100 kilómetros">
              litros/100 km
             </abbr>
            </span>
                    </strong>
                    .
                    Esos valores deben aparecer como atributos constantes de de la clase y es
                    obligatorio usarlos en el constructor;
                </li>
                <li>
                    otro que permita crear un objeto de tipo&nbsp;Vehiculo donde la capacidad del
                    depósito y el consumo se le pasarán como parámetros. Ahora bien, si los parámetros
                    no son válidos (no cumplen las condiciones que se piden), entonces se lanzará una
                    excepción de tipo&nbsp;IllegalArgumentException y el objeto no será creado. Las
                    condiciones mínimas exigibles para que un objeto de tipo Vehiculo&nbsp;pueda ser
                    creado es que la capacidad del depósito se encuentre entre los 10 y los 120 litros
                    (ambos inclusive) y el consumo medio esté entre 2,0
                    <span title="litros a los 100 kilómetros">
            litros/100 km
           </span>
                    y 20
                    <abbr title="litros a los 100 kilómetros">
                        litros/100 km
                    </abbr>
                    . Todas estas cifras
                    estarán definidas en las constantes de clase que se han descrito en apartados
                    anteriores y
                    <strong>
                        deben utilizarse esas constantes para las comprobaciones en el
                        constructor, y no valores literales
                    </strong>
                    .
                </li>
            </ul>
        </li>
        <li>
            Añade a la clase&nbsp;Vehiculo los
            <strong>
                métodos consultores
            </strong>
            (
            <strong>
          <span lang="en">
           getters
          </span>
            </strong>
            ) para poder obtener la siguiente información:
            <ul class="lista_verificacion">
                <li>
                    isArrancado(), que indique
                    <strong>
                        si el motor del vehículo está arrancado o
                        no;
                    </strong>
                </li>
                <li>
                    getConsumoMedio(), que devuelva el
                    <strong>
                        consumo medio del vehículo
                    </strong>
                    (en
                    <abbr title="litros a los 100 kilómetros">
                        litros/100 km
                    </abbr>
                    );
                </li>
                <li>
                    getCapacidadDeposito(), que devuelva la
                    <strong>
                        capacidad del depósito de
                        combustible del vehículo
                    </strong>
                    (en litros);
                </li>
                <li>
                    getNivelCombustible(), que devuelva el
                    <strong>
                        nivel actual del depósito de
                        combustible del vehículo
                    </strong>
                    (en litros);
                </li>
                <li>
                    getDistanciaRecorrida(), que devuelva la
                    <strong>
                        distancia recorrida por el&nbsp;vehículo
                        desde que ha sido arrancado por última vez
                    </strong>
                    (en
                    <abbr title="Kilómetros">
                        km
                    </abbr>
                    );
                </li>
                <li>
                    getDistanciaRecorridaTotal(), que devuelva la
                    <strong>
                        distancia total recorrida por
                        el vehículo desde su fabricación
                    </strong>
                    (en
                    <abbr title="Kilómetros">
                        km
                    </abbr>
                    );
                </li>
                <li>
                    getCombustibleConsumido(), que devuelva el
                    <strong>
                        combustible que ha sido consumido
                        por el vehículo desde que ha sido arrancado por última vez
                    </strong>
                    (en litros);
                </li>
                <li>
                    getCombustibleConsumidoTotal(), que devuelva el
                    <strong>
                        combustible total que ha
                        sido consumido por el vehículo desde su fabricación
                    </strong>
                    (en litros).
                </li>
                <li>
                    getDistanciaRecorridaFlota (), que devuelva la
                    <strong>
                        distancia recorrida total por
                        todos los vehículos que se hayan creado hasta el
                        momento
                    </strong>
                    (en
                    <abbr title="Kilómetros">
                        km
                    </abbr>
                    );
                </li>
                <li>
                    getCombustibleConsumidoFlota(),que devuelva el
                    <strong>
                        combustible total que ha sido
                        consumido por todos los vehículos que hayan sido creados hasta el momento
                    </strong>
                    (en litros);
                </li>
                <li>
                    getNumVehiculosArrancadosFlota(), que devuelva el
                    <strong>
                        número de vehículos que
                        haya con el motor encendido
                    </strong>
                    en ese momento.
                </li>
            </ul>
        </li>
        <li>
            Implementa un método repostar que permita
            <strong>
                rellenar el depósito de combustible del
                vehículo
            </strong>
            . Recibirá un parámetro que indicará la cantidad de litros para repostar.
            Este método
            <strong>
                actualizará el nivel&nbsp; de combustible del vehículo en función del
                valor del parámetro que se le pase
            </strong>
            . Ahora bien, podrían darse
            <strong>
                algunos
                casos de error
            </strong>
            que deberían lanzar una excepción:
            <br>
            <ol>
                <li>
                    <strong>
                        si el motor está arrancado
                    </strong>
                    , no se podrá repostar, y se lanzará una
                    excepción &lt;code&gt;IllegalStateException. El mensaje asociado a la excepción
                    debería ser "se intentó repostar con el motor encendido. No se ha repostado.".
                    <div class="elemento_derecha">
                        <div class="elemento_centrado">
                        </div>
                    </div>
                </li>
                <li>
                    si
                    <strong>
                        la cantidad de combustible que se intenta repostar es superior a la que
                        puede admitir el depósito en ese momento
                    </strong>
                    , el depósito se llenará, pero al
                    rebosar hará que se lance una excepción IllegalArgumentException. En este caso, el
                    mensaje asociado a la excepción sería "depósito lleno. Se ha sobrepasado la capaciad
                    del depósito de combustible en xxx litros.", donde xxx sería la cantidad en exceso
                    de combustible que se ha intentado repostar y que no se ha podido (lo que habría
                    rebosado).
                </li>
            </ol>
            <br/></li>
        <li>
            Implementa un método arrancar que hace que
            <strong>
                el estado del motor pase a encendido (o
                arrancado)
            </strong>
            . Arrancar el motor de un vehículo hará que produzca una pequeña cantidad
            de
            <strong>
                consumo
            </strong>
            de combustible. El consumo que se produce al arrancar estará
            definido en una de las constantes de clase que se han descrito anteriormente y habrá que
            utilizar esa constante para modificar el estado del objeto (incrementar el consumo y
            decrementar el nivel del depósito). Ahora bien, pueden producirse algunas situaciones de
            error:
            <ol>
                <li>
                    <strong>
                        el estado del motor pasa a arrancado si aún no lo está
                    </strong>
                    , pero si ya
                    lo está, no se producirá ningún consumo y además se lanzará una excepción de
                    tipo&nbsp;IllegalStateException
                    con el mensaje "Error: El motor ya se encuentra arrancado.";
                </li>
                <li>
                    <strong>
                        si el depósito del vehículo no tiene combustible suficiente para poder
                        arrancar, se producirá una excepción
                    </strong>
                    IllegalStateException y se vaciará
                    completamente lo que quede de combustible. El mensaje de la excepción será en este
                    caso "depósito vacío. Se intentó arrancar sin combustible suficiente.".
                </li>
            </ol>
        </li>
        <li>
            Implementa un método realizarTrayecto, que haga que el vehículo realice un trayecto de una
            determinada cantidad de kilómetros que se pasarán como parámetro. Podrá generarse una
            situación de error, y por tanto el lanzamiento de una excepción, en alguno de los siguientes
            casos:
            <ol>
                <li>
                    excepción&nbsp;IllegalArgumentException si el valor que se pasa como distancia para
                    recorrer es
                    <strong>
                        negativo
                    </strong>
                    . El mensaje de la excepción será en este caso
                    "Error: Se intentó realizar un trayecto negativo.";
                </li>
                <li>
                    excepción&nbsp;IllegalStateException si está el
                    <strong>
                        motor apagado
                    </strong>
                    . El
                    mensaje de la excepción será en este caso "Error: Se intentó realizar un trayecto
                    con el motor apagado. No se ha avanzado.";
                </li>
                <li>
                    excepción&nbsp;IllegalArgumentException si no hay combustible suficiente para
                    recorrer esa distancia. En tal caso se consume todo el depósito, se recorre la
                    distancia que sea posible, y se apaga el motor. El mensaje de la excepción será en
                    este caso "no se ha podido finalizar el trayecto completamente. Depósito vacío. Han
                    faltado por recorrer xxx km.", donde xxx sería la cantidad de kilómetros que no se
                    han podido recorrer debido a la falta de combustible.
                </li>
            </ol>
        </li>
        <li>
            Implementa un método apagar, que
            <strong>
                apaque el motor
            </strong>
            y reinicie a cero los
            indicadores de consumo y distancia recorrida desde el último arranque. Si el motor ya
            estuviera apagado, se debería lanzar una excepción de tipo IllegalStateException con un
            mensaje de error del tipo "el motor ya se encuentra apagado." y no llevar a cabo ninguna
            acción.
        </li>
        <li>
            Implementa un método
            <code style="font-style: italic;">
                toString
            </code>
            <span style="font-style: italic; font-size: 1em;">
          que represente el estado de un vehículo generando un
         </span>
            <code style="font-style: italic;">
                String
            </code>
            <span style="font-style: italic; font-size: 1em;">
          que:
         </span>
            <ol>
                <li>
                    contenga la siguiente
                    <strong style="font-style: italic; font-size: 1em;">
                        información
                        del estado del vehículo
                    </strong>
                    <span style="font-style: italic; font-size: 1em;">
            en ese momento:
           </span>
                    <ol>
                        <li>
                            <strong style="font-size: 1em;">
                                estado del motor
                            </strong>
                            <span style="font-size: 1em;">
              (encendido o apagado);
             </span>
                        </li>
                        <li>
                            <strong style="font-size: 1em;">
                                nivel del depósito
                            </strong>
                            <span style="font-size: 1em;">
              de combustible;
             </span>
                        </li>
                        <li>
                            <strong style="font-size: 1em;">
                                distancia recorrida
                            </strong>
                            <span style="font-size: 1em;">
              desde que se ha arrancado (si es que el motor está arrancado, pues si está apagado será obviamente cero);
             </span>
                        </li>
                        <li>
                            <strong style="font-size: 1em;">
                                consumo realizado
                            </strong>
                            <span style="font-size: 1em;">
              desde que se ha arrancado (si es que&nbsp;el motor está arrancado, pues si está apagado será obviamente cero);
             </span>
                        </li>
                    </ol>
                </li>
                <li>
                    La muestre con el siguiente formato: "
                    <strong style="font-size: 1em;">
                        Motor: XXX -
                        Deposito: YYY - Dist: ZZZ - Consumo: VVV
                    </strong>
                    <span style="font-size: 1em;">
            ", donde XXX podrá ser encendido o apagado; YYY será el nivel del depósito expresado en litros y con dos decimales; ZZZZ será la distancia recorrida expresada en kilómetros y con dos decimales, y VVV el consumo expresado en litros y con dos decimales. Algunos ejemplos de la salida de
           </span>
                    toString
                    <span style="font-size: 1em;">
            podrían ser:
           </span>
                    <ol>
                        <li>
                            motor: apagado&nbsp;&nbsp; - Depósito:&nbsp;&nbsp; 0,00 - Dist:&nbsp;&nbsp;&nbsp;&nbsp;
                            0,00 - Consumo:&nbsp;&nbsp;&nbsp;&nbsp; 0,00
                        </li>
                        <li>
                            motor: arrancado - Depósito:&nbsp;&nbsp; 4,98 - Dist:&nbsp;&nbsp;&nbsp;&nbsp;
                            0,00 - Consumo:&nbsp;&nbsp;&nbsp;&nbsp; 0,02
                        </li>
                        <li>
                            motor: arrancado - Depósito:&nbsp;&nbsp; 4,23 - Dist:&nbsp;&nbsp; 15,00 -
                            Consumo:&nbsp;&nbsp;&nbsp;&nbsp; 0,77
                        </li>
                        <li>
                            motor: apagado&nbsp;&nbsp; - Depósito:&nbsp;&nbsp; 4,23 - Dist:&nbsp;&nbsp;&nbsp;&nbsp;
                            0,00 - Consumo:&nbsp;&nbsp;&nbsp;&nbsp; 0,00
                        </li>
                        <li>
                            motor: arrancado - Depósito:&nbsp;&nbsp; 4,68 - Dist:&nbsp;&nbsp; 10,00 -
                            Consumo:&nbsp; &nbsp;&nbsp; 0,32
                        </li>
                    </ol>
                </li>
            </ol>
        </li>
        <li>
            Documenta apropiadamente el código con
            <strong style="font-size: 1em;">
                comentarios
                javadoc
            </strong>
            <span style="font-size: 1em;">
          para poder generar la documentación apropiadamente:
         </span>
            <ol>
                <li>
                    <strong style="font-style: italic; font-size: 1em;">
                        documentación a nivel de
                        clase
                    </strong>
                    <span style="font-style: italic; font-size: 1em;">
            . Debes incluir un buen comentario para documentar la clase en general;
           </span>
                </li>
                <li>
                    <strong style="font-size: 1em;">
                        documentación a nivel de métodos
                    </strong>
                    <span style="font-size: 1em;">
            , incluyendo, por cada método:
           </span>
                    <ol>
                        <li>
                            <strong style="font-size: 1em;">
                                descripción de los atributos
                                públicos.
                            </strong>
                            <span style="font-size: 1em;">
              Uso de
             </span>
                            &#64;value
                            <span style="font-size: 1em;">
              para incluir el valor de las constantes;
             </span>
                        </li>
                        <li>
                            <strong style="font-size: 1em;">
                                descripción del método
                            </strong>
                            <span style="font-size: 1em;">
              .
             </span>
                            <strong style="font-size: 1em;">
                                Descripción
                                corta
                            </strong>
                            <span style="font-size: 1em;">
              y
             </span>
                            <strong style="font-size: 1em;">
                                descripción larga;
                            </strong>
                            <span style="font-size: 1em;">
              <br>
             <br/></span>
                        </li>
                        <li>
                            <strong style="font-size: 1em;">
                                descripción de los parámetros
                            </strong>
                            <span style="font-size: 1em;">
              (
             </span>
                            &#64;param
                            <span style="font-size: 1em;">
              );
             </span>
                        </li>
                        <li>
                            descripción de las posibles excepciones que puede lanzar (&#64;throws
                            <span style="font-size: 1em;">
              ). En nuestro caso serán
             </span>
                            IllegalArgumentException
                            <span style="font-size: 1em;">
              o
             </span>
                            IllegalStateException
                            <span style="font-size: 1em;">
              . En algunos casos ambas.
             </span>
                        </li>
                    </ol>
                </li>
            </ol>
        </li>
        <li>
            Se proporciona un
            <strong style="font-size: 1em;">
                programa principal
            </strong>
            <span style="font-size: 1em;">
          para probar el funcionamiento de la clase
         </span>
            Vehiculo
            <span style="font-size: 1em;">
          con tres variables objeto
         </span>
            v1
            <span style="font-size: 1em;">
          ,
         </span>
            v2
            <span style="font-size: 1em;">
          y
         </span>
            v3
            <span style="font-size: 1em;">
          de esa clase. El programa está casi completo. Tan solo falta añadir el código necesario para probar el objeto
         </span>
            v3
            <span style="font-size: 1em;">
          sobre el que habrá que realizar las siguientes acciones:
         </span>
            <ol>
                <li>
           <span style="font-size: 1em;">
           </span>
                    Crear el objeto vehículo
                    <code style="font-style: italic;">
                        v3
                    </code>
                    <span style="font-style: italic; font-size: 1em;">
            con el constructor sin parámetros;
           </span>
                </li>
                <li>
                    Repostar 20 litros de combustible en el vehículo v3;
                    <span style="font-size: 1em;">
            <br>
           <br/></span>
                </li>
                <li>
                    Arrancar el vehículo v3;
                    <span style="font-size: 1em;">
            <br>
           <br/></span>
                </li>
                <li>
                    Recorrer un trayecto de 100
                    <abbr title="kilómetros">
                        km
                    </abbr>
                    con el vehículo
                    v3;
                    <span style="font-size: 1em;">
            <br>
           <br/></span>
                </li>
                <li>
                    Dejar el motor del vehíclo&nbsp;v3
                    <span style="font-size: 1em;">
            encendido, es decir, no apagarlo.
           </span>
                </li>
            </ol>
        </li>
        <li>
            <p>
                Fíjate bien en cómo se pueden realizar esas acciones observando cómo se ha hecho
                previamente con&nbsp;v1 y
                <code>
                    v2
                </code>
                , enviando a la pantalla los mensajes
                apropiados y gestionando las excepciones que sean necesarias de una manera apropiada.
                Debes "proteger" esas acciones con bloques try - catch de la misma manera que se ha
                hecho previamente con las operaciones sobre v1 y
                <code>
                    v2
                </code>
                .
            </p>
            <p>
          <span>
           Es
           <strong>
            obligatorio
           </strong>
           que utilices esa clase principal que se te proporciona. De esta manera todos tendréis que amoldaros a las interfaces definidas para la clase
          </span>
                Vehiculo
                <span>
           . Es decir, que vuestra clase
          </span>
                <span>
          </span>
                <span>
           Vehiculo deberá encajar en este programa principal como si fuera una pieza más de un
          </span>
                <strong>
                    puzzle
                </strong>
                <span>
           como ya hemos tenido que hacer en otras ocasiones. La clase principal la puedes descargar de la sección de recursos necesarios. En esta clase se utilizan métodos de la clase
          </span>
                ES
                <span>
           para la lectura de datos por teclado. Por tanto, también deberás incorporarla en tu proyecto.
          </span>
            </p>
        </li>
    </ol>
</div><h1 class="title">
    II.2.- Información de interés
</h1>
<div class="iDevice_content">
    <h4 class="resaltado_inline" style="text-align: center;">
        Recursos necesarios y recomendaciones
    </h4>
    <ul class="lista_verificacion">
        <li>
            Recuerda que
            <strong>
                es obligatorio
                utilizar
            </strong>
            <span>
          <strong>
           la clase principal
          </strong>
          que se te proporciona como programa principal de tu
         </span>
            proyecto
            con su método main():
            Clase Principal
            <span class="exe-link-data file-size">
          (java - 15.18
          <abbr lang="en" title="KiloBytes">
           KB
          </abbr>
          )
         </span>
            .
        </li>
        <li>
            La clase ES para recepción de información por teclado y
            <span>
          escritura en pantalla
         </span>
            :
            Clase ES
            <span class="exe-link-data file-size">
          (java - 17.27
          <abbr lang="en" title="KiloBytes">
           KB
          </abbr>
          )
         </span>
        </li>
        <li>
         <span>
          <span>
           Las excepciones que hay que lanzar desde los métodos de la clase Vehiculo (y capturar en el programa principal) son IllegalStateException y
           <code>
            IllegalArgumentException
           </code>
           .
          </span>
         </span>
        </li>
        <li>
         <span>
          Para que te sea más fácil probar si tu programa funciona correctamente, te proporcionamos un ejemplo de ejecución del programa con diversos
          <strong>
           casos de prueba
          </strong>
          .
          <strong>
           Deberías probar tu programa al menos con todos esos casos
          </strong>
          , más otros que se te puedan ocurrir a ti, pues los profesores vamos a probar esos
          <strong>
           como mínimo
          </strong>
          :
         </span>
            <ul>
                <li>
                    Archivo de texto (.txt) con la salida del programa al probar todos esos casos:
                    Ejecución de casos de prueba
                    <span class="exe-link-data file-size">
            (txt - 6.96
            <abbr lang="en" title="KiloBytes">
             KB
            </abbr>
            )
           </span>
                </li>
            </ul>
        </li>
        <li>
            También te proporcionamos una muestra de cómo podría quedar tu
            <strong>
                documentación
                javadoc
            </strong>
            . Tus descripciones y comentarios no tienen porqué coincidir exactamente con
            estos, pues no es más que un ejemplo, pero puede servirte de guía si no tienes claro cómo
            enfocar tu documentación (está directamente basada en los textos de la descripción de la
            tarea):
            Ejemplo de Javadoc
            <span class="exe-link-data file-size">
          (zip - 64.8
          <abbr lang="en" title="KiloBytes">
           KB
          </abbr>
          )
         </span>
            .

        </li>
    </ul>
</div><h1 class="title">
    II.3.- Propuesta de solución
</h1>
<div class="iDevice_content">
    <p>
        Aquí tienes una propuesta de solución al ejercicio:
        solución clase Vehiculo
        <span class="exe-link-data file-size">
         (zip - 27.3
         <abbr lang="en" title="KiloBytes">
          KB
         </abbr>
         )
        </span>
        .
    </p>
</div><h1 class="title">
    Condiciones y términos de uso de los materiales
</h1>
<div class="iDevice_content">
    <div title="Información acerca de la licencia de los materiales">
        <p align="center" style="margin: 2px 2px;">
            <strong>
                Materiales desarrollados inicialmente por
                el Ministerio de Educación, Cultura y Deporte y actualizados por el profesorado de
                la
                Junta de Andalucía bajo licencia Creative Commons
                <abbr title="Reconocimiento-NoComercial-CompartirIgual">
                    BY-NC-SA.
                </abbr>
            </strong>
        </p>
        <p align="center" style="font-size: 0.8em; margin: 2px 2px;">
            <strong>
            </strong>
        </p>
        <p align="center" style="font-size: 0.8em; margin: 2px 2px;">
          <span>
           Antes de cualquier uso leer detenidamente el siguente
          </span>
            Aviso
            legal
        </p>
    </div>
</div>

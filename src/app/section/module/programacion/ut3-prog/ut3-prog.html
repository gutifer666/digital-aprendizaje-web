<h1 class="title">
    Utilización de objetos.
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">

        </div>

    </div>
    <p>
        <strong>
            Ada
        </strong>
        y
        <strong>
            Juan
        </strong>
        se han reunido para discutir sobre
        distintos proyectos de
        <strong>
            BK Programación
        </strong>
        .
        <strong>
            Ada
        </strong>
        le
        comenta a
        <strong>
            Juan
        </strong>
        que están teniendo algunos problemas con algunos de
        estos proyectos. A menudo surgen modificaciones o mejoras en el
        <span lang="en">
           software
          </span>
        en el ámbito de los contratos de mantenimiento que
        tienen suscritos con los clientes, y realizar las modificaciones en los programas
        está suponiendo en muchos casos modificar el programa casi en su totalidad.
    </p>
    <p>
        A eso se ha de sumar que las tareas de modificación son encargadas a las personas más
        adecuadas en ese momento, según la carga de trabajo que haya, que no tienen por qué
        coincidir con las personas que desarrollaron el programa. Las modificaciones en los
        proyectos se están retrasando, y hay algunas que deben estar listas antes de que
        surja el nuevo cambio de versión.
    </p>
    <p>
        En reuniones anteriores se ha comentado la posibilidad de aumentar el precio del
        contrato de mantenimiento de los clientes. Se ha consultado con el equipo de
        comerciales y a regañadientes han aceptado un aumento que aún está por decidir, pero
        aún así quizás no sea suficiente. La empresa necesita
        <strong>
            mejorar el método de
            trabajo para reducir costes de mantenimiento del software
        </strong>
        y alcanzar la
        rentabilidad deseada.
    </p>
</div><h1 class="title">
    1.- Introducción.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Si nos paramos a observar el mundo que nos rodea, podemos apreciar que
        <strong>
            casi todo está
            formado por objetos
        </strong>
        .
    </p>
    <p>
        Existen coches, edificios, sillas, mesas, semáforos, ascensores e incluso personas o
        animales.
        <strong>
            Todos ellos pueden ser considerados objetos, con una serie de
            características y comportamientos.
        </strong>
        Por ejemplo, existen coches de diferentes
        marcas, colores,
        <abbr title="etcétera">
            etc
        </abbr>
        . y pueden acelerar, frenar, girar,
        <abbr title="etcétera">
            etc
        </abbr>
        ., o las personas tenemos diferente color de pelo, ojos,
        altura y peso y podemos nacer, crecer, comer, dormir,
        <abbr title="Etcétera.">
            etc
        </abbr>
        .
    </p>
    <p>
        <strong>
            Los programas son el resultado de la búsqueda y obtención de una solución para un
            problema del mundo real.
        </strong>
        Pero ¿en qué medida los programas están organizados de
        la misma manera que el problema que tratan de solucionar?
    </p>
    <p>
        La respuesta es que muchas veces los programas se ajustan más a los términos del sistema en
        el que se ejecutarán que a los del propio problema.
    </p>
    <p>
        Si redactamos los programas utilizando los mismos términos de nuestro mundo real, es decir,
        utilizando objetos, y no los términos del sistema o computadora donde se vaya a ejecutar,
        conseguiremos que éstos sean más legibles y, por tanto, más fáciles de desarrollar,
        modificar y mantener, y por tanto, menos costosos.
    </p>
    <p>
        Esto es precisamente lo que pretende la
        <strong>
            Programación Orientada a Objetos (
            <abbr title="Programación Orientada a Objetos.">
                POO
            </abbr>
        </strong>
        <strong>
            )
        </strong>
        ,
        en inglés
        <strong>
            <abbr title="Object Oriented Programming.">
                OOP
            </abbr>
            (
            <span lang="en">
          Object Oriented Programming
         </span>
        </strong>
        <strong>
            )
        </strong>
        <strong>
            ,
        </strong>
        establecer una serie de técnicas que permitan trasladar los problemas del mundo
        real a nuestro sistema informático. Ahora que ya conocemos la sintaxis básica de
        <span lang="en">
         Jav
        </span>
        a, es el momento de comenzar a utilizar las características
        orientadas a objetos de este lenguaje, y estudiar los conceptos fundamentales de este modelo
        de programación.
    </p>
</div><h1 class="title">
    2.- Fundamentos de la Programación Orientada a Objetos.
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        <strong>
            Juan
        </strong>
        cuenta con la ayuda de
        <strong>
            María
        </strong>
        para desarrollar
        la aplicación para la Clínica Veterinaria. Lo normal es pensar en tener una
        aplicación de escritorio para las altas y bajas de clientes y la gestión de
        mascotas, y una parte web para que la clínica pueda estar presente en Internet, e
        incluso, realizar la venta
        <span lang="en">
           on-line
          </span>
        de sus productos.
        <strong>
            María
        </strong>
        tiene bastante experiencia en administración de páginas web,
        pero para estar capacitada en el desarrollo de aplicaciones en
        <span lang="en">
           Java
          </span>
        , necesita adquirir conocimientos adicionales.
    </p>
    <p>
        <strong>
            Juan
        </strong>
        le explica que tienen que utilizar un método de programación
        que les ayude a organizar los programas, a
        <strong>
            trabajar en equipo
        </strong>
        de
        forma que si uno de ellos tiene que dejar una parte para que se encargue el otro,
        que éste lo pueda retomar con el mínimo esfuerzo.
        <strong>
            Nadie del equipo debe ser
            imprescindible
        </strong>
        para que el trabajo continúe. Además, interesa
        poder
        <strong>
            reutilizar todo el código
        </strong>
        que vayan creando, para ir más
        rápido a la hora de programar.
        <strong>
            Juan
        </strong>
        le explica que si consiguen
        adoptar ese método de trabajo, no sólo redundará en una mejor organización para
        ellos, sino que ayudará a que las modificaciones en los programas sean más
        llevaderas de lo que lo están siendo ahora.
    </p>
    <p>
        <strong>
            María
        </strong>
        asiente ante las explicaciones de
        <strong>
            Juan
        </strong>
        , e
        intuye que todo lo entenderá mejor conforme vaya conociendo los conceptos de
        Programación Orientada a Objetos.
    </p>
    <p>
        De lo que realmente se trata es de que
        <strong>
            BK Programación
        </strong>
        invierta el
        menor tiempo posible en los proyectos que realice, aprovechando material elaborado
        con el esfuerzo ya realizado en otras aplicaciones.
    </p>
</div><h1 class="title">
    2.1.- Conceptos.
</h1>
<div class="iDevice_content">
    <p align="justify">
        Para entender mejor la filosofía de orientación a objetos veamos algunas
        características que la diferencian de las técnicas de programación tradicional.
    </p>
    <p align="justify">
        En la Programación Estructurada, el programa estaba compuesto por un conjunto
        de
        <strong>
            datos y funciones "globales".
        </strong>
        El término global significaba que eran
        accesibles por todo el programa, pudiendo ser llamados en cualquier ubicación de la
        aplicación. Dentro de las funciones se situaban las instrucciones del programa que
        manipulaban los datos.
        <strong>
            Funciones y datos se encontraban separados y totalmente
            independientes.
        </strong>
        Esto ocasionaba dos problemas principales:
    </p>
    <ul class="lista_verificacion">
        <li>
            Los programas se creaban y estructuraban de acuerdo con la arquitectura de la
            computadora donde se tenían que ejecutar.
        </li>
        <li>
            Al estar separados los datos de las funciones, éstos eran visibles en toda la
            aplicación. Ello ocasionaba que cualquier modificación en los datos podía requerir la
            modificación en todas las funciones del programa, en correspondencia con los cambios en
            los datos.
            <div class="elemento_centrado">
                <div class="elemento_centrado">

                </div>
            </div>
        </li>
    </ul>
    <p align="justify">
        En la
        <strong>
            Programación Orientada a Objetos la situación es
            diferente
        </strong>
        . La utilización de
        <strong>
            objetos
        </strong>
        permite un mayor nivel de
        <strong>
            abstracción
        </strong>
        que con la Programación Estructurada, y ofrece las siguientes
        diferencias con respecto a ésta:
    </p>
    <ul class="lista_verificacion">
        <li>
            El programador organiza su programa en
            <strong>
                objetos
            </strong>
            , que son
            <strong>
                representaciones del mundo real
            </strong>
            que están más cercanas a la forma de pensar
            de la gente.
        </li>
        <li>
            Los datos, junto con las funciones que los manipulan, son parte interna de los objetos y
            no están accesibles al resto de los objetos. Por tanto, los cambios en los datos de un
            objeto sólo afectan a las funciones definidas para ese objeto, pero no al resto de la
            aplicación.
            <div class="elemento_centrado">
                <div class="elemento_centrado">

                </div>
            </div>
        </li>
    </ul>
    <p align="justify">
        Todos los programas escritos bajo el paradigma orientado a Objetos se pueden
        escribir igualmente mediante la Programación Estructurada. Sin embargo, la Programación
        Orientada a Objetos es la que mayor facilidad presenta para el desarrollo de programas
        basados en
        interfaces gráficas de
        usuario


        Interfaces gráficas de usuario

        Entorno visual sencillo que ofrecen
        los programas para permitir la comunicación de los usuarios con la aplicación en sí,
        o con el sistema operativo.
        .
    </p>
</div><h1 class="title">
    2.2.- Beneficios.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>
    </div>
    <p>
        Según lo que hemos visto hasta ahora,
        <strong>
            un objeto es cualquier entidad que podemos ver
            o apreciar.
        </strong>
    </p>
    <p>
        El concepto fundamental de la Programación Orientada a Objetos son, precisamente, los
        objetos. Pero ¿qué beneficios aporta la utilización de objetos?
    </p>
    <p>
        Fundamentalmente la posibilidad de representar el problema en términos del mundo real, que
        como hemos dicho están más cercanos a nuestra forma de pensar, pero existen otra serie de
        ventajas como las siguientes:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Comprensión
            </strong>
            . Los conceptos del espacio del problema se hayan reflejados
            en el código del programa, por lo que la mera lectura del código nos describe la
            solución del problema en el mundo real.
        </li>
        <li>
            <strong>
                Modularidad.
            </strong>
            La definición de objetos en módulos o archivos
            independientes hace que las aplicaciones estén mejor organizadas y sean más fáciles de
            entender.
        </li>
        <li>
            <strong>
                Fácil mantenimiento.
            </strong>
            Cualquier modificación en las acciones queda
            automáticamente reflejada en los datos, ya que ambos están estrechamente relacionados.
            Esto hace que el mantenimiento de las aplicaciones, así como su corrección y
            modificación sea mucho más fácil. Por ejemplo, podemos querer utilizar un algoritmo más
            rápido, sin tener que cambiar el programa principal. Por otra parte, al estar las
            aplicaciones mejor organizadas, es más fácil localizar cualquier elemento que se quiera
            modificar y/o corregir. Esto es importante ya que se estima que
            <strong>
                los mayores
                costes de
                <span lang="en">
           software
          </span>
                no están en el proceso de desarrollo en
                sí, sino en el mantenimiento posterior
            </strong>
            de ese
            <span lang="en">
          software
         </span>
            a lo largo de su vida útil.
        </li>
        <li>
            <strong>
                Seguridad
            </strong>
            . La probabilidad de cometer errores se ve reducida, ya que no
            podemos modificar los datos de un objeto directamente, sino que debemos hacerlo mediante
            las acciones definidas para ese objeto. Imaginemos un objeto lavadora. Se compone de un
            motor, tambor, cables, tubos,
            <abbr title="etcétera.">
                etc.
            </abbr>
            Para usar una lavadora
            no se nos ocurre abrirla y empezar a manipular esos elementos, ya que lo más probable es
            que se estropee. En lugar de eso utilizamos los programas de lavado establecidos. Pues
            algo parecido con los objetos, no podemos manipularlos internamente, sólo utilizar las
            acciones que para ellos hay definidas.
        </li>
        <li>
            <strong>
                Reusabilidad
            </strong>
            . Los objetos se definen como entidades reutilizables, es
            decir, que los programas que trabajan con las mismas estructuras de información, pueden
            reutilizar las definiciones de objetos empleadas en otros programas, e incluso las
            acciones definidas sobre ellos. Por ejemplo, podemos crear la definición de un objeto de
            tipo Persona para una aplicación de negocios y deseamos construir a continuación otra
            aplicación, digamos de educación, en donde utilizamos también personas, no es necesario
            crear de nuevo el objeto, sino que por medio de la reusabilidad podemos utilizar el tipo
            de objeto Persona previamente definido.
        </li>
    </ul>
</div><h1 class="title">
    2.3.- Características.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Cuando hablamos de
        <strong>
            Programación Orientada a Objetos
        </strong>
        , existen una serie de
        características que se deben cumplir. Cualquier lenguaje de programación orientado a objetos
        las debe contemplar. Las características más importantes del paradigma de la programación
        orientada a objetos son:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Abstracción.
            </strong>
            Es el proceso por el cual definimos las características
            más importantes de un objeto, sin preocuparnos de cómo se escribirán en el código del
            programa, simplemente lo definimos de forma general. En la Programación Orientada a
            Objetos la herramienta más importante para soportar la abstracción es la
            <strong>
                clase
            </strong>
            . Básicamente, una clase es un
            tipo
            de dato


            Tipo de dato

            Un
            tipo especifica la naturaleza del dato, esto es, el rango de valores que puede
            adquirir, así como las operaciones que se pueden llevar a cabo sobre esos
            valores.
            que agrupa las características comunes de un conjunto de
            objetos. Poder ver los objetos del mundo real que deseamos trasladar a nuestros
            programas, en términos abstractos, resulta de gran utilidad para un buen diseño del
            <span lang="en">
          software
         </span>
            , ya que nos ayuda a comprender mejor el problema y a
            tener una visión global de todo el conjunto. Por ejemplo, si pensamos en una clase
            <strong>
                Vehículo
            </strong>
            que agrupa las características comunes de todos ellos, a
            partir de dicha clase podríamos crear objetos como
            <strong>
                Coche
                <code>
                </code>
            </strong>
            y
            <strong>
                Camión
            </strong>
            . Entonces se dice que
            <strong>
                Vehículo
            </strong>
            es una
            abstracción de Coche y de Camión.
        </li>
        <li>
            <strong>
                Modularidad.
            </strong>
            Una vez que hemos representado el escenario del problema
            en nuestra aplicación, tenemos como resultado un conjunto de objetos
            <span lang="en">
          software
         </span>
            a utilizar. Este conjunto de objetos se crean a partir de
            una o varias clases. Cada clase se encuentra en un archivo diferente, por lo que la
            modularidad nos permite modificar las características de la clase que define un objeto,
            sin que esto afecte al resto de clases de la aplicación.
        </li>
        <li>
            <strong>
                Encapsulación.
            </strong>
            También llamada
            <strong>
                "ocultamiento de la
                información"
            </strong>
            . La
            <strong>
                encapsulación
            </strong>
            o
            <strong>
                encapsulamiento
            </strong>
            es el mecanismo básico para ocultar la información de
            las partes internas de un objeto a los demás objetos de la aplicación. Con la
            encapsulación un objeto puede ocultar la información que contiene al mundo exterior, o
            bien restringir el acceso a la misma para evitar ser manipulado de forma inadecuada. Por
            ejemplo, pensemos en un programa con dos objetos, un objeto
            <strong>
                Persona
            </strong>
            y
            otro Coche.
            <strong>
                &lt;code&gt;Persona
            </strong>
            se comunica con el objeto
            <strong>
                Coche
            </strong>
            para llegar a su destino
            <em>
                ,
            </em>
            utilizando para ello las acciones que Coche
            tenga definidas, como por ejemplo, conducir. Es decir,
            <strong>
                Persona
            </strong>
            utiliza
            <strong>
                Coche
            </strong>
            , pero no sabe cómo funciona internamente, sólo sabe utilizar sus
            métodos o acciones.
            <div class="elemento_derecha">
                <div class="elemento_centrado">

                </div>
            </div>
        </li>
        <li>
            <strong>
                Jerarquía
            </strong>
            . Mediante esta propiedad podemos definir relaciones de
            jerarquías entre clases y objetos. Las dos jerarquías más importantes son la jerarquía
            <strong>
                "es un"
            </strong>
            llamada
            <strong>
                generalización
            </strong>
            o
            <strong>
                especialización
            </strong>
            y la jerarquía
            <strong>
                "es parte de"
            </strong>
            , llamada
            <strong>
                agregación
            </strong>
            . Conviene detallar algunos aspectos:
            <ul>
                <li>
                    La generalización o especialización, también conocida como
                    <strong>
                        herencia
                    </strong>
                    , permite crear una clase nueva en términos de una
                    clase ya existente (herencia simple) o de varias clases ya existentes (herencia
                    múltiple). Por ejemplo, podemos crear la clase
                    <strong>
                        CocheDeCarreras
                    </strong>
                    a partir de la clase
                    <strong>
                        Coche
                    </strong>
                    , y así sólo tendremos que definir
                    las nuevas características que tenga.
                </li>
                <li>
                    La agregación, también conocida como
                    <strong>
                        inclusión
                    </strong>
                    , permite agrupar
                    objetos relacionados entre sí dentro de una clase. Así, un
                    <strong>
                        Coche
                    </strong>
                    está formado por
                    <strong>
                        Motor
                    </strong>
                    ,
                    <strong>
                        Ruedas
                    </strong>
                    ,
                    <strong>
                        Frenos
                    </strong>
                    y
                    <strong>
                        Ventanas
                    </strong>
                    . Se
                    dice que
                    <strong>
                        Coche
                    </strong>
                    es una agregación y
                    <strong>
                        Motor
                    </strong>
                    ,
                    <strong>
                        Ruedas
                    </strong>
                    ,
                    <strong>
                        Frenos
                    </strong>
                    y
                    <strong>
                        Ventanas
                    </strong>
                    son
                    agregados de
                    <strong>
                        Coche
                    </strong>
                    .
                </li>
            </ul>
        </li>
        <li>
            <strong>
                Polimorfismo
            </strong>
            . Esta propiedad indica la capacidad de que varias clases
            creadas a partir de una antecesora realicen una misma acción de forma diferente. Por
            ejemplo, pensemos en la clase
            <strong>
                Animal
            </strong>
            y la acción de expresarse. Nos
            encontramos que cada tipo de
            <strong>
                Animal
            </strong>
            puede hacerlo de manera distinta,
            los
            <strong>
                Perros
            </strong>
            ladran, los
            <strong>
                Gatos
            </strong>
            maúllan, las
            <strong>
                Personas
            </strong>
            hablamos,
            <abbr title="etcétera.">
                etc
            </abbr>
            . Dicho de otra
            manera, el polimorfismo indica la posibilidad de tomar un objeto (de tipo
            <strong>
                Animal
            </strong>
            , por ejemplo), e indicarle que realice la acción de expresarse,
            esta acción será diferente según el tipo de mamífero del que se trate.
        </li>
    </ul>
</div><h1 class="title">
    2.4.- Lenguajes de programación orientados a objetos.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Una panorámica de la evolución de los lenguajes de programación orientados a objetos hasta
        llegar a los utilizados actualmente es la siguiente:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
          <span lang="en">
           Simula
          </span>
            </strong>
            <strong>
                (1962)
            </strong>
            . El primer
            lenguaje con objetos fue B1000 en 1961, seguido por
            <span lang="en">
          Sketchpad
         </span>
            en
            1962, el cual contenía clones o copias de objetos. Sin embargo, fue Simula el primer
            lenguaje que introdujo el concepto de clase, como elemento que incorpora datos y las
            operaciones sobre esos datos. En 1967 surgió Simula 67 que incorporaba un mayor número
            de tipos de datos, además del apoyo a objetos.
        </li>
        <li>
            <strong>
          <span lang="en">
           SmallTalk
          </span>
            </strong>
            <strong>
                (1972)
            </strong>
            . Basado
            en
            <strong>
          <span lang="en">
           Simula
          </span>
            </strong>
            67, la primera versión fue
            <strong>
          <span lang="en">
           Smalltalk
          </span>
            </strong>
            72, a la que siguió
            <strong>
          <span lang="en">
           Smalltalk
          </span>
            </strong>
            76, versión totalmente orientada a objetos.
            Se caracteriza por soportar las principales propiedades de la Programación Orientada a
            Objetos y por poseer un entorno que facilita el rápido desarrollo de aplicaciones. El
            Modelo-Vista-Controlador (
            MVC


            MVC.
            Modelo-Vista-Controlador

            Modelo de programación que separa los datos de
            una aplicación, de la interfaz que los maneja y del controlador que define la
            forma en que actúa la interfaz.
            ) fue una importante contribución de
            este lenguaje al mundo de la programación. El lenguaje
            <strong>
          <span lang="en">
           Smalltalk
          </span>
            </strong>
            ha influido sobre otros muchos lenguajes
            como
            <abbr title="C más más.">
                C++
            </abbr>
            y
            <span lang="en">
          Java
         </span>
            .
        </li>
        <li>
            <strong>
                C++ (1985).
            </strong>
            <abbr title="C más más.">
                C++
            </abbr>
            fue diseñado por
            <span lang="da">
          Bjarne Stoustrup
         </span>
            en los laboratorios donde trabajaba, entre 1982
            y 1985. Lenguaje que deriva del C, al que añade una serie de mecanismos que le
            convierten en un lenguaje orientado a objetos. No tiene recolector de basura automática,
            lo que obliga a utilizar un destructor de objetos no utilizados. En este lenguaje es
            donde aparece el concepto de clase tal y como lo conocemos actualmente, como un conjunto
            de datos y funciones que los manipulan.
        </li>
        <li>
            <strong>
          <span lang="fr">
           Eiffel
          </span>
            </strong>
            <strong>
                (1986)
            </strong>
            . Creado en 1985
            por
            <span lang="fr">
          Bertrand Meyer
         </span>
            , recibe su nombre en honor a la famosa torre
            de París. Tiene una sintaxis similar a C. Soporta todas las propiedades fundamentales de
            los objetos, utilizado sobre todo en ambientes universitarios y de investigación. Entre
            sus características destaca la posibilidad de traducción de código
            <span lang="fr">
          Eiffel
         </span>
            a Lenguaje C. Aunque es un lenguaje bastante potente, no
            logró la aceptación de
            <abbr title="C más más.">
                C++
            </abbr>
            y Java.
        </li>
        <li>
            <strong>
          <span lang="en">
           Java
          </span>
                (1995)
            </strong>
            . Diseñado por James
            <span lang="en">
          Gosling
         </span>
            de
            <span lang="en">
          Sun Microsystems
         </span>
            a finales de
            1995. Es un lenguaje orientado a objetos diseñado desde cero, que recibe muchas
            influencias de
            <abbr title="C más más.">
                C++
            </abbr>
            . Como sabemos, se caracteriza
            porque produce un
            <span lang="en">
          bytecode
         </span>
            que posteriormente es interpretado por
            la máquina virtual. La revolución de Internet ha influido mucho en el auge de
            <span lang="en">
          Java
         </span>
            .
        </li>
        <li>
            <strong>
                <abbr title="C Sharp.">
                    C#
                </abbr>
                (2000)
            </strong>
            . El lenguaje
            <abbr title="C Sharp.">
                C#
            </abbr>
            , también es conocido como C
            <span lang="en">
          Sharp
         </span>
            . Fue creado por
            <span lang="en">
          Microsoft
         </span>
            , como una
            ampliación de C con orientación a objetos. Está basado en
            <abbr title="C más más.">
                C++
            </abbr>
            y en Java. Una de sus principales ventajas que
            evita muchos de los problemas de diseño de
            <abbr title="C más más.">
                C++
            </abbr>
            .
        </li>
    </ul>
</div><h1 class="title">
    3.- Clases y Objetos. Características de los objetos.
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        <strong>
            María
        </strong>
        ha hecho un descanso de cinco minutos.
    </p>
    <p>
        Se está tomando un café y está repasando los conceptos de Programación Orientada a
        Objetos. Piensa que este paradigma supone un cambio de enfoque con respecto a las
        técnicas tradicionales. Ahora lo que necesita es ahondar en el concepto de objeto,
        que parece ser el eje central de este modelo de programación.
    </p>
</div><h1 class="title">
    3.1.- Propiedades y métodos de los objetos.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>
    </div>
    <p align="justify">
        Como acabamos de ver todo objeto tiene
        <strong>
            un estado y un
            comportamiento
        </strong>
        .
    </p>
    <p align="justify">
        Concretando un poco más, las partes de un objeto son:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Atributos
            </strong>
            ,
            <strong>
                campos
            </strong>
            o
            <strong>
                propiedades
            </strong>
            . Son
            la parte del objeto que almacena los datos. También se les denomina
            <strong>
                variables
            </strong>
            <strong>
                miembro
            </strong>
            . Estos datos pueden ser de cualquier
            tipo primitivo (boolean,
            <code>
                char
            </code>
            , int,
            <code>
                double
            </code>
            ,
            <abbr title="etcétera.">
                etc.
            </abbr>
            )
            <strong>
                o ser a su vez una referencia a otro
                objeto
            </strong>
            . Por ejemplo, un objeto de la clase Vehiculo
            <code>
            </code>
            puede
            contener varios objetos de la clase Rueda.
        </li>
        <li>
            <strong>
                Métodos
            </strong>
            o
            <strong>
                funciones miembro
            </strong>
            . Son la parte del objeto
            que lleva a cabo las operaciones sobre los atributos definidos para ese objeto.
        </li>
    </ul>
    <p>
        La idea principal es que el objeto reúne en una sola entidad los datos y las operaciones, y
        para acceder a los datos privados del objeto debemos utilizar los métodos que hay definidos
        para ese objeto.
    </p>
    <p>
        <strong>
            La única forma de manipular la información del objeto es a través de sus
            métodos
        </strong>
        . Esto significa que si queremos conocer el valor de algún atributo,
        tenemos que utilizar el método que nos muestre el valor de ese atributo (si es que se
        dispone de un método para ello). De esta forma, evitamos que métodos externos al objeto
        puedan alterar sus datos de manera inadecuada.
        <strong>
            Se dice que los atributos y los
            métodos están encapsulados dentro del objeto.
        </strong>
    </p>
</div><h1 class="title">
    3.2.- Interacción entre objetos.
</h1>
<div class="iDevice_content">
    <p>
        ¿Pero los distintos objetos de un programa pueden tener algún tipo de comunicación entre
        ellos?
    </p>
    <p>
        Dentro de un programa los objetos se comunican llamando unos a los
        métodos


        Método.

        Un método en Java
        es un conjunto de instrucciones definidas dentro de una clase, que realizan una
        determinada tarea y a las que podemos invocar mediante un nombre.


        Cuando se
        llama a un método, es como si en el lugar donde se pone su nombre, se "expandiera"
        todo el código que éste contiene, como si de una sola sentencia se tratara, de forma
        que la ejecución del programa pasa al método y cuando éste acaba, la ejecución
        continúa a partir del punto donde se produjo la llamada.
        de otros. Los
        métodos están dentro de los objetos y describen el comportamiento de un objeto cuando recibe
        una llamada a uno de sus métodos. En otras palabras, cuando un objeto,
        objeto1
        <strong>
            ,
        </strong>
        quiere actuar sobre otro, objeto2
        <strong>
            ,
        </strong>
        tiene que
        ejecutar uno de sus métodos. Entonces se dice que
        <strong>
            el objeto2 recibe un mensaje del
            objeto1
        </strong>
        .
    </p>
    <p align="justify" class="destacado">
        <strong>
            Un
            <em>
                mensaje
            </em>
            es la solicitud a un objeto
            para que realice una determinada acción.
        </strong>
        <br>
        <strong>
            Un
            <em>
                método
            </em>
            es la
            función o procedimiento al que se llama para actuar sobre un objeto
        </strong>
        (para
        enviarle un mensaje)
        <strong>
            .
        </strong>
        <br/></p>
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Los distintos mensajes que puede recibir un objeto o a los que puede responder reciben el
        nombre de
        <strong>
            protocolo
        </strong>
        de ese objeto.
    </p>
    <p>
        <span class="destacado_inline">
         <strong>
          El proceso de interacción entre objetos
         </strong>
         <strong>
          se suele resumir diciendo que se ha "enviado un mensaje" (hecho una
                                    petición) a un objeto, y el objeto determina "q
         </strong>
         <strong>
          ué hacer con el
                                    mensaje" (ejecuta el código del método).
         </strong>
        </span>
    </p>
    <p>
        Cuando se ejecuta un programa se producen las siguientes acciones:
    </p>
    <ul class="lista_verificacion">
        <li>
            Creación de los objetos a medida que se necesitan (de manera similar a como hacemos con
            variables de tipo entero, real, carácter,
            <abbr title="etcétera">
                etc
            </abbr>
            .).
        </li>
        <li>
            Comunicación entre los objetos mediante el envío de mensajes&nbsp; de unos a otros, o el
            usuario a los objetos.
        </li>
        <li>
            Eliminación de los objetos cuando no son necesarios para dejar espacio libre en la
            memoria del ordenador.
        </li>
    </ul>
    <p align="justify" class="destacado">
        <strong>
            Los objetos se pueden comunicar entre ellos
            invocando a los métodos de los otros objetos.
        </strong>
    </p>
</div><h1 class="title">
    3.3.- Clases.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>
    </div>
    <p>
        Hasta ahora hemos visto lo que son los objetos.
    </p>
    <p>
        Piensa en el mundo real, en un tipo de objeto, una galleta y en el proceso industrial de
        producción de galletas. No necesitamos hacer y hornear una sola galleta, sino que lo normal
        será hacer y hornear un montón de ellas. Para realizar ese proceso, seguro que nos resulta
        útil disponer de un molde que establezca cómo va a ser cada objeto galleta. Pues bien, algo
        así ocurre en programación con los objetos, que usamos "moldes" para construirlos.
    </p>
    <p>
        Un programa informático se compone de muchos objetos, algunos de los cuales comparten la
        misma estructura y comportamiento. Si tuviéramos que definir la estructura y comportamiento
        del objeto cada vez que queremos crear un objeto, estaríamos utilizando mucho código
        redundante. Por ello lo que se hace es crear una
        <strong>
            clase
        </strong>
        , que es una
        descripción de un conjunto de objetos que comparten una estructura y un comportamiento
        común. Y a partir de la clase, se crean tantas "copias" o "
        <strong>
            instancias
        </strong>
        " como
        necesitemos. Esas copias son los objetos de la clase.
    </p>
    <p align="justify" class="destacado">
        <strong>
            <em>
                Las clases constan de datos y métodos que
                resumen las características comunes de un conjunto de objetos
            </em>
            .
            <br>
            Un programa
            informático está compuesto por un conjunto de clases, a partir de las cuales se crean
            objetos que interactúan entre sí.
            <br/></strong>
    </p>
    <p>
        Si recuerdas, cuando utilizábamos los tipos de datos enumerados, los definíamos con la
        palabra reservada enum y la lista de valores entre llaves, y decíamos que un tipo de datos
        enum no es otra cosa que una especie de clase en
        <span lang="en">
         Java
        </span>
        . Efectivamente,
        todas las clases llevan su contenido entre llaves. Y una clase tiene la misma estructura que
        un tipo de dato enumerado, añadiéndole en su interior una serie de métodos y variables.
    </p>
    <p>
        En otras palabras,
        <strong>
            una clase es una plantilla o prototipo donde se
            especifican
        </strong>
        :
    </p>
    <ul class="lista_verificacion">
        <li>
            Los
            <strong>
                atributos
            </strong>
            comunes a todos los objetos de la clase.
        </li>
        <li>
            Los
            <strong>
                métodos
            </strong>
            que pueden utilizarse para manejar esos objetos.
        </li>
    </ul>
    <p>
        Para declarar una clase en
        <span lang="en">
         Java
        </span>
        se utiliza la palabra reservada class.
        La declaración de una clase está compuesta por:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Cabecera de la clase.
            </strong>
            La cabecera es un poco más compleja que como aquí
            definimos, pero por ahora sólo nos interesa saber que está compuesta por una serie de
            modificadores. En este caso hemos puesto public, que indica que es una clase pública a
            la que pueden acceder otras clases del programa, la palabra reservada class y el nombre
            de la clase.
        </li>
        <li>
            <strong>
                Cuerpo de la clase
            </strong>
            <em>
                <strong>
                    .
                </strong>
            </em>
            En él se especifican
            encerrados entre llaves los atributos y los métodos que va a tener la clase.
        </li>
    </ul>
    <div class="elemento_centrado">
        <div class="elemento_centrado">

        </div>
    </div>
    <p class="enlace_centrado">
        Estructura de una clase en Java

    </p>
    <p>
        En las unidades anteriores ya hemos utilizado clases, aunque aún no sabíamos apenas nada
        sobre su significado exacto.
    </p>
    <p>
        Por ejemplo, en la plantilla genérica que estamos usando para nuestros programas, en algunos
        ejemplos y en las tareas, hemos estado utilizando clases, todas ellas eran clases
        principales, sin ningún atributo y con un único método llamado main. Y así vamos a seguir
        por el momento,
        <strong>
            en esta unidad no vamos a aprender a implementar clases sino a
            utilizarlas
        </strong>
        . Usaremos las que nos proporciona la biblioteca de Java, también
        conocida como
        <abbr title="Application Programming Interface">
            API
        </abbr>
        (interfaz de
        programación de aplicaciones) de Java. También utilizaremos algún ejemplos de clase ya
        implementada que os proporcionemos como ejemplo.
    </p>
    <p>
        <span class="destacado_inline">
         Por ahora la única clase que vamos a implementar es la que
                                contiene nuestro programa principal dentro de un
         <strong>
          método main
         </strong>
         . Ahi
                                dentro estará todo nuestro programa.
        </span>
    </p>
</div><h1 class="title">
    4.- Utilización de objetos.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p align="justify">
        <strong>
            María
        </strong>
        sigue fuera de la oficina. Esta noche en casa
        quiere repasar conceptos sobre Programación Orientada a Objetos, así que aprovecha
        un momento para llamar a
        <strong>
            Juan
        </strong>
        y le comenta:
    </p>
    <p align="justify">
        —Ya sé todo sobre objetos -le dice- sólo que...
    </p>
    <p align="justify">
        —Solo que.... ¿qué? -añade
        <strong>
            Juan.
        </strong>
    </p>
    <p align="justify">
        —Solo me falta saber una cosa, ¿cómo se crea un objeto?
    </p>
    <p align="justify">
        <strong>
            Jua
        </strong>
        <strong>
            n
        </strong>
        sonríe ante la pregunta de
        <strong>
            Ma
        </strong>
        <strong>
            r
        </strong>
        <strong>
            ía
        </strong>
        , y le explica que los
        objetos se crean como si fuera declarando una variable más, tan sólo que el tipo de
        datos de dicho objeto será una clase. Tras declararlos hay que instanciarlos con el
        operador new para reservar memoria para ellos, y después ya podremos utilizarlos,
        refiriéndonos a su contenido con el operador punto.
    </p>
    <p align="justify">
        —Te mando un documento por correo electrónico que lo explica todo muy
        bien.
    </p>
    <p align="justify">
        —¡Ah, gracias! Esta noche le echo un vistazo
        <strong>
            .
        </strong>
    </p>
</div><h1 class="title">
    4.1.- Ciclo de vida de los objetos.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>
    </div>
    <p>
        Todo programa en
        <span lang="en">
         Java
        </span>
        parte de una única clase, que como hemos
        comentado se trata de la
        <strong>
            clase principal
        </strong>
        . Esta clase ejecutará el contenido
        de su método
        <strong>
            main
        </strong>
        , el cual será el que utilice las demás clases del
        programa, cree objetos y lance mensajes a otros objetos.
    </p>
    <p>
        Las instancias u objetos tienen un tiempo de vida determinado. Cuando un objeto no se va a
        utilizar más en el programa, es destruido por el recolector de basura para liberar recursos
        que pueden ser reutilizados por otros objetos.
    </p>
    <p>
        A la vista de lo anterior, podemos concluir que los objetos tienen un ciclo de vida, en el
        cual podemos distinguir las siguientes fases:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Creación
            </strong>
            , donde se hace la reserva de memoria e inicialización de
            atributos.
        </li>
        <li>
            <strong>
                Manipulación
            </strong>
            , que se lleva a cabo cuando se hace uso de los atributos y
            métodos del objeto.
        </li>
        <li>
            <strong>
                Destrucción
            </strong>
            , eliminación del objeto y liberación de recursos.
        </li>
    </ul>
</div><h1 class="title">
    4.2.- Declaración.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Para la creación de un objeto hay que seguir los siguientes pasos:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Declaración
            </strong>
            : indicar el tipo de objeto.
        </li>
        <li>
            <strong>
                Instanciación
            </strong>
            : creación del objeto utilizando el operador
            new
            <strong>
                .
            </strong>
        </li>
    </ul>
    <p>
        Veamos primero cómo declarar un objeto. Para indicar el tipo de objeto debemos emplear la
        siguiente instrucción:
    </p>
    <div class="highlighted-code language-java" style="width: 19.2em;">
        <div class="texto_izquierda">
            <pre>Tipo nombreObjeto;</pre>
        </div>
    </div>
    <p>
        donde:
    </p>
    <ul class="lista_verificacion">
        <li>
            Tipo es la clase a partir de la cual se va a crear el objeto (nombre de la clase, que
            empezará por mayúscula), y
        </li>
        <li>
            nombreObjeto es el nombre de la variable referencia con la cual nos referiremos al
            objeto (empezará por minúscula).
        </li>
    </ul>
    <p align="justify" class="destacado">
        <strong>
            Los tipos referenciados o referencias se utilizan
            para guardar una dirección de memoria en la que se encuentra un dato o un conjunto de
            datos.
        </strong>
    </p>
    <p>
        Para entender mejor la declaración de objetos veamos un ejemplo.
    </p>
    <p>
        La biblioteca de clases de la
        <abbr title="Application Programming Interface">
            API
        </abbr>
        <span lang="en">
         Java
        </span>
        ofrece un extenso conjunto de clases organizadas en paquetes que nos permiten programar con
        comodidad proporcionándonos muchas herramientas y utilidades que nosotros ya no vamos a
        tener que implementar. Un ejemplo podría ser la clase Rectangle, que representa a un
        rectángulo en el plano. Los objetos de esta clase representan rectángulos mediante una serie
        de datos (atributos). Entre esos atributos tenemos la
        <strong>
            ubicación del
            rectángulo
        </strong>
        (coordenadas (x,y) en el plano) y sus
        <strong>
            dimensiones
        </strong>
        (anchura y altura).
    </p>
    <p>
        La clase&nbsp;Rectangle se encuentra dentro del
        <span lang="en">
         paquete java.awt
        </span>
        . Para
        poder disponer de esta clase en tu programa debes incluir la línea import java.awt.Rectangle
        en tu programa (después de la línea package, que probablemente sea tu primera línea de
        código):
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>import java.awt.Rectangle;</pre>
        </div>
    </div>
    <p>
        Si queremos declarar un objeto de tipo "rectángulo" a partir de la clase Rectangle lo haremos
        como hemos hecho hasta el momento con cualquier variable de tipo primitivo salvo que en este
        caso en lugar de usar un tipo primitivo (
        <span lang="en">
         int
        </span>
        ,
        <span lang="en">
         double
        </span>
        ,
        <span lang="en">
         char
        </span>
        ,
        <span lang="en">
         boolean
        </span>
        ,
        <abbr title="etcétera">
            etc
        </abbr>
        .) usaremos como tipo el nombre de la clase:
    </p>
    <div class="highlighted-code language-java" style="width: 36em;">
        <div class="texto_izquierda">
         <pre>Rectangle rectangulo; // Declaración de una referencia
</pre>
        </div>
    </div>
    <p>
        Si queremos declarar varios, podemos hacerlo en líneas diferentes:
    </p>
    <div class="highlighted-code language-java" style="width: 36em;">
        <div class="texto_izquierda">
         <pre>// Declaración de varias referencias (variables) cada una por separado
Rectangle r1;
Rectangle r2;
Rectangle r3;
</pre>
        </div>
    </div>
    <p>
        o en la misma línea, como también hacemos con los tipos primitivos:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>Rectangle r1, r2, r3;  // Declaración de varias referencias (variables) en la misma línea
</pre>
        </div>
    </div>
    <p align="justify" class="destacado">
        <strong>
            En Java, los nombres de las clases empiezan con
            mayúscula, como por ejemplo
            <em>
                Rectangle
            </em>
            , y los nombres de los objetos (variables)
            con minúscula, como por ejemplo
            <em>
                rectangulo
            </em>
            . De este modo sabemos rápidamente de
            qué tipo de elemento estamos hablando (una clase o un objeto).
        </strong>
    </p>
    <p>
        Como puedes observar, poco se diferencia esta declaración de las declaraciones de variables
        que hacíamos para los tipos primitivos:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>int numero;        // Declaración de una variable de tipo entero
Rectangle placa;   // Declaración de una variable de tipo referencia a un objeto de la clase Rectangle</pre>
        </div>
    </div>
    <p>
        Lo que sí es cierto es que placa aún no contiene una referencia a un objeto (una dirección a
        una zona de memoria donde se encuentren los atributos de una instancia de la clase
        Rectangle) de la misma manera que numero aún no contiene en su interior los bytes que
        representan a un número entero.
    </p>
    <p>
        <strong>
            Al declarar una referencia, ésta se encuentra vacía
        </strong>
        hasta que se le asigne
        algún valor, como cualquier otra variable. Cuando una variable referencia a un objeto no
        contiene ninguna dirección a una instancia se dice que es una
        <strong>
            referencia
            nula
        </strong>
        , es decir, que contiene el valor null
        <strong>
        </strong>
        (también se dice
        que apunta a null). Esto significa que la variable referencia está creada, pero que aún no
        contiene una dirección de memoria (o "referencia") a una instancia. Es decir, hemos
        preparado la variable de tipo referencia indicando a qué tipo de objetos va a apuntar, pero
        todavía no hemos reservado memoria para el contenido del objeto (para los atributos que
        alberga en su interior). Por tanto, aún no está apuntando a ninguna posición de memoria que
        contenga ese objeto (sus datos o atributos), y para que no haya confusión posible, la
        referencia apunta a un lugar de la memoria inexistente llamado null (nulo).
    </p>
    <p>
        Debes tener en cuenta que
        <strong>
            en Java, para una variable de tipo referencia recién
            creada, ni siquiera podríamos considerar que contiene inicialmente el valor null. En
            este caso el compilador considera que aún no se le ha asignado ningún valor y si se
            intenta utilizar lo más probable es que se produzca un error de compilación
        </strong>
        . Se
        trata de algo similar a lo que sucedería por ejemplo con una variable de tipo int, recién
        declarada, que ni siquera contiene el valor 0 sino que se considera "aún no inicializada"
        (se obtendría un error del tipo
        <em>
        </em>
        <span lang="en">
         <em>
          variable might not have been
                                    initialized
         </em>
        </span>
        ).
    </p>
    <p>
        En el ejemplo anterior lo más probable es que en placa haya un valor null (de la misma manera
        que en&nbsp;numero haya un 0), pero el compilador de Java, por seguridad, no nos dejará
        utilizar esas variables hasta que se les haya asignado explícitamente algún valor.
    </p>
</div><h1 class="title">
    4.3.- Instanciación.
</h1>
<div class="iDevice_content">
    <p>
        Una vez declarada una variable de tipo referencia a un objeto, debemos crear la instancia u
        objeto a la que va a apuntar esa referencia. Para ello utilizamos el operador
        <strong>
            new
        </strong>
        con la siguiente sintaxis:
    </p>
    <div class="highlighted-code language-latex">
        <div>
            <pre>nombreObjeto = new ConstructorDeLaClase(parámetro1,...,parámetroN);</pre>
        </div>
    </div>
    <p>
        donde:
    </p>
    <ul class="lista_verificacion">
        <li>
            nombreObjeto es el nombre de la variable referencia con la cual nos referiremos al
            objeto;
        </li>
        <li>
            new es el operador necesario para crear el objeto (invocar una llamada al constructor);
        </li>
        <li>
            ConstructorDeLaClase es un método especial de la clase, que
            <strong>
                se llama igual que
                ella
            </strong>
            , y se encarga de inicializar el objeto. Es decir, de dar unos valores
            iniciales a sus atributos;
        </li>
        <li>
            par&lt;code&gt;ametro1,...,parametroN, son parámetros que puede o no necesitar el
            constructor para dar los valores iniciales a los atributos del objeto.
        </li>
    </ul>
    <p align="justify">
        Durante la instanciación del objeto se reserva memoria suficiente para
        almacenar todos los valores de los atributos del objeto. De esta tarea se encarga
        automáticamente la máquina virtual de
        <span lang="en">
         Java.
        </span>
    </p>
    <p>
        En el apartado anterior vimos cómo declarar un objeto de la clase Rectangle proporcionada por
        la biblioteca de clases de la
        <abbr title="Application Programming Interface">
            API
        </abbr>
        <span lang="en">
         Java (paquete
                                java.awt)
        </span>
        . Recuerda que poder disponer de esta clase en tu programa debes incluir
        la línea import java.awt.Rectangle al comienzo. Veamos ahora un ejemplo de creación de
        objetos instancias de la clase Rectangle.
    </p>
    <p>
        Si queremos instanciar un objeto de tipo "rectángulo" a partir de la clase Rectangle
        tendremos que utilizar el constructor seguido de un paréntesis y unos valores para
        "alimentar" los parámetros con los que haya sido diseñado ese constructor. Por ejemplo:
    </p>
    <div class="highlighted-code language-java" style="width: 36em;">
        <div class="texto_izquierda">
         <pre>Rectangle rectangulo; // Declaración
rectangulo = new Rectangle (0, 0, 10, 5); // Instanciación y asignación
</pre>
        </div>
    </div>
    <p>
        Con la primera línea declaramos una variable de tipo "rectángulo" (en realidad una variable
        referencia a objetos de la clase Rectangle). Con la segunda estamos:
    </p>
    <ol>
        <li>
            <strong>
                ejecutando el constructor
            </strong>
            de&nbsp;Rectangle para crear un objeto
            instancia de la clase Rectangle, cuyo vértice inferior izquierdo estará ubicado en las
            coordenadas (0,0), con una base de longitud 10 y una altura de longitud 5;
        </li>
        <li>
            <strong>
                asginando
            </strong>
            a la variable rectangulo la referencia devuelta por el
            operador new tras la ejecución del constructor.
        </li>
    </ol>
    <p>
        Como puedes observar, el operador&nbsp;new se encarga de devolver la referencia (algo así
        como una dirección de memoria) al objeto recién creado.
    </p>
    <p>
        También podrías haberlo hecho todo en una única línea:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>Rectangle rectangulo = new Rectangle (0, 0, 10, 5); // declaración + instaciación + asignación</pre>
        </div>
    </div>
    <p>
        En cualquier caso, tras la ejecución de estas instrucciones dispondrás de una variable
        llamada rectangulo que será una referencia que apuntará a un objeto instancia de la
        clase&nbsp;Rectangle cuyo contenido serán las coordenadas x=0, y=0, con una base de tamaño
        10 y una altura de tamaño 5.
    </p>
    <p align="justify">
        Visualmente podríamos representarlo en abstracto con la siguiente figura:
    </p>
    <p align="justify">

    </p>
</div><h1 class="title">
    4.3.1.- Concepto de constructor
</h1>
<div class="iDevice_content">
    <p>
        Acabamos de ver que para poder crear o "instanciar" un objeto de una clase determinada
        debemos utilizar el operador new
        <strong>
        </strong>
        seguido del nombre de la clase y un
        paréntesis con una opcional lista de parámetros. A esa acción la hemos llamado
        "
        <em>
            invocación al constructor de la clase
        </em>
        ". También hemos visto que el nombre del
        <strong>
            constructor
        </strong>
        de una clase con el nombre de la misma, de ahí la necesidad de
        poner paréntesis, y lo hemos descrito como un método especial que sirve para inicializar
        valores. En este apartado vamos a hablar un poco más sobre los constructores.
    </p>
    <p align="justify" class="destacado">
        <strong>
            Un constructor es un método especial con el mismo
            nombre de la clase y que no devuelve ningún valor de forma explícita tras su ejecución,
            aunque implícitamente se devuelve el objeto que se está creando a través del operador
            new
            <strong>
            </strong>
            .
            <br>
            <br/></strong>
    </p>
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>
    </div>
    <p>
        Para poder crear un objeto debemos instanciarlo utilizando el constructor de la clase. En el
        apartado anterior vimos un ejemplo de creación de un objeto de la clase Rectangle
        proporcionada por la biblioteca de clases de
        <span lang="en">
         Java (paquete java.awt)
        </span>
        :
    </p>
    <div class="highlighted-code language-java" style="width: 32em;">
        <div class="texto_izquierda">
         <pre>Rectangle rectangulo = new Rectangle (0, 0, 10, 5);
</pre>
        </div>
    </div>
    <p>
        Con esa línea creábamos, a través de una invocación al constructor y mediante el uso del
        operdor
        <span lang="en">
         new
        </span>
        , un
        <strong>
            objeto instancia de la clase
            Rectangle
        </strong>
        ubicado en la posición (0,0), de base 10 y de altura 5. Y a
        continuación se asignaba a la variable rectangulo la referencia devuelta por el operador new
        tras la ejecución del constructor.
    </p>
    <p>
        Lo primero que hay que hacer para poder disponer de un objeto y aplicar manipulaciones sobre
        él es invocar a su constructor.
    </p>
    <p>
        Un constructor tiene las siguientes caracteristicas:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                es invocado automáticamente durante la creación de un objeto al usar el
                operador
            </strong>
            <span lang="en">
          new
         </span>
            . Una vez creado un objeto no se
            podrá volver a llamar a su constructor. Si se hace una nueva invocación con
            <span lang="en">
          new
         </span>
            se estará creando otro nuevo objeto;
        </li>
        <li>
            <strong>
                los nombres de los constructores no empiezan con minúscula
            </strong>
            , como el
            resto de los métodos, ya que
            <strong>
                se llaman igual que la clase
            </strong>
            y los nombres
            de clase deben empezar siempre con letra mayúscula, según convenio;
        </li>
        <li>
            <strong>
                puede haber varios constructores
            </strong>
            para una clase, que se llamarán todos
            igual, pero que se diferenciarán por su lista de argumentos
            (
            <strong>
                sobrecarga
            </strong>
            );
        </li>
        <li>
            el constructor puede tener
            <strong>
                parámetros
            </strong>
            para indicar con qué valores
            iniciar o configurar los atributos del objeto que se va a crear;
        </li>
        <li>
            en Java,
            <strong>
                es necesario que toda clase tenga al menos un constructor
            </strong>
            . Si
            no se implementa ningún constructor para una clase Java,
            <strong>
                y solamente en ese
                caso
            </strong>
            , el compilador crea un
            <strong>
                constructor por omisión vacío
            </strong>
            ,
            (también conocido como "
            <em>
                constructor por defecto
            </em>
            " o "
            <em>
            </em>
            <span lang="en">
          <em>
           default constructor
          </em>
         </span>
            ") que inicializa los atributos a sus
            valores por omisión o defecto, según del tipo que sean: 0 para los tipos numéricos,
            false para los boolean y
            <code>
                null
            </code>
            para las referencias.
        </li>
    </ul>
</div><h1 class="title">
    4.4.- Referencias a objetos
</h1>
<div class="iDevice_content">
    <p>
        Ya hemos visto que lo que contiene una variable de tipo referencia (variable que no es de
        tipo primitivo) es una referencia (algunos lo llaman puntero) a una zona de memoria donde se
        encuentran alojados los atributos de un objeto instancia de una clase.
    </p>
    <p>
        Eso significa que en la variable de tipo "referencia" u "objeto" no está almacenado el objeto
        en sí (la sucesión de todos los bytes que representan la información que contienen los
        atributos), sino un número (que nosotros llamamos referencia, dirección de memoria o
        puntero) que indica donde están todos esos bytes con los valores de los atributos. Una
        analogía podría ser la de que la variable referencia es un casillero donde se guarda la
        llave de una habitación. La habitación con todo su contenido sería el objeto con sus
        atributos dentro y el casillero sería la variable de tipo referencia que contiene la
        dirección de memoria o referencia (llave de la habitación) a donde está el objeto
        (habitación).
    </p>
    <p>
        Por tanto, cuando se realiza una asignación de un objeto de tipo referencia a otro objeto de
        tipo referencia, lo único que estamos haciendo es copiar y asignar referencias (direcciones
        de memoria o "llaves") pero no haciendo copias de los objetos ("habitaciones").
    </p>
    <p>
        En este ejemplo que ya analizamos anteriormente:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>Rectangle r1 = new Rectangle (0, 0, 10, 5); // declaración + instaciación + asignación</pre>
        </div>
    </div>
    <p>
        podíamos considerar que se llevaban a cabo tres pasos:
    </p>
    <ol>
        <li>
            se declaraba la variable r1 de tipo referencia a objetos instancias de la clase
            Rectangle,
        </li>
        <li>
            se instanciaba un objeto de la clase&nbsp;Rectangle con las siguientes caracteristicas:
            ubicación en las coordenadas (0,0), base 10, altura 5 (invocación al constructor a
            través del operador new);
        </li>
        <li>
            se asignaba a la variable&nbsp;r1 la referencia que devuelve el operador&nbsp;new tras
            ejecutar el código del constructor y reservarse una zona de memoria para almacenar los
            atributos de un nuevo objeto instancia de la clase Rectangle.
        </li>
    </ol>
    <p>
        Es decir, que hemos hecho un&nbsp;new y por tanto tenemos un nuevo objeto Rectangle. Y como
        además hemos hecho una asignación a r1, podemos decir que r1 "apunta" a ese objeto recién
        creado. Eso es más correcto que decir que r1 "contiene" al objeto rectángulo. Por eso
        usábamos una representación gráfica de este tipo:
    </p>
    <p align="justify">

    </p>
    <p>
        Si a continuación hacemos:
    </p>
    <div class="highlighted-code language-java">
        <pre>Rectangle r2= r1;
</pre>
    </div>
    <p align="justify">
        <strong>
            No estaremos creando un nuevo objeto Rectangle
        </strong>
        , sino que
        estaremos asignando a r2 la misma referencia (posición de memoria o "llave") que contiene
        r1. De este modo, aunque r1 y
        <code>
            r2
        </code>
        son dos variables distintas (podemos
        imaginarlas como dos casilleros distintos) están apuntando al mismo objeto (podríamos decir
        que ambos contienen copias de una misma llave para una misma habitación). Eso significa que
        cualquier acción que se lleve a cabo sobre el objeto apuntado por r1 también se estará
        llevando a cabo sobre el objeto apuntado por r2, pues no son más que dos referencias al
        mismo objeto. No se trata de objetos diferentes sino de variables referencia diferentes que
        en este caso apuntan a la misma instancia (un objeto de la clase
        <strong>
            Rectangle
        </strong>
        ).
    </p>
    <p align="justify">

    </p>
    <p>
        Si queremos tener un segundo objeto de tipo Rectangle, tendríamos que hacer un segundo new (o
        bien, como veremos más adelante, una invocación a algún método que devuelva un nuevo objeto
        instancia de la clase Rectangle) y asignarlo a alguna variable de tipo referencia a la clase
        Rectangle. Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <pre>Rectangle r3= new Rectangle (1, 1, 6, 3);
</pre>
    </div>
    <p align="justify">
        En este caso la variable r3 apuntaría a un nuevo objeto de tipo Rectangle
        diferente al que apuntan r1 y
        <code>
            r2
        </code>
        :
    </p>
    <p align="justify">

    </p>
    <p>
        ¿Qué sucede si en un momento dado r3 deja de apuntar a su objeto original y se le asigna por
        ejemplo el valor de r2?
    </p>
    <div class="highlighted-code language-java">
        <pre>r3= r2;  // r3 "apunta" a donde esté apuntando r2 (no hace una copia, "apuntan" o "referencian" al mismo objeto)
</pre>
    </div>
    <p>

    </p>
    <p>
        No habría problema, r3 cambiará de valor y a partir de ese momento las variables r1,
        <code>
            r2
        </code>
        y r3 apuntarían al mismo objeto. Por otro lado, el objeto al apuntaba
        originalmente r3 se habrá quedado "perdido" o "huérfano" (no existe ninguna variable
        referencia que apunte a él). El recolector de basura de Java acabará borrándolo de la
        memoria, pues se trata de un elemento irrecuperable desde el programa y por tanto inútil.
    </p>
</div><h1 class="title">
    4.5.- Manipulación.
</h1>
<div class="iDevice_content">
    <p>
        Una vez creado e instanciado un objeto ¿cómo accedemos a su contenido o le enviamos un
        mensaje?
    </p>
    <p>
        Para acceder a los
        <strong>
            atributos y métodos del objeto
        </strong>
        utilizaremos el nombre del
        objeto seguido del
        <strong>
            operador punto (.)
        </strong>
        y el nombre del atributo o método que
        queremos utilizar. Cuando utilizamos el operador punto se dice que estamos enviando un
        mensaje al objeto. La forma general de enviar un mensaje a un objeto es:
    </p>
    <div class="highlighted-code language-java" style="width: 17.55em;">
        <div class="texto_izquierda">
         <pre>nombreObjeto.mensaje
</pre>
        </div>
    </div>
    <p>
        Por ejemplo, para acceder a los atributos o variables instancia del objeto se utiliza la
        siguiente sintaxis:
    </p>
    <div class="highlighted-code language-java" style="width: 18.1em;">
        <div class="texto_izquierda">
         <pre>nombreObjeto.nombreAtributo
</pre>
        </div>
    </div>
    <p>
        Y para acceder a los métodos o funciones miembro del objeto se utiliza la sintaxis:
    </p>
    <div class="highlighted-code language-java" style="width: 33.85em;">
        <div class="texto_izquierda">
         <pre>nombreObjeto.nombreMetodo ( lista de parámetros )
</pre>
        </div>
    </div>
    <p align="left">
        La lista de parámetros consiste en una lista de valores (puede ser una lista
        vacía) que cada método espera que se le pasen.
    </p>
    <p>
        Ahora bien, para poder acceder a cualquier miembro de un objeto (ya sea un atributo o un
        método) debe de tratarse de un
        <strong>
            miembro accesible
        </strong>
        , es decir, que tengamos
        permiso para acceder a él. Si no tenemos acceso a ese miembro desde fuera del objeto es como
        si no existiera. De hecho, ni siquiera sabremos que existe, pues será un elemento
        estructural de la clase que como usuarios de ella desconoceremos. En ese sentido podemos
        imaginar la clase como una "caja negra" que define con qué miembros del objeto (atributos
        y/o métodos) nos podemos comunicar. Cuando escribamos programas que utilicen objetos de una
        determinada clase, no todo el contenido de esos objetos será accesible directamente desde
        nuestro código mediante el operador punto. Sólo tendremos acceso a aquellos elementos a los
        que se nos permita acceder. Son los elementos que definen la
        <strong>
            interfaz de la
            clase
        </strong>
        . A esos elementos también se les suele llamar
        <strong>
            miembros
            públicos
        </strong>
        del objeto.
    </p>
    <p>
        Para entender mejor cómo se pueden manipular objetos vamos a continuar con nuestro ejemplo de
        los objetos de la clase Rectangle. En primer lugar instanciamos el objeto invocando al
        <strong>
            método constructor, que se llama igual que la clase
        </strong>
        , a través del operador
        new e indicando los parámetros correspondientes a la posición y a las dimensiones del
        rectángulo como ya hemos hecho en anteriores ocasiones:
    </p>
    <div class="highlighted-code language-java" style="width: 32.95em;">
        <div class="texto_izquierda">
         <pre>Rectangle rectangulo = new Rectangle(50, 50, 150, 150);
</pre>
        </div>
    </div>
    <p>
        La sentencia anterior declara la variable rectangulo como una referencia de tipo Rectangle, y
        hace que apunte a un nuevo objeto que se crea al invocar al constructor con el operador new.
        El constructor recibe como parámetros las coordenadas de la esquina superior izquierda, que
        sería el punto (50, 50) en la pantalla, y el ancho y alto del mismo (longitud de la base y
        la altura), que sería 150 en ambos casos.
    </p>
    <p>
        Una vez que hemos instanciado un objeto de tipo&nbsp;Rectangle y que disponemos de una
        variable referencia a él llamada rectangulo, si queremos cambiar el valor de los atributos
        utilizamos el operador punto. Por ejemplo, para cambiar la dimensión del rectángulo, para
        que tanto su altura como su base sean 100, en lugar de los 150 que le habíamos asignado,
        podría hacerse modificando directamente el valor de sus atributos así:
    </p>
    <div class="highlighted-code language-java" style="width: 14.8em;">
        <div class="texto_izquierda">
         <pre>rectangulo.height = 100 ;
</pre>
            <pre>rectangulo.width = 100 ;
</pre>
        </div>
    </div>
    <p>
        Esto hemos podido hacerlo porque los atributos height (altura) y width (anchura o base) de la
        clase&nbsp;Rectangle son
        <strong>
            públicos
        </strong>
        (accesibles desde fuera del objeto) y por
        tanto manipulables desde nuestro programa. Si no, no habríamos podido acceder a ellos.
    </p>
    <p>
        Otra posibilidad habría sido utilizar un método para hacer algo similar a lo anterior. Por
        ejemplo, la siguiente línea de código fija el tamaño del rectángulo a 200 por 200, tanto de
        base como de altura. El método utilizado se llama setSize:
    </p>
    <div class="highlighted-code language-java" style="width: 18.65em;">
        <div class="texto_izquierda">
         <pre>rectangulo.setSize(200,200) ;
</pre>
        </div>
    </div>
    <p>
        Lo más habitual será proceder de esta segunda manera, pues normalmente los atributos suelen
        ser privados dentro del objeto y no se pueden manipular desde fuera. Para ello se nos
        proporcionarán métodos (como por ejemplo setSize) que nos permitirán llevar a cabo esas
        manipulaciones pero de forma "controlada".
    </p>
    <p>
        Aquí tienes un ejemplo completo donde se prueba todo lo anterior:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Instanciamos un nuevo objeto de la clase Rectangle
// y apuntamos a él mediante la variable r1
// Ubicación en (0,0) y dimiensiones 10 de base, 5 de altura
System.out.print   ("Creando objeto instancia de la clase Rectangle ");
System.out.println ("y referenciado desde la variable r1.");
Rectangle r1= new Rectangle (0,0, 10, 5);
System.out.println ();

// Mostramos los atributos o propiedades del objeto al que apunta r1
System.out.println ("Rectángulo r1:");
System.out.println ("Ubicación: x=" + r1.x + " y=" + r1.y);
System.out.println ("Dimensiones: base= " + r1.width+ " altura= " + r1.height);

// Modificamos los atributos o propiedades del objeto al que apunta r1

// 1. Accediendo directamente a sus atributos y modificándolos (pues son públicos)
r1.height= 20;
r1.width= 100;
System.out.println ();
System.out.println ("Rectángulo r1 modificado mediante manipulación de atributos:");
System.out.println ("Ubicación: x=" + r1.x + " y=" + r1.y);
System.out.println ("Dimensiones: base= " + r1.width+ " altura= " + r1.height);

// 2. Utilizando un método para modificar algunos de sus atributos: setSize
r1.setSize(200, 50);
System.out.println ();
System.out.println ("Rectángulo r1 modificado mediante llamada a un método:");
System.out.println ("Ubicación: x=" + r1.x + " y=" + r1.y);
System.out.println ("Dimensiones: base= " + r1.width+ " altura= " + r1.height);</pre>
        </div>
    </div>
    <p>
        La salida debería ser algo similar a lo siguiente:
    </p>
    <div class="highlighted-code code-style-2 language-latex">
        <div>
         <pre>Creando objeto instancia de la clase Rectangle y referenciado desde la variable r1.

Rectángulo r1:
Ubicación: x=0 y=0
Dimensiones: base= 10 altura= 5

Rectángulo r1 modificado mediante manipulación de atributos:
Ubicación: x=0 y=0
Dimensiones: base= 100 altura= 20

Rectángulo r1 modificado mediante llamada a un método:
Ubicación: x=0 y=0
Dimensiones: base= 200 altura= 50</pre>
        </div>
    </div>
</div><h1 class="title">
    4.6.- Destrucción de objetos y liberación de memoria.
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Cuando un objeto deja de ser utilizado, es necesario liberar el espacio de memoria y otros
        recursos que poseía para que puedan ser reutilizados por el sistema. A esta acción se le
        denomina
        <strong>
            destrucción del objeto.
        </strong>
    </p>
    <p>
        En
        <span lang="en">
         Java
        </span>
        la destrucción de objetos corre a cargo del
        <strong>
            recolector
            de basura (
            <span lang="en">
          garbage collector
         </span>
        </strong>
        <strong>
            )
        </strong>
        . ¡Un gran
        invento!, ya que nos permite como programadores prácticamente desentendernos de ese asunto,
        sabiendo además que nunca van a producirse problemas por olvidarse de recoger la basura
        adecuadamente, como ocurría en otros lenguajes.
    </p>
    <p>
        El recolector de basura es un sistema de destrucción automática de objetos que ya no son
        utilizados (no existe ninguna variable de tipo referencia que enlace a ellos). Lo que se
        hace es liberar una zona de memoria que había sido reservada previamente mediante el
        operador new, pero que ya ha dejado de estar referenciada, es decir, ya no hay forma de
        llegar a ella, y por tanto ya no es posible volver a usar ese objeto. Esto evita que al
        programar tengamos que preocuparnos de realizar la liberación de memoria.
    </p>
    <p>
        El recolector de basura se ejecuta en segundo plano y de manera muy eficiente para no afectar
        a la velocidad del programa que se está ejecutando. Lo que hace es que periódicamente va
        buscando objetos que ya no son referenciados, y cuando encuentra alguno lo marca para ser
        eliminado. Después los elimina en el momento que considera oportuno, cuando el procesador
        está menos ocupado.
    </p>
    <div class="texto_izquierda">
        <pre/>
    </div>
</div><h1 class="title">
    4.7.- Objetos String en Java.
</h1>
<div class="iDevice_content">
    <p>
        Cuando veíamos los tipos de datos primitivos, indicábamos que
        <span lang="en">
         Java
        </span>
        proporcionaba un tipo de dato especial para los textos o cadenas de caracteres que era el
        tipo de dato String. Realmente este tipo de dato es un
        <strong>
            tipo referenciado
        </strong>
        ,
        no un tipo primitivo. Para declarar una variable de este tipo de dato llamada por ejemplo
        mensaje, debemos escribir lo siguiente:
    </p>
    <div class="highlighted-code language-java" style="width: 14.25em;">
        <pre>String mensaje;</pre>
    </div>
    <p>
        Con lo que ya sabemos ahora podemos observar que String
        <strong>
            es realmente una
            clase
        </strong>
        que nos proporciona
        <span lang="en">
         Java
        </span>
        para facilitar el trabajo
        con cadenas de texto a partir de la cual creamos nuestro objeto llamado mensaje.
    </p>
    <p align="justify" class="destacado">
        <strong>
            En Java, los nombres de las clases empiezan con
            mayúscula, como por ejemplo
            <em>
                String
            </em>
            , y los nombres de los objetos con minúscula,
            como por ejemplo
            <em>
                mensaje
            </em>
            . De este modo sabemos rápidamente de qué tipo de
            elemento estamos hablando (una clase o un objeto).
        </strong>
    </p>
    <p>
        Como puedes observar, poco se diferencia esta declaración de las declaraciones de variables
        que hacíamos para los tipos primitivos. Antes decíamos que mensaje era una variable del tipo
        de dato String
        <strong>
        </strong>
        . Ahora realmente vemos que mensaje es una referencia a un
        objeto de la clase String, pero en la práctica la declaración no es diferente a como podría
        ser por ejemplo la declaración de una variable de tipo int.
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>int numero;     // Declaración de una variable de tipo entero
String mensaje; // Declaración de una variable de tipo referencia a un objeto de la clase String</pre>
        </div>
    </div>
    <p>
        Lo que sí es cierto es que mensaje aún no contiene una referencia a un objeto (una dirección
        a una zona de memoria donde se encuentren los atributos de una instancia de la clase String)
        de la misma manera que numero aún no contiene en su interior los bytes que representan a un
        número entero. Lo más probable es que en&nbsp;mensaje haya un valor null (de la misma manera
        que en&nbsp;numero haya un 0), pero el compilador de Java, por seguridad, no nos dejará usar
        esas variables hasta que se les haya asignado explíciamente algún valor.
    </p>
    <p align="justify">
        Para instanciar un objeto String debemos invocar a su constructor, como ya
        hemos visto con ejemplos de otros objetos:
    </p>
    <div class="highlighted-code language-java" style="width: 17.55em;">
        <pre>String texto = new String();
</pre>
    </div>
    <p align="justify">
        Así estaríamos instanciando el objeto texto. Para ello utilizaríamos el
        operador new y el constructor de la clase String, que se llama igual que la clase (String).
    </p>
    <p align="justify">
        En el ejemplo anterior el objeto se crearía con la cadena vacía (""), si
        queremos que tenga un contenido debemos una versión del constructor que contenga parámetros.
        Por ejemplo:
    </p>
    <div class="highlighted-code language-java" style="width: 30.2em;">
        <pre>texto = new String ("El primer programa");
</pre>
    </div>
    <p align="justify" class="destacado">
        <strong>
            Aunque String es una clase, se trata de una clase
            muy especial.
        </strong>
        <br>
        <br>
        <strong>
         <span lang="en">
          Java
         </span>
            permite utilizar la
            clase String como si de un tipo de dato primitivo se tratara, por eso no hace falta
            utilizar el operador new para instanciar un objeto de la clase String, aunque también
            puede hacerse. Por tanto las sentencias texto=new String("El primer programa"); y
            texto="El primer programa"; son totalmente equivalentes. Lo que hace Java cuando se
            encuentra una del segundo (sin invocación al constructor con
            <strong>
                new
            </strong>
            ) tipo
            es "traducirla" al primer tipo (con
            <strong>
                new
            </strong>
            y el
            constructor).
        </strong>
        <br>
        <br>
        <strong>
            Queremos llamar también tu atención sobre el
            hecho de que no es lo mismo decir que una referencia de tipo String apunte a&nbsp; la
            cadena vacía
            (objeto String de longitud
            cero, que no tiene ningún carácter) que decir que apunte a null (que no es un String,
            sino una forma de indicar que no apunta a ningún objeto). La cadena vacía sí es un
            objeto. El valor
            <strong>
                null
            </strong>
            no representa a ningún objeto sino a la
            referencia nula (es decir, que no se está apuntando a nada).
            <br>
            <br/></strong>
        <br/><br/><br/><br/></p>
    <p align="justify">
        Como ya hemos visto con otras variables de tipo referencia (y con los tipos
        primitivos), la
        <strong>
            declaración y asignación de un valor inicial
        </strong>
        a una variable
        de tipo&nbsp;String puede hacerse también en una misma línea o instrucción. Es decir, que
        podemos hacer:
    </p>
    <div class="highlighted-code language-java">
        <pre>String texto = new String ("El primer programa"); // Declaración + instanciación + asignación de valor inicial
</pre>
    </div>
    <p>
        donde se llevan a cabo la siguientes operaciones y en este orden:
    </p>
    <ol>
        <li>
            declaración de la variable texto, de tipo String (o de la clase String);
        </li>
        <li>
            instanciación de un objeto de la clase String mediante la llamada a su constructor con
            el parámetro "
            <em>
                el primer programa
            </em>
            " a través del operador new;
        </li>
        <li>
            asignación de la referencia al objeto recién creado (lo que devuelve new) a la variable
            texto para que a partir de ese momento la variable texto "referencie" o "apunte" a un
            objeto de la clase&nbsp;String con el contenido "
            <em>
                el primer programa
            </em>
            ".
        </li>
    </ol>
    <p>
        Ahora bien, dado que Java nos ofrece la comodidad de poder instanciar objetos&nbsp;String sin
        necesidad de usar el operador new para invocar al constructor, lo normal es que la
        inicialización de un objeto de tipo&nbsp;String normalmente tenga el siguiente aspecto:
    </p>
    <div class="highlighted-code language-java">
        <pre>String texto = "El primer programa"; // Declaración + instanciación + asignación de valor inicial
</pre>
    </div>
    <p>
        donde se llevan a cabo las mismas acciones que en el ejemplo anterior.
    </p>
    <div class="exe-tooltip-text" id="tc5529e84-d198-6b96-bb43-adc24e5dee8a">
        <p>
            Valor para una cadena que consiste en una cadena con 0 caracteres. Sería algo así como el
            "cero" de las cadenas. Es representada habitualmente por dos comillas dobles "" sin nada
            en medio.
        </p>
    </div>
</div><h1 class="title">
    5.- Métodos.
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        <strong>
            María
        </strong>
        está contenta con lo que está aprendiendo sobre
        <span lang="en">
           Java
          </span>
        , básicamente se trata de ampliar sus conocimientos y con
        la experiencia que ella tiene no le resultará difícil ponerse a programar en poco
        tiempo.
    </p>
    <p>
        <strong>
            Juan
        </strong>
        ha comenzado el proyecto de la Clínica Veterinaria y ella
        quiere implicarse también lo antes posible. Además, están los dos becarios
        <strong>
            Ana
        </strong>
        y
        <strong>
            Carlos,
        </strong>
        que se han incorporado al proyecto
        hace poco y hay que comenzar a pensar en tareas para ellos.
    </p>
    <p>
        Por lo pronto,
        <strong>
            María
        </strong>
        continúa con el documento facilitado por
        <strong>
            Juan
        </strong>
        , ahora tiene que ver cómo se utilizan los métodos, aunque
        intuye que no va a ser algo muy diferente a las funciones y procedimientos de
        cualquier otro lenguaje.
    </p>
</div><h1 class="title">
    5.1.- Parámetros y valores devueltos.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Los métodos se pueden utilizar tanto para consultar información sobre el objeto como para
        modificar su estado. La información consultada del objeto se devuelve a través de lo que se
        conoce como
        <strong>
            valor de retorno
        </strong>
        , y la modificación del estado del objeto, es
        decir, de sus atributos, se lleva a cabo mediante la
        <strong>
            lista de parámetros
        </strong>
        .
    </p>
    <p>
        En general, los parámetros de un método pueden pasarse de dos formas diferentes:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                por valor.
            </strong>
            El valor de los parámetros no cambia al finalizar la
            ejecución el método. Es decir, cualquier modificación que se haga en los parámetros no
            tendrá efecto una vez se salga del método. Esto es así porque cuando se llama al método
            desde cualquier parte del programa, dicho método recibe una copia de los argumentos, por
            tanto cualquier modificación que haga será sobre la copia, no sobre las variables
            originales;
        </li>
        <li>
            <strong>
                por referencia.
            </strong>
            La modificación en los valores de los parámetros sí
            tienen efecto tras la finalización del método. Cuando pasamos una variable a un método
            por referencia lo que estamos haciendo es pasar la dirección del dato en memoria, por
            tanto cualquier cambio en el dato seguirá modificado una vez que salgamos del método.
        </li>
    </ul>
    <p>
        <span class="destacado">
         <strong>
          En el lenguaje
          <span lang="en">
           Java
          </span>
          , todos parámetros
                                    se pasan por valor
         </strong>
         .
        </span>
    </p>
    <p>
        Ahora bien, en el caso de parámetros que son referencias a objetos debemos tener en cuenta
        que:
    </p>
    <ol>
        <li>
            al pasarse por valor la referencia al objeto (zona de memoria a la que se apunta), ésta
            no podrá ser modificada desde el interior del método (siempre se "apuntará" al mismo
            objeto o zona de memoria, pues siempre se pasa por "valor");
        </li>
        <li>
            el estado del objeto al que se apunta (sus atributos) sí podría ser modificado si se le
            aplica algún método que altera alguno de sus atributos;
        </li>
        <li>
            sólo si el objeto al que se apunta es inmutable podemos garantizar que ese objeto no
            puede ser modificado dentro de un método.
        </li>
    </ol>
    <p>
        Respecto a la interfaz de un método en
        <span lang="en">
         Java
        </span>
        , debemos tener en cuenta
        que:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                indica qué tipo de valor devuelve
            </strong>
            (o bien void o tipo "vacío" en el
            caso de no devolver nada). Este
            <strong>
                valor de retorno
            </strong>
            es el valor que
            devuelve el método cuando termina de ejecutarse, al método o programa que lo llamó.
            Puede ser un tipo primitivo, un tipo referenciado o bien el tipo void, que indica la
            ausencia de valor de retorno;
        </li>
        <li>
            <strong>
                dispone de una lista de argumentos o parámetros.
            </strong>
            Los argumentos son
            variables a través de las cuales se pasa información al método desde el lugar del que se
            llame, para que éste pueda utilizar dichos valores durante su ejecución. Los argumentos
            reciben el nombre de
            <strong>
                parámetros
            </strong>
            cuando aparecen en la declaración del
            método. Esos argumentos serían como las "variables de entrada" del método pues lo
            habitual es que un método no haga peticiones de datos por teclado, sino que reciba ya
            sus datos de entrada a través de sus parámetros.
        </li>
    </ul>
    <p class="destacado">
        <strong>
            El
            <em>
                valor de retorno
            </em>
            es la información que devuelve un
            método tras su ejecución.
        </strong>
    </p>
    <p>
        La cabecera de un método en Java se declara como sigue:
    </p>
    <div class="highlighted-code language-java">
        <div class="texto_izquierda">
         <pre>public tipoDeDatoDevuelto nombreMetodo (listaDeParametros) // Cabecera del método &#123;
   // Cuerpo del método (algo a lo que no tiene acceso quien use el método)
&#125;
</pre>
        </div>
    </div>
    <p>
        Como puedes observar, el
        <strong>
            tipo de dato devuelto
        </strong>
        aparece después del
        modificador public y se corresponde con el
        <strong>
            valor de retorno
        </strong>
        . La lista de
        parámetros aparece al final de la cabecera del método, justo después del nombre, encerrados
        entre signos de paréntesis y separados por comas. Se debe indicar el tipo de dato de cada
        parámetro así:
    </p>
    <div class="highlighted-code language-java" style="width: 47.25em;">
        <div class="texto_izquierda">
         <pre>(tipoParametro1 nombreParametro1, ..., tipoParametroN nombreParametroN)
</pre>
        </div>
    </div>
    <p>
        Aquí tienes un ejemplo real de la cabecera de un método que pertenece a la clase Rectangle:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>public boolean contains(int x, int y)</pre>
        </div>
    </div>
    <p>
        En este caso el valor de retorno es de tipo boolean y la lista de parámetros contiene dos
        parámetros ambos de tipo int.
    </p>
    <p>
        Cuando se llame al método, se deberá utilizar el nombre del método, seguido de los argumentos
        que deben coincidir con la lista de parámetros.
    </p>
    <p class="destacado">
        La
        <strong>
            lista de argumentos
        </strong>
        en la llamada a un método (lista de
        parámetros actuales) debe coincidir en número, tipo y orden con los
        <strong>
            parámetros
        </strong>
        incluidos en la declaración del método (lista de parámetros
        formales), ya que de lo contrario se produciría un error de sintaxis.
    </p>
    <p>
        Un ejemplo de llamada al método anterior podría ser el siguiente:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>boolean test= r1.contains(3,4);</pre>
        </div>
    </div>
    <p>
        donde:
    </p>
    <ol>
        <li>
            r1 debería apuntar a un objeto instancia de la clase Rectangle;
        </li>
        <li>
            la invocación al método devolvería un valor true o
            <code>
                false
            </code>
            dependiendo de que
            el punto (3,4) se encuentre dentro del área abarcada por el rectángulo representado por
            ese objeto.
        </li>
    </ol>
    <p>
        En este caso los
        <strong>
            parámetros formales
        </strong>
        serían x e
        <code>
            y
        </code>
        , de tipo int,
        y los
        <strong>
            parámetros actuales
        </strong>
        serían 3 y
        <code>
            4
        </code>
        . Podríamos decir que
        durante la ejecución del método para esa llamada en concreto, en el interior del código del
        método la variable local o parámetro&nbsp;x pasará a valer 3 y la variable y pasará a valer
        4.
    </p>
</div><h1 class="title">
    5.2.- Uso de métodos
</h1>
<div class="iDevice_content">
    <p>
        Una vez que hemos visto el aspecto de la interfaz de un método, vamos a ver algunos ejemplos
        de cómo utilizar algunos de ellos. Para ello vamos a volver a la clase&nbsp;Rectangle que ya
        hemos usado en varias ocasiones. Podemos observar en la siguiente tabla algunos ejemplos de
        los métodos que incorpora:
    </p>
    <table class="tabla">
        <caption>
            Algunos métodos de la clase Rectangle
        </caption>
        <tbody>
        <tr>
            <td style="width: 40%;">
                <strong>
                    Método
                </strong>
            </td>
            <td style="width: 60%;">
                <strong>
                    Descripción
                </strong>
            </td>
        </tr>
        <tr>
            <td>
                public boolean contains(int x, int y)
            </td>
            <td>
                Indica si el rectángulo contiene al punto (x,y). Devuelve un boolean.
            </td>
        </tr>
        <tr>
            <td>
                public Rectangle intersection(Rectangle r)
            </td>
            <td>
                Calcula el rectángulo resultante de realizar la intersección con el rectángulo r
                que se pasa como parámetro. Devuelve una referencia a un nuevo objeto Rectangle.
            </td>
        </tr>
        <tr>
            <td>
                public boolean intersects(Rectangle r)
            </td>
            <td>
                Indica si el objeto rectángulo y el rectángulo r que se pasa como parámetro
                tienen algún punto en común (hacen intersección). Devuelve un boolean.
            </td>
        </tr>
        <tr>
            <td>
                public void setLocation(int x, int y)
            </td>
            <td>
                Se desplaza la ubicación del rectángulo a las coordenadas (x,y) pasadas como
                parámetros. No devuelve ningún valor.
            </td>
        </tr>
        <tr>
            <td>
                public void setSize(int width, int height)
            </td>
            <td>
                Se establece un nuevo tamaño para el rectángulo a partir de la nueva anchura
                (base) y altura pasadas como parámetros. No devuelve nada.
            </td>
        </tr>
        <tr>
            <td>
                public Rectangle union(Rectangle)
            </td>
            <td>
                Calcula un nuevo rectángulo resultado de realizar la unión con el rectángulo r
                que se pasa como parámetro. Devuelve una referencia a un nuevo objeto Rectangle.
            </td>
        </tr>
        <tr>
            <td>
                public double getHeight()
            </td>
            <td>
                Obtiene la altura actual del objeto rectángulo. Devuelve un double.
            </td>
        </tr>
        <tr>
            <td>
                public double getWidth()
            </td>
            <td>
                Obtiene&nbsp;la anchura (longitud de la base) actual del objeto rectángulo.
                Devuelve un double.
            </td>
        </tr>
        <tr>
            <td>
                &lt;code&gt;public double getX()
            </td>
            <td>
                Obtiene&nbsp;la posición x del rectángulo (esquina inferior izquierda). Devuelve
                un double.
            </td>
        </tr>
        <tr>
            <td>
                public double getY()
            </td>
            <td>
                Obtiene&nbsp;la posición y del rectángulo (esquina inferior izquierda). Devuelve
                un double.
            </td>
        </tr>
        </tbody>
    </table>
    <p>
    </p>
    <p>
        La forma en la que estos métodos han sido implementados "por dentro" (el cuerpo o "interior"
        de los métodos) es algo que por el momento no nos interesa. Los objetos que instanciemos de
        la clase&nbsp;Rectangle son algo así como "cajas cerradas" con las cuales nos podemos
        comunicar a través de sus métodos sin conocer su mecanismo interior. Su implementación
        interna ha sido la labor de otro programador o programadora que se encargó de codificar y
        probar apropiadamente cada uno esos métodos y que nosotros vamos a utilizar sin preocuparnos
        acerca de cómo están desarrollados internamente. A ese efecto nos podemos considerar como
        "usuarios" de los objetos de esta clase, pues no tenemos acceso a su código fuente ni es
        nuestra misión conocer su interior. Nos vamos a limitar a usarlos.
    </p>
</div><h1 class="title">
    5.3.- Documentación de una clase
</h1>
<div class="iDevice_content">
    <p>
        Una vez que ya hemos estado manipulando objetos a través del uso de sus métodos, es posible
        que te preguntes:
    </p>
    <ul class="lista_verificacion">
        <li>
            ¿cómo puedo conocer todas las operaciones (métodos) que puedo realizar sobre un objeto
            que sea instancia de una determinada clase? ¿qué valores devuelven estos métodos? ¿qué
            parámetros hay que pasarles para que funcionen correctamente?
        </li>
        <li>
            ¿tienen los objetos de esa clase algunos atributos públicos a los que pueda acceder?
        </li>
        <li>
            ¿cuántos constructores tiene esa clase? ¿qué parámetros tienen?
        </li>
    </ul>
    <p>
        Normalmente cuando se distribuye un conjunto de clases para que pueda ser utilizada por otros
        programadores, además de los archivos binarios que contienen esas clases también se
        proporciona una documentación sobre ese paquete o conjunto de clases donde puedes encontrar
        las respuestas a todas esas preguntas.
    </p>
    <p>
        Dependiendo del lenguaje (y a veces incluso del entorno), dispondremos de un sistema de
        documentación u otro. Pero en general se tratará de un conjunto de documentos donde para
        cada clase se ofrecerá una descripción de todos y cada uno de sus miembros públicos para que
        esa clase pueda ser utilizada correcta y apropiadamente por cualquier programador sin que
        tenga por qué conocer ningún detalle de su implementación interna.
    </p>
    <p>
        En el caso de Java, se utiliza un sistema de documentación conocido como
        <strong>
            javadoc
        </strong>
        que proporciona toda la información disponible sobre cada clase en
        formato
        <abbr title="Hypertext Markup Language ">
            HTML
        </abbr>
        facilitando la navegación
        entre clases, paquetes, métodos, etc. Esto quiere decir que si vamos a utilizar una
        biblioteca de clases, además de las propias clases (archivos binarios) deberían también
        proporcionarnos el javadoc de esa biblioteca para que sepamos de qué clases disponemos, qué
        métodos tienen, qué hacen, qué parámetros necesitan, que valores se devuelven y en qué
        circunstancias,
        <abbr title="etcétera">
            etc
        </abbr>
        .
    </p>
    <p>
        Puedes echar un primer vistazo a toda esta documentación consultando el siguiente enlace:
    </p>
    <p>
        <strong>
            Documentación javadoc de la API de Java
        </strong>
    </p>
    <p>
        Aquí podrás observar una lista de los paquetes básicos de la API de Java. Dado que ahora
        mismo todo eso te puede parecer una "sobredosis" de información, limítate a pulsar sobre el
        enlace al módulo java.desktop y a continuación sobre el enlace al paquete java.awt. Una vez
        ahí te aparecerá una tabla resumen con una lista de interfaces ("
        <em>
            Interface
            Summary
        </em>
        ") y a continuación otra tabla con una lista de clases ("
        <em>
            Class
            Summary
        </em>
        "). Ahí podrás observar todas las clases del paquete java.awt, entre ellas
        tendrás la clase Rectangle. Pulsa sobre ella para navegar por la documentación de esa clase,
        que al menos ya has utilizado.
    </p>
    <p>
        Si te has perdido entre tanta información, también puedes pulsar sobre el siguiente enlace:
    </p>
    <p>
        <strong>
            Documentación javadoc de la API de Java
        </strong>
    </p>
    <p>
        que te llevará directamente a la documentación sobre la clase Rectangle.
    </p>
    <p>
        Una vez allí, te encontrarás con una página con la siguiente estructura:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                cabecera
            </strong>
            , sección "
            <em>
                <strong>
                    Class Rectangle
                </strong>
            </em>
            ", donde te
            aparecerá el título "
            <strong>
                <em>
                    Class Rectangle
                </em>
            </strong>
            " (nombre de la clase).
            Aquí encontrarásabundante información general sobre la clase, la mayoría de la cual aún
            no entenderás. Pero sí observarás que, entre otras cosas, dispones de una
            <strong>
                descripción de la clase
            </strong>
            explicando para qué puede servir y qué
            características tendrán los objetos que se instancien a partir de ella;
        </li>
    </ul>
    <div class="exe-figure exe-image position-center license-copyright" style="width: 240px;">

        <div class="figcaption">
            Oracle
            <span class="license">
          <span class="sep">
           (
          </span>
          <span>
           Todos los derechos reservados
          </span>
          <span class="sep">
           )
          </span>
         </span>
        </div>
    </div>
    <div class="exe-figure exe-image position-center license-copyright" style="width: 240px;">

        <div class="figcaption">
            Oracle
            <span class="license">
          <span class="sep">
           (
          </span>
          <span>
           Todos los derechos reservados
          </span>
          <span class="sep">
           )
          </span>
         </span>
        </div>
    </div>
    <ul class="lista_verificacion">
        <li>
            sección "
            <em>
                <strong>
                    Nested Class Summary
                </strong>
            </em>
            ", que por ahora no entendemos ni
            necesitamos consultar;
        </li>
        <li>
            sección "
            <em>
                <strong>
                    Field Summary
                </strong>
            </em>
            ", donde podrás observar los
            <strong>
                atributos
            </strong>
            ,
            <strong>
                propiedades
            </strong>
            o "
            <strong>
                campos
            </strong>
            "
            públicos (
            <span lang="en">
          <em>
           fields
          </em>
         </span>
            en inglés) de la clase;
        </li>
    </ul>
    <div class="exe-figure exe-image position-center license-copyright" style="width: 240px;">

        <div class="figcaption">
            Oracle
            <span class="license">
          <span class="sep">
           (
          </span>
          <span>
           Todos los derechos reservados
          </span>
          <span class="sep">
           )
          </span>
         </span>
        </div>
    </div>
    <ul class="lista_verificacion">
        <li>
            sección "
            <em>
                <strong>
                    Constructor Summary
                </strong>
            </em>
            ", con una tabla resumen de los
            <strong>
                constructores
            </strong>
            disponibles para esta clase;
        </li>
    </ul>
    <div class="exe-figure exe-image position-center license-copyright" style="width: 240px;">

        <div class="figcaption">
            Oracle
            <span class="license">
          <span class="sep">
           (
          </span>
          <span>
           Todos los derechos reservados
          </span>
          <span class="sep">
           )
          </span>
         </span>
        </div>
    </div>
    <ul class="lista_verificacion">
        <li>
            sección "
            <em>
                <strong>
                    Method Summary
                </strong>
            </em>
            ", con otra table resumen de los
            <strong>
                métodos públicos
            </strong>
            de esta clase;
        </li>
    </ul>
    <div class="exe-figure exe-image position-center license-copyright" style="width: 240px;">

        <div class="figcaption">
            Oracle
            <span class="license">
          <span class="sep">
           (
          </span>
          <span>
           Todos los derechos reservados
          </span>
          <span class="sep">
           )
          </span>
         </span>
        </div>
    </div>
    <p>
    </p>
    <ul class="lista_verificacion">
        <li>
            sección "
            <em>
                <strong>
                    Field Detail
                </strong>
            </em>
            ", donde se explica con más detalle cada
            uno de los atributos de la clase;
        </li>
    </ul>
    <div class="exe-figure exe-image position-center license-copyright" style="width: 240px;">

        <div class="figcaption">
            Oracle
            <span class="license">
          <span class="sep">
           (
          </span>
          <span>
           Todos los derechos reservados
          </span>
          <span class="sep">
           )
          </span>
         </span>
        </div>
    </div>
    <p>
    </p>
    <ul class="lista_verificacion">
        <li>
            sección "
            <em>
                <strong>
                    Constructor Detail
                </strong>
            </em>
            ", donde se explica detalladamente
            el
            <strong>
                funcionamiento de cada uno de los constructores
            </strong>
            de la clase;
        </li>
    </ul>
    <div class="exe-figure exe-image position-center license-copyright" style="width: 240px;">

        <div class="figcaption">
            Oracle
            <span class="license">
          <span class="sep">
           (
          </span>
          <span>
           Todos los derechos reservados
          </span>
          <span class="sep">
           )
          </span>
         </span>
        </div>
    </div>
    <ul class="lista_verificacion">
        <li>
            seccion "
            <em>
                <strong>
                    Method Detail
                </strong>
            </em>
            ", donde se explica detalladamente el
            <strong>
                funcionamiento de cada uno de los métodos
            </strong>
            de la clase.
        </li>
    </ul>
    <div class="exe-figure exe-image position-center license-copyright" style="width: 240px;">

        <div class="figcaption">
            Oracle
            <span class="license">
          <span class="sep">
           (
          </span>
          <span>
           Todos los derechos reservados
          </span>
          <span class="sep">
           )
          </span>
         </span>
        </div>
    </div>
    <p>
        Aquí tendrás toda la información que pudieras necesitar para usar esa clase. Como puedes
        observar, la tabla con la descripción de sus métodos y constructores puede ser como diez
        veces más grande que la pequeña tabla resumen con algunos ejemplos de métodos que nosotros
        hemos usado en la sección anterior para resolver algunos ejercicios. Ahora se trata de una
        documentación "real" y es exhaustiva, pues contiene toda la información que pudiera requerir
        un programador que quisera hacer uso de esa clase en sus programas.
    </p>
</div><h1 class="title">
    5.4.- Objetos inmutables.
</h1>
<div class="iDevice_content">
    <p>
        Se dice que una es
        <strong>
            clase inmutable
        </strong>
        cuando sus instancias una vez creadas e
        inicializadas no pueden modificar su estado, es decir, que son
        <strong>
            objetos
            inmutables
        </strong>
        . Esto significa que todos los métodos que llevan a cabo operaciones
        que en principio alterarían el estado interno de estos objetos, en realidad lo que hacen es
        generar una nueva instancia con ese nuevo estado.
    </p>
    <p>
        Algunos ejemplos de clases en Java cuyos objetos son inmutables son:
    </p>
    <ul class="lista_verificacion">
        <li>
            la clase String;
        </li>
        <li>
            las clases envoltorio o "
            <em>
          <span lang="en">
           wrappers
          </span>
            </em>
            " (Byte,
            <code>
                Integer
            </code>
            , Integer,
            <code>
                Long
            </code>
            , Float,
            <code>
                Double
            </code>
            , Character,
            <code>
                Boolean
            </code>
            );
        </li>
        <li>
            las clases para manipulación de fecha y hora: LocalDate,
            <code>
                LocalTime
            </code>
            ,
            LocalDateTime.
        </li>
    </ul>
    <p>
        Esto significa que cada vez que se llame a un método de un objeto instancia estas clases que
        implique algún tipo de modificación en su estado, no se va a llevar a cabo ese cambio en el
        propio objeto sino que se devolverá un nuevo objeto con esos cambios.
    </p>
    <p>
        Un caso típico de clase inmutable en Java es la clase String. Para objetos instancias esta
        clase, métodos como concat,
        <code>
            replace
        </code>
        o trim no modifican el estado del objeto
        original sino que generan un nuevo objeto con la modificación que resulta de la aplicación
        del método. Si probamos el siguiente ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Declaramos y creamos una nueva cadena (declaración + instanciación + asignación)
String cadenaOriginal = new String ("Hola");

// Mostramos su contenido en pantalla
System.out.println("Cadena original: "+ cadenaOriginal);

// Le concatenamos la cadena " caracola" (aplicación del método concat)
cadenaOriginal.concat(" caracola");

// Volvemos a mostrar su contenido en pantalla
System.out.println(cadenaOriginal);
</pre>
        </div>
    </div>
    <p>
        podemos observar que la salida del programa es:
    </p>
    <div class="highlighted-code code-style-2 language-latex">
        <div>
         <pre>Cadena original: Hola
Cadena tras la aplicación del método concat: Hola</pre>
        </div>
    </div>
    <p>
        Es decir, que la concatenación no ha afectado al objeto cadenaOriginal, sino que se ha
        generado (instanciado) un nuevo objeto de la clase String con el resultado de esa
        modificación (una nueva cadena cuyo valor será "
        <em>
            Hola caracola
        </em>
        "). Si quisiéramos
        haber visto el resultado de la modificación en pantalla deberíamos haber mostrado
        directamente el resultado de la operación:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Declaramos y creamos una nueva cadena
String cadenaOriginal = new String ("Hola");

// Mostramos su contenido en pantalla
System.out.println("Cadena original: " + cadenaOriginal);

// Mostrar el resultado de aplicar el método concat
System.out.println("Cadena tras la aplicación del método concat: " + cadenaOriginal.concat(" caracola"));</pre>
        </div>
    </div>
    <p>
        O bien asignar a una segunda variable de tipo referencia a String ese resultado y a
        continuación mostrar su contenido por pantalla:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Declaramos y creamos una nueva cadena
String cadenaOriginal = new String ("Hola");

// Mostramos su contenido en pantalla
System.out.println("Cadena original: " + cadenaOriginal);

// Declaramos una segunda variable para referenciar objetos de la clase String
String cadenaTransformada;

// Y le asignamos el resultado de aplicar el método concat sobre el cadenaOriginal
cadenaTransformada= cadenaOriginal.concat(" caracola");

// Mostramos el contenido de ese segundo objeto
System.out.println("Cadena tras la aplicación del método concat: " + cadenaTransformada);</pre>
        </div>
    </div>
    <p>
        En ambos casos deberíamos obtener una salida del tipo:
    </p>
    <div class="highlighted-code code-style-2 language-latex">
        <div>
         <pre>Cadena original: Hola
Cadena tras la aplicación del método concat: Hola caracola</pre>
        </div>
    </div>
    <p>
        La conclusión que obtenemos de este experimento es que métodos de manipulación de este tipo
        de objetos no afectan al objeto sobre el que se aplica la operación sino que generan un
        nuevo objeto como resultado de la operación aplicada. En este caso se dice que se trata de
        <strong>
            objetos inmutables
        </strong>
        y, por extensión, se habla de
        <strong>
            clases
            inmutables
        </strong>
        .
    </p>
    <p>
        En estos casos necesitamos una segunda referencia (una variable) para poder almacenar la
        referencia al nuevo objeto que se ha creado como resultado de la operación. Si no
        almacenamos en una variable la referencia al objeto devuelta por el método que se ha
        invocado para llevar a cabo la operación, esa instancia quedaría sin referenciar desde
        nuestro programa y el recolector de basura acabará eliminándola.
    </p>
    <p>
        Si queremos utilizar solamente una variable, podríamos hacerlo volviendo a asignar a la misma
        variable referencia a String en la que se almacenaba el contenido original, la referencia al
        nuevo objeto creado tras la operación de concatenación:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Declaramos, instanciamos y asignamos una nueva cadena
String miVar = new String("Hola");

// Mostramos su contenido en pantalla
System.out.println("Cadena inicial: " + miVar);

// Y le ahora asignamos a la misma variable el resultado de aplicar el método concat sobre la cadena inicial
miVar = miVar.concat(" Antonio");

// Mostramos el nuevo contenido de la referencia, que ahora apunta a un nuevo objeto String
System.out.println("Cadena tras la aplicación del método concat: " + miVar);</pre>
        </div>
    </div>
    <p>
        En este caso la salida por pantalla sería idéntica, pero habríamos perdido la referencia a
        objeto&nbsp;String original, pues en esa variable hemos almacenado ahora la referencia al
        nuevo objeto&nbsp;String resultado del a concatenación.
    </p>
    <p>
        Ahora bien, dadas las particularidades de la clase String en Java, lo usual será que:
    </p>
    <ol>
        <li>
            no encuentres el uso de new con una llamada al constructor para crear nuevas cadenas
            (objetos instancia de la clase String);
        </li>
        <li>
            no veas el uso del método concat para concatenarlas, sino que te encontrarás
            directamente con el operador = (asignación) para la instanciación (llamada al
            constructor) y asignación, así como el operador + para concatenar un objeto&nbsp;String
            con otro objeto String.
        </li>
    </ol>
    <p>
        Teniendo en cuenta eso, el anterior fragmento de código quedaría de la siguiente manera:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Declaramos, instanciamos y asignamos una nueva cadena
// (llamada implícita al constructor sin necesidad de new ni de escribir el constructor)
String miVar = "Hola";

// Mostramos su contenido en pantalla
System.out.println("Cadena inicial: " + miVar);

// Y le asignamos el resultado de aplicar el operador de concatenación + sobre la cadena inicial
miVar = miVar + " Antonio";

// Mostramos el contenido de ese segundo objeto
System.out.println("Cadena tras la aplicación del método concat: " + miVar);
</pre>
        </div>
    </div>
    <p>
        El resultado en este caso también debería ser el mismo.
    </p>
</div><h1 class="title">
    5.5.- Comparación de objetos en Java: método equals.
</h1>
<div class="iDevice_content">
    <p>
        En algunas ocasiones necesitarás comparar dos objetos para saber si son iguales. Cuando
        comparábamos dos variables de tipo primitivo (reales, enteros, caracteres, booleanos,
        <abbr title="etcétera">
            etc.
        </abbr>
        ) teníamos muy claro qué significaba que dos elementos sean
        iguales. Sin embargo, cuando hablamos de objetos, quizá la cosa no esté tan clara.
    </p>
    <p>
        Dado que un objeto suele estar caracterizado por un conjunto de valores que conforman su
        estado (atributos o propiedades), ¿cuál es el criterio para decidir si dos objetos son
        iguales o no? Por ejemplo podríamos decidir que dos objetos instancias de la misma clase son
        iguales sin tienen el mismo estado (mismos valores en cada uno de sus atributos comparados
        uno a uno). Eso parece bastante razonable y es lo que se suele hacer.
    </p>
    <p>
        Por ejemplo, para el caso de objetos de la clase Rectangle que hemos estado utilizando,
        podríamos decir que dos rectángulos son iguales si coinciden los valores de sus atributos de
        <strong>
            ubicación
        </strong>
        (x,
        <code>
            y
        </code>
        ),
        <strong>
            base
        </strong>
        (width) y
        <strong>
            altura
        </strong>
        (height). ¿Y cómo llevamos a cabo esa comparación? ¿debemos nosotros
        escribir el código que vaya comparando uno a uno cada uno de sus atributos? Obviamente no.
        La idea es disponer de algún mecanismo de comparación que nos facilite esa labor de la misma
        manera que hacíamos con los tipos primitivos cuando utilizábamos el operador relacional ==
        para obtener true si dos valores del mismo tipo eran iguales o false si no lo eran.
    </p>
    <p>
        En Java ese mecanismo de comparación se realiza mediante el método equals. Todo objeto en
        Java dispone de un método&nbsp;equals que permite compararlo con otro objeto del mismo tipo.
        Veamos un ejemplo de comparación de varios objetos instancia de la clase Rectangle:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Declaración de tres referencias a objetos Rectangle
// Instanciación de tres objetos Rectangle mediante el constructor
// Y asignación de las referencias devueltas por el operador new a cada una de
// las tres variables declaradas
Rectangle r1= new Rectangle (1,2, 5, 4);
Rectangle r2= new Rectangle (5,3, 4, 6);
Rectangle r3= new Rectangle (5,3, 4, 6);

// Comparación de los tres objetos mediante el uso del método equals
// sobre las variable referencia que apuntan a los objetos
System.out.println ("Ejemplos de comparación de objetos rectángulo:");
System.out.println ("Comparación r1 con r2 -> r1.equals(r2): " + r1.equals(r2));
System.out.println ("Comparación r1 con r3 -> r1.equals(r3): " + r1.equals(r3));
System.out.println ("Comparación r2 con r3 -> r2.equals(r3): " + r2.equals(r3));</pre>
        </div>
    </div>
    <p>
        El resultado de esas comparaciones debería ser el siguiente:
    </p>
    <div class="highlighted-code code-style-2 language-latex">
        <div>
         <pre>Ejemplos de comparación de objetos rectángulo:
Comparación r1 con r2 -> r1.equals(r2): false
Comparación r1 con r3 -> r1.equals(r3): false
Comparación r2 con r3 -> r2.equals(r3): true</pre>
        </div>
    </div>
    <p>
        Lo cual es razonable dado que r2 y
        <code>
            r3
        </code>
        tienen exactamente los mismos valores
        en sus atributos (son rectángulos idénticos), mientras que&nbsp;r1 es diferente.
    </p>
    <p>
        Del mismo modo que el operador&nbsp;== para tipos primitivos cumplía la
        <strong>
            propiedad
            conmutativa
        </strong>
        (daba igual qué valor estuviera a la izquierda o a la derecha), en
        el caso del método&nbsp;equals también sucede lo mismo: vamos a obtener el mismo resultado
        tanto si hacemos r1.equals(r2) como si&nbsp; hacemos r2.equals(r1).
    </p>
    <p>
        Es posible que ahora te preguntes, ¿y no podrá haber utilizado directamente el operador ==
        para llevar a cabo esas comparaciones en lugar de tener que usar el método equals? Te
        retamos a que lo pruebes tú mismo:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>System.out.println ("Comparación r1 con r2 -> r1 == r2: " + (r1 == r2) );
System.out.println ("Comparación r1 con r3 -> r1 == r3: " + (r1 == r3) );
System.out.println ("Comparación r2 con r3 -> r2 == r3: " + (r2 == r3) );</pre>
        </div>
    </div>
    <p>
        ¿Qué has obtenido?
    </p>
    <p>
        Lo más probable es que todas las comparaciones te hayan salido como false, ¿verdad? ¿Por qué?
        Porque lo que estás comparando con el operador&nbsp;== es el contenido de las variables
        referencia r1,
        <code>
            r2
        </code>
        y&nbsp;r3 y no el contenido de los valores de los
        atributos de cada uno de los objetos a los que apuntan esas referencias. Cada una de esas
        variables apunta a una zona de memoria diferente (un objeto diferente) y por tanto
        contendrán un valor (dirección de memoria) diferente haciendo que su comparación de igualdad
        resulte como false.
    </p>
    <p>
        El método equals sirve para evitar precisamente eso: para comprobar si dos objetos son
        iguales (tienen los mismos valores en sus atributos), independientemente de que sean objetos
        diferentes. Sin embargo el operador == está comprobando si las referencias son las mismas
        (mismo valor para la referencia o dirección de memoria), es decir si se apunta desde dos
        variables referencia al mismo objeto.
    </p>
    <p>
        Si en el ejemplo anterior, realizamos la siguiente asignación:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>r1= r3;</pre>
        </div>
    </div>
    <p>
        y a continuación volvemos a repetir las comparaciones anteriores:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>System.out.println ("Comparación de objetos rectángulo:");
System.out.println ("Comparación r1 con r2 -> r1.equals(r2): " + r1.equals(r2));
System.out.println ("Comparación r1 con r3 -> r1.equals(r3): " + r1.equals(r3));
System.out.println ("Comparación r2 con r3 -> r2.equals(r3): " + r2.equals(r3));
System.out.println ();
System.out.println ("Comparación de referencias a objetos rectángulo:");
System.out.println ("Comparación r1 con r2 -> r1 == r2: " + (r1 == r2) );
System.out.println ("Comparación r1 con r3 -> r1 == r3: " + (r1 == r3) );
System.out.println ("Comparación r2 con r3 -> r2 == r3: " + (r2 == r3) );</pre>
        </div>
    </div>
    <p>
        deberíamos obtener los siguientes resultados:
    </p>
    <div class="highlighted-code code-style-2 language-latex">
        <div>
         <pre>Comparación de objetos rectángulo:
Comparación r1 con r2 -> r1.equals(r2): true
Comparación r1 con r3 -> r1.equals(r3): true
Comparación r2 con r3 -> r2.equals(r3): true

Comparación de referencias a objetos rectángulo:
Comparación r1 con r2 -> r1 == r2: false
Comparación r1 con r3 -> r1 == r3: true
Comparación r2 con r3 -> r2 == r3: false</pre>
        </div>
    </div>
    <p>
        En este caso las comparaciones entre objetos (uso del método equals) devuelven todas true,
        pues r1 y
        <code>
            r3
        </code>
        en realidad apuntan al mismo rectángulo y el rectángulo al que
        apunta&nbsp;r2 tiene los mismos valores en sus atributos que el rectángulo al que apuntan r1
        y
        <code>
            r3
        </code>
        . Por tanto todos los rectángulos son iguales. Podríamos tener la "ilusión"
        de que existen tres objetos rectángulo aunque en realidad existen sólo dos para los cuales
        hay dos variables referencia que apuntan a uno de ellos (r1 y
        <code>
            r3
        </code>
        ) y una
        variable referencia que apunta al otro (r2).
    </p>
    <p>
        Sin embargo las comparaciones entre las propias referencias (uso del operador ==) algunas
        devuelven true y otras devuelven false:
    </p>
    <ul class="lista_verificacion">
        <li>
            si comparamos&nbsp;r1 y
            <code>
                r3
            </code>
            obtenemos&nbsp;true pues ambas variables
            almacenan la misma dirección de memoria o referencia (una referencia al mismo objeto
            rectángulo);
        </li>
        <li>
            si comparamos&nbsp;r2 con alguna de las otras dos obtenemos false, pues&nbsp;r2 contiene
            una referencia (dirección de memoria) diferente ya que apunta a otro objeto rectángulo.
        </li>
    </ul>
    <p>
        En conclusión:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                el método&nbsp;equals nos indica si dos referencias apuntan a objetos que son
                iguales (tienen los mismos valores, aunque sean objetos distintos)
            </strong>
            ;
            <strong>
            </strong>
        </li>
        <li>
            <strong>
                el operador&nbsp;== nos indica si dos referencias apuntan al mismo
                objeto
            </strong>
            .
        </li>
    </ul>
    <p>
        Lo habitual será por tanto que utilicemos el método equals.
    </p>
</div><h1 class="title">
    5.6.- Métodos estáticos.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>
    </div>
    <p>
        Un
        <strong>
            método estático
        </strong>
        puede ser usado directamente desde la clase sin necesidad
        de hacer referencia a ninguna instancia.
    </p>
    <p>
        Estos métodos también son conocidos como
        <strong>
            métodos de clase
        </strong>
        , frente a los
        <strong>
            métodos de objeto
        </strong>
        o instancia (es necesario un objeto para poder
        invocarlos).
    </p>
    <p>
        <strong>
            Los métodos estáticos no pueden manipular instancias (objetos)
        </strong>
        y suelen ser
        utilizados para realizar operaciones genéricas independientes de las posibles instancias que
        puedan existir de esa clase en un momento concreto. De hecho estos métodos pueden ser
        invocados sin necesidad de que existan objetos de la clase.
    </p>
    <p>
        La manera correcta de invocar a un método estático es escribiendo el nombre de la clase,
        seguido por el operador punto (.) más el nombre del método estático
        <strong>
        </strong>
        :
    </p>
    <div class="highlighted-code language-java">
        <pre>NombreClase.nombreMetodoEstatico();
</pre>
    </div>
    <p>
        En alguna ocasión, es posible que te encuentres con programas donde se haya realizado la
        llamada a un método estático escribiendo el nombre del objeto, seguido por el operador
        punto&nbsp;(.) más el nombre del método estático. Esta forma de invocar a un método estático
        no es apropiada. ¿Por qué? Porque aunque en efecto puede hacerse esa llamada y va a
        funcionar, puede inducir a confusión a quien lea el código. Si se observa una llamada un
        método a partir de un objeto lo normal es pensar que se está llamando a un método de ese
        objeto para que realice operaciones teniendo en cuenta los atributos de ese objeto. Sin
        embargo en el caso de un método estático no es así, pues un método estático jamás podrá
        acceder ni alterar el estado de un objeto.
    </p>
    <p class="destacado" style="text-align: left;">
        <strong>
            Es muy importante que
            <em>
                cualquier
                método estático se invoque siempre referenciado por el nombre de la clase a la que
                pertenece
            </em>
            , justamente para hacer explícito que se trata de un método estático
            sin más que ver la sentencia donde se invoca, quedando claro que hace algo para la
            clase, y no para un objeto particular. Es decir, algo como:
            <br>
            <br>
            <code class="elemento_centrado">
                NombreClase.nombreMetodoEstatico()
            </code>
            <br>
            <br/><br/><br/></strong>
    </p>
    <p>
        En la
        <strong>
            biblioteca de Clases de la
            <abbr title="Application Programming Interface">
                API
            </abbr>
            <span lang="en">
          Java
         </span>
        </strong>
        existen muchas clases que contienen métodos
        estáticos, ya los iremos viendo poco a poco según los vayamos necesitando.
    </p>
    <p>
        Un ejemplo típico de clase con muchos métodos estáticos es la clase Math que se encuentra en
        el paquete&nbsp;java.lang (clase java.lang.Math).
    </p>
    <p>
        Esta clase tiene además la particularidad de que no puede ser instanciada, es decir, que no
        se pueden tener objetos de ella. Por tanto todos sus métodos son obligatoriamente estáticos.
    </p>
    <p style="text-align: center;">
        <span class="destacado">
         Todos los métodos de la clase&nbsp;Math
                                son estáticos.
        </span>
    </p>
    <p>
        Esta clase podemos imaginarla como una especie de "
        <em>
            caja de herramientas
        </em>
        " (
        <em>
         <span lang="en">
          toolbox
         </span>
        </em>
        ) que proporciona una serie de métodos para ser usados
        sin necesidad de objetos instancia de la clase. De hecho es para lo que se utiliza, para
        contener una extensa lista de funciones matemáticas a las que podemos invocar cuando nos
        haga falta.
    </p>
    <p>
        Aquí tienes algunos ejemplos de métodos de la clase (todos estáticos):
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>static double abs(double a)  // Calcula y devuelve el valor absoluto del parámetro
static double cos(double a)  // Calcula y devuelve el coseno trigonométrico del parámetro
static double exp(double a)  // Calcula y devuelve el número e elevado a la potencia indicada por el parámetro
static double log(double a)  // Calcula y devuelve el logaritmo neperiano del parámetro
static double max(double a, double b)  // Calcula y devuelve el máximo de los dos parámetros
static double pow(double a, double b)  // Calcula y devuelve el valor del primer parámetro elevado al segundo
static double sqrt(double a)  // Calcula y devuelve la raíz cuadrada del parámetro
static double random()  // Devuelve un valor aleatorio mayor o igual que 0.0 y menor que 1.0</pre>
        </div>
    </div>
    <p>
        Esta clase también proporciona algunos atributos públicos con algunas de las constantes más
        habituales en matemáticas:
    </p>
    <ul>
        <li>
            la constante "e" de Euler (Math.E);
        </li>
        <li>
            el número pi: π&nbsp; (Math.PI.).
        </li>
    </ul>
    <div class="highlighted-code language-java">
        <div>
         <pre>public static double  E   // El valor aproximado del número e (2,718281828459045)
public static double  PI  // Un valor aproximado de pi (3.141592653589793)
</pre>
        </div>
    </div>
    <p>
        Estos atributos, al igual que los métodos, son también estáticos (tienen existencia y valor
        independientemente de la existencia o no de objetos instancia de la clase) pues todos los
        miembros (métodos y atributos) de la clase&nbsp;Math son estáticos.
    </p>
    <p>
        Aquí tienes algunos ejemplos de uso de estos métodos y atributos estáticos:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Funciones trigonométricas
double angulo = 45.0 * Math.PI/270.0;
System.out.println("cos(" + angulo + ")= " + Math.cos(angulo));

//La función exponencial devuelve el número e elevado a una potencia
System.out.println("exp(10.0)= " + Math.exp(10.0));

// Logaritmo natural (de base e) de un número
System.out.println("log(10.0)= " + Math.log(10.0));
System.out.println("log(Math.E)= " + Math.log(Math.E));

// Elevar 10 a la potencia 2.5
System.out.println("pow(10.0, 2.5)= " +  Math.pow(10.0,2.5));

// Hallar la raíz cuadrada de un número
System.out.println("Raíz cuadrada de 3= " + Math.sqrt(3));</pre>
        </div>
    </div>
    <p>
        La salida por pantalla debería dar algo así:
    </p>
    <div class="highlighted-code code-style-2 language-latex">
        <div>
         <pre>cos(0.5235987755982988)= 0.8660254037844387
exp(10.0)= 22026.465794806718
log(10.0)= 2.302585092994046
log(Math.E)= 1.0
pow(10.0, 2.5)= 316.22776601683796
Raíz cuadrada de 3= 1.7320508075688772</pre>
        </div>
    </div>
    <p>
        Otro ejemplo de clase con miembros estáticos que ya has utilizado es la clase System (de la
        que luego volveremos a hablar en la unidad), que se encuentra en el paquete&nbsp;java.lang y
        que contiene abudantes miembros estáticos. De hecho, al igual que sucede con Math, esta
        clase tampoco puede ser instanciada, así que todos sus miembros son estáticos.
    </p>
    <p>
        Veamos un pequeño ejemplo de acceso a algunos miembros estáticos (atributos y métodos)&nbsp;
        de esta clase:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Hora actual en milisegundos
long horaMiliseg = System.currentTimeMillis() ;
System.out.println("Hora actual en milisegundos: " + horaMiliseg);

// Separador en la ruta de archivos
String separador = System.getProperty("file.separator") ;
System.out.println("Separador de carpetas en las rutas: " + separador);

// Idioma
String idioma = System.getProperty("user.language") ;
System.out.println("Idioma: " + idioma);

// Versión de Java
String versionJava = System.getProperty("java.version") ;
System.out.println("Versión de Java: " + versionJava);
</pre>
        </div>
    </div>
    <p>
        Si ejecutáramos esas líneas, la salida del programa nos mostraría algo parecido a esto
        (dependiendo de las características de vuestro sistema):
    </p>
    <div class="highlighted-code code-style-2 language-latex">
        <div>
         <pre>Hora actual en milisegundos: 1604375707426
Separador de carpetas en las rutas: \
Idioma: es
Versión de Java: 1.8.0_151</pre>
        </div>
    </div>
</div><h1 class="title">
    5.6.1.- Ejemplos: generar números aleatorios.
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-copyright" style="width: 233px;">
    </div>
    <p>
        En Java podemos generar números
        pseudoaleatorio
        s de dos formas:
    </p>
    <ul>
        <li class="lista_verificacion">
            Utilizando el método estático random de la clase Math.
        </li>
        <li class="lista_verificacion">
            Utilizando métodos la clase Random.
        </li>
    </ul>
    <p>
        El método random de la clase&nbsp;Math devuelve un número aleatorio de tipo&nbsp;double mayor
        o igual que
        <strong>
            0.0
        </strong>
        y menor que
        <strong>
            1.0
        </strong>
        .
    </p>
    <p>
        Para generar un número entre 0 y el número que deseemos, basta con hacer un simple cambio de
        escala multiplicando por el factor de escala que necesitemos. Por ejemplo para escalar el
        rango de [0,1[ a [0,25[, podríamos escribir: Math.random()*25. Ésto generaría un número
        entre 0 y 25, donde este último no se incluye. El máximo sería 24,99999…
    </p>
    <p>
        Si lo que queremos generar es un
        <strong>
            número entero
        </strong>
        , entonces debemos truncar el
        resultado anterior quedándonos sólo con la parte entera. Para hacerlo podemos por ejemplo
        realizar un casting o conversión explícita a int:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>(int)(Math.random()*25); // El resultado final es convertido a tipo int</pre>
        </div>
    </div>
    <p>
        En este caso generaremos un número entero aleatorio entre 0 y 25 pero que nunca llegará a ser
        25. Otra forma de hacerlo podría ser mediante el uso del método Math.floor, aunque como este
        método devuelve un número real (double) también tendríamos que volver a hacer una conversión
        explícita si lo que necesitamos es un tipo entero:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>Math.floor((Math.random()*25)); // El resultado final es de tipo double
(int) Math.floor((Math.random()*25)) // El resultado final es convertido a tipo int</pre>
        </div>
    </div>
    <p>
        Aquí tienes un ejemplo del proceso paso a paso:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>double aleatorioReal;
double aleatorioRealEscalado;
int aleatorioEntero1;
int aleatorioEntero2;

aleatorioReal= Math.random();
aleatorioRealEscalado= aleatorioReal*25;
aleatorioEntero1= (int)aleatorioRealEscalado;
aleatorioEntero2= (int) Math.floor (aleatorioRealEscalado);
System.out.println ("Aleatorio real: " + aleatorioReal);
System.out.println ("Aleatorio real escalado al intervalo [0,25[: " + aleatorioRealEscalado);
System.out.println ("Aleatorio entero con casting (int): " + aleatorioEntero1);
System.out.println ("Aleatorio entero con Math.floor: " + aleatorioEntero2);</pre>
        </div>
    </div>
    <p>
        donde el resultado podría ser por ejemplo algo así:
    </p>
    <div class="highlighted-code code-style-2 language-latex">
        <div>
         <pre>Aleatorio real: 0.7318010261640145
Aleatorio real escalado al intervalo [0,25[: 18.295025654100364
Aleatorio entero con casting (int): 18
Aleatorio entero con Math.floor: 18</pre>
        </div>
    </div>
    <p>
        Si quisiéramos también alcanzar el 25, podríamos por ejemplo escalar entre 0 y 26 (25+1):
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>(int)( Math.random() * (25+1) ); // Aleatorio entero entre 0 y 25, ambos incluidos</pre>
        </div>
    </div>
    <p>
        En general, se trataría de sumar 1 al máximo si deseamos que el máximo esté incluido. Por
        ejemplo, si queremos generar aleatorios en el rango&nbsp; [0, N], es decir entre 0 y N,
        donde ambos extremos están incuidos, podríamos hacer algo como:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>(int)( Math.random() * (N+1) ); // Aleatorio entero entre 0 y N, ambos incluidos</pre>
        </div>
    </div>
    <p>
        Otra opción podría ser utilizar el método round de la clase Math, que nos permite redondear
        un número, eso haría que:
    </p>
    <ol>
        <li>
            si el número aleatorio generado y escalado (multiplicado por 25) fuera 24,5 o superior
            (hasta 24,99999...), entonces el resultado final sería 25;
        </li>
        <li>
            el número aleatorio generado y escalado fuera&nbsp;25,499999... o inferior (hasta 24,0),
            entonces el resultadofinal sería 24.
        </li>
    </ol>
    <p>
        La forma de generar el número quedaría entonces así:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>Math.round(Math.random() * N); // Aleatorio entero entre 0 y N, ambos incluidos</pre>
        </div>
    </div>
    <p>
        Si al experimento anterior le añadimos esa línea:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>double aleatorioReal;
double aleatorioRealEscalado;
int aleatorioEntero1;
int aleatorioEntero2;

aleatorioReal= Math.random();
aleatorioRealEscalado= aleatorioReal*25;
aleatorioEntero1= (int)aleatorioRealEscalado;
aleatorioEntero2= (int) Math.floor (aleatorioRealEscalado);
System.out.println ("Aleatorio real: " + aleatorioReal);
System.out.println ("Aleatorio real escalado al intervalo [0,25[: " + aleatorioRealEscalado);
System.out.println ("Aleatorio entero con casting (int): " + aleatorioEntero1);
System.out.println ("Aleatorio entero con Math.floor: " + aleatorioEntero2);
System.out.println ("Aleatorio real escalado y redondeado a entero: " + Math.round(aleatorioRealEscalado));
</pre>
        </div>
    </div>
    <p>
        Podríamos obtener algo así:
    </p>
    <div class="highlighted-code code-style-2 language-latex">
        <div>
         <pre>Aleatorio real: 0.3908175527635215
Aleatorio real escalado al intervalo [0,25[: 9.770438819088037
Aleatorio entero con casting (int): 9
Aleatorio entero con Math.floor: 9
Aleatorio real escalado y redondeado a entero: 10 --> Pasa a 10</pre>
        </div>
    </div>
    <p>
        O bien así:
    </p>
    <div class="highlighted-code code-style-2 language-latex">
        <div>
         <pre>Aleatorio real: 0.688931852993666
Aleatorio real escalado al intervalo [0,25[: 17.223296324841648
Aleatorio entero con casting (int): 17
Aleatorio entero con Math.floor: 17
Aleatorio real escalado y redondeado a entero: 17 --> Se queda en 17</pre>
        </div>
    </div>
    <p>
        Según el número aleatorio generado y escalado este por encima o por debajo del .5.
    </p>
    <p>
        Otra alternativa para generar números aleatorios fácilmente en Java es mediante el uso de la
        clase&nbsp;Random, que se encuentra en el paquete java.util.
    </p>
    <p>
        Para generar números aleatorios con esta clase se debe crear una instancia de la clase
        Random. El algoritmo de generación trabaja con un valor semilla. Si se usa el constructor
        sin parámetro, el valor de la semilla se obtiene del valor de tiempo en nanosegundos que
        maneja la máquina virtual Java, así tenemos dos
        <strong>
            constructores
        </strong>
        en la clase:
    </p>
    <ul>
        <li class="lista_verificacion">
            Random(): crea un nuevo generador aleatorio. En cada
            invocación Java se encarga de que la semilla para generar los números sea siempre
            distinta.
        </li>
        <li class="lista_verificacion">
            Random(long semilla): crea un nuevo generador aleatorio con
            una semilla especificada.
        </li>
    </ul>
    <p>
        La clase clase&nbsp;Random brinda cierta flexibilidad o posibilidades adicionales a
        Math.random, como se puede comprobar en la
        referencia de
        esta clase en la Documentación de la API de Java
        , pues dispone de
        bastantes métodos. Por ejemplo, tenemos disponibles varios métodos para generar números
        aleatorios de tipo int,
        <code>
            long
        </code>
        , double, etcétera.
    </p>
    <ul>
        <li class="lista_verificacion">
            nextBoolean(): devuelve un valor
            <span class="exe-tooltip definition-tt titled-tt">
          pseudoaleatorio
         </span>
            booleano.
        </li>
        <li class="lista_verificacion">
            nextDouble(): devuelve un valor pseudoaleatorio de
            tipo&nbsp;double entre 0.0 y 1.0.
        </li>
        <li class="lista_verificacion">
            nextFloat(): el mismo caso que el anterior pero de tipo
            float.
        </li>
        <li class="lista_verificacion">
            nextInt(): devuelve un pseudoaleatorio de tipo&nbsp;int con
            valores entre 0 y 2
            <sup>
                32
            </sup>
            producidos con aproximadamente la misma probabilidad.
        </li>
        <li class="lista_verificacion">
            nextInt(int n): devuelve un número pseudoaleatorio de
            tipo&nbsp;int comprendido entre cero y el valor especificado (excluido).
        </li>
    </ul>
    <p>
        Aquí tienes un ejemplo de uso de algunos de esos métodos:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>Random objetoRandom= new Random();
System.out.println ("Aleatorio entero con Random: " + objetoRandom.nextInt());
System.out.println ("Otro aleatorio entero con Random: " + objetoRandom.nextInt());
System.out.println ("Aleatorio entero entre 0 y 25 con Random (sin contar el 25): " + objetoRandom.nextInt(25));
</pre>
        </div>
    </div>
    <p>
        Cuyo resultado obviamente es impredecible. Un ejemplo de salida podría ser:
    </p>
    <div class="highlighted-code code-style-2 language-latex">
        <div>
         <pre>Aleatorio entero con Random: -72400602
Otro aleatorio entero con Random: 59409490
Aleatorio entero entre 0 y 25 con Random (sin contar el 25): 19</pre>
        </div>
    </div>
    <p>
    </p>
    <div class="exe-tooltip-text" id="t485db9e3-0054-c98d-d39e-908b6ad00062">
        <p>
            Un generador pseudoaleatorio de números produce una sucesión de números que es una muy
            buena aproximación a un conjunto aleatorio de números
        </p>
    </div>
</div><h1 class="title">
    5.6.2.- Métodos "fábrica" o pseudoconstructores
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-left license-pd" style="width: 180px;">
    </div>
    <p class="lista_verificacion">
        Hemos visto algunos casos de métodos de una clase que devuelven
        como resultado objetos instancia de esa misma clase. En algunas ocasiones puede deberse a
        que se trata de un método que realiza algún tipo de operación entre el objeto cuyo método se
        invoca y los parámetros que recibe, devolviendo un nuevo objeto resultado de esa operación.
        Algunos ejemplos de esto podrían ser los métodos&nbsp;&lt;code&gt;union
        o&nbsp;&lt;code&gt;intersection de la clase&nbsp;&lt;code&gt;Rectangle, que devuelven una
        nuevo recctángulo como resultado de realizar una unión o intersección con otro rectángulo.
        Otro ejemplo podrían ser los&nbsp;métodos concat o
        <code>
            trim
        </code>
        de la clase String que
        permiten concatenar cadenas o eliminar los espacios en blanco en sus extremos. Son métodos
        que no modifican el objeto cambiando sus atributos sino que generan un nuevo objeto con esos
        cambios.
    </p>
    <p class="lista_verificacion">
        En otros casos se trata de un
        <strong>
            método estático
        </strong>
        que
        genera un nuevo objeto de esa clase a partir de ciertos parámetros, como si fuera un
        constructor. Hay quien llama a estos métodos "pseudoconstructores" o métodos "fábrica" pues
        se trata de métodos que "fabrican" o instancian objetos de una manera similar a como lo
        hacen los constructores.
    </p>
    <p>
        Existen algunas clases en la
        <abbr title="Application Programming Interface">
            API
        </abbr>
        de Java que disponen de métodos de
        este tipo. Por ejemplo la
        clase LocalTime, que no tiene constructores públicos sino que proporciona un conjunto de
        métodos estáticos para poder instanciar un objeto de tipo LocalTime. Un poco más adelante,
        en el apartado dedicado al trabajo con horas y fechas, verás algunos ejemplos de uso de esos
        métodos "fábrica" que generan nuevos objetos de tipo LocalDate,
        <code>
            LocalTime
        </code>
        o&nbsp;LocalDateTime como si fueran constructores.
    </p>
</div><h1 class="title">
    5.7.- Clases envoltorio en Java.
</h1>
<div class="iDevice_content">
    <p>
        Como ya has visto anteriormente en el temario, Java usa tipos primitivos, como int o
        <code>
            double
        </code>
        , para contener los tipos de datos básicos admitidos por el lenguaje,
        hacer operaciones con ellos, etc.
        <br>
        <br>
        Pero hay ocasiones en los que necesitaremos
        utilizar un dato representado como un objeto en lugar de como tipo primitivo. Por ejemplo,
        muchas de las estructuras de datos estándar implementadas por Java, y que veremos en temas
        posteriores, operan con objetos, lo que significa que no se puede usar estas estructuras de
        datos para almacenar tipos primitivos. Para gestionar estas situaciones Java proporciona
        <strong>
            envoltorios
        </strong>
        o
        <span lang="en">
         wrappers
        </span>
        de tipo, que son
        <strong>
            clases que encapsulan un tipo primitivo
        </strong>
        dentro de un objeto.
        <br/><br/></p>
    <p>
        Cada tipo primitivo en Java tiene su correspondiente clase envoltorio.
    </p>
    <table class="tabla">
        <caption>
            Clases envoltorio
        </caption>
        <thead>
        <tr>
            <th scope="col">
                Tipo primitivo
            </th>
            <th scope="col">
                Clase envolvotio
            </th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>
                boolean
            </td>
            <td>
                Boolean
            </td>
        </tr>
        <tr>
            <td>
                byte
            </td>
            <td>
                Byte
            </td>
        </tr>
        <tr>
            <td>
                char
            </td>
            <td>
                Character
            </td>
        </tr>
        <tr>
            <td>
                short
            </td>
            <td>
                Short
            </td>
        </tr>
        <tr>
            <td>
                int
            </td>
            <td>
                Integer
            </td>
        </tr>
        <tr>
            <td>
                long
            </td>
            <td>
                Long
            </td>
        </tr>
        <tr>
            <td>
                float
            </td>
            <td>
                Float
            </td>
        </tr>
        <tr>
            <td>
                double
            </td>
            <td>
                Double
            </td>
        </tr>
        </tbody>
    </table>
    <p>
    </p>
    <p>
        En principio, los objetos se construyen pasando el valor al constructor correspondiente. Por
        ejemplo, dado el dato primitivo siguiente:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>int entero = 20;</pre>
        </div>
    </div>
    <p>
        construiríamos un objeto a partir de él:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>Integer oEntero = new Integer(entero); //<strong>de primitivo a objeto se llama boxing</strong>.
int miEntero = oEntero.intValue();     //<strong>de objeto a primitivo se llama unboxing</strong>.</pre>
        </div>
    </div>
    <p>
        Pero estas operaciones complican excesivamente el código. Así que a partir de J2SE 5.0 se
        introdujo una conversión automática (
        <strong>
            autoboxing
        </strong>
        ) que permite asignar y
        obtener los tipos primitivos sin necesidad de utilizar las clases envoltorio.
    </p>
    <p>
        <strong>
            Autoboxing
        </strong>
        es la conversión automática que el compilador de Java hace que
        entre los tipos primitivos y sus clases de objetos. Por ejemplo, la conversión de un int a
        un Integer, un double con un Double, y así sucesivamente. Si la conversión es de objeto a
        dato primitivo entonces se denomina
        <strong>
         <span lang="en">
          Unboxing
         </span>
        </strong>
        .
    </p>
    <p>
        De este modo, podríamos hacer si problema:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>int entero = 20;
Integer oEntero = entero;
</pre>
        </div>
    </div>
    <p>
        O bien simplemente:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>Integer oEntero = 20; </pre>
        </div>
    </div>
    <p>
        Y el compilador hará automáticamente la conversión.
    </p>
</div><h1 class="title">
    5.8.- Representación textual de un objeto en Java: método toString.
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-pd" style="width: 200px;">
    </div>
    <p>
        En Java, toda clase, por el hecho de ser una clase Java, dispone del método
        <span>
         toString
        </span>
        .
    </p>
    <p>
        El propósito de este método es
        <strong>
            asociar a todo objeto un texto representativo de su
            contenido
        </strong>
        . Es decir, que se trata de un método que devuelve una representación
        "textual" del contenido del objeto. Ahora bien, ¿qué formato tendrá esa representación
        textual para cada clase que se escriba en Java? Esa es una cuestión que habrán decidido los
        desarrolladores de cada clase en su momento. Si queremos saber qué aspecto tiene la
        representación textual de los objetos de una clase podemos:
    </p>
    <ol>
        <li>
            consultar la documentación de la clase y observar qué indica acerca de su método
            <span>
          Rectangle
         </span>
            ;
        </li>
        <li>
            hacer un pequeño programa de prueba donde creemos un objeto instancia de esa clase y
            mostremos por pantalla la cadena devuelta por el método
            <span>
          toString
         </span>
            de
            ese objeto.
        </li>
    </ol>
    <p>
        Podemos realizar ambos experimentos con un objeto de la clase
        <span>
         Rectangle
        </span>
        que
        llevamos usando para nuestras pruebas a lo largo de toda la unidad. Si consultamos la
        documentación de la API de Java respecto a la clase

        Rectangle
        , podemos observar la siguiente descripción de su método
        <span>
         toString
        </span>
        :
    </p>
    <div class="exe-figure exe-image position-center license-copyright" style="width: 480px;">
    </div>
    <p>
        En esa descripción nos indica que el método devuelve una cadena (objeto
        <span>
         String
        </span>
        )
        con las coordenadas y tamaño del objeto
        <span>
         Rectangle
        </span>
        . La verdad es que no es mucha
        información pues es lo que podíamos imaginar que haría el método sin necesidad de leer esa
        descripción.
    </p>
    <p>
        Si queremos saber algo más sobre el aspecto que tendrá esa cadena de caracteres, podemos
        optar por hacer un pequeño programa de prueba donde instanciemos un objeto rectángulo y
        mostremos por pantalla la cadena devuelta por el método
        <span>
         toString
        </span>
        :
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Creamos un par de objetos Rectangle y almacenamos sus referencias en sendas variables
// de tipo referencia a Rectangle
Rectangle r1= new Rectangle (1,2, 5, 4);
Rectangle r2= new Rectangle (5,3, 4, 6);
// Mostramos por pantalla la "representación textual" ofrecida por el método toString
System.out.println( "r1= " + r1.toString() );
System.out.println( "r2= " + r2.toString() );</pre>
        </div>
    </div>
    <p>
        El resultado obtenido en este caso tendrá más o menos el siguiente aspecto:
    </p>
    <div class="highlighted-code code-style-2 language-latex">
        <div>
         <pre>r1= java.awt.Rectangle[x=1,y=2,width=5,height=4]
r2= java.awt.Rectangle[x=5,y=3,width=4,height=6]</pre>
        </div>
    </div>
    <p>
        Podemos observar que el formato de la cadena tiene el siguiente aspecto:
    </p>
    <div class="highlighted-code language-latex">
        <div>
            <pre>&lt;nombreClase&gt;[x=&lt;valorX&gt;,y=&lt;valorY&gt;,width=&lt;valorBase&gt;,height=&lt;valorAltura&gt;]</pre>
        </div>
    </div>
    <p>
        donde
        <span>
         &lt;valorX&gt;
        </span>
        ,
        <span>
         &lt;valorY&gt;
        </span>
        ,
        <span>
         &lt;valorBase&gt;
        </span>
        , y
        <span>
         &lt;valorAltura&gt;
        </span>
        son los valores de
        los atributos del objeto rectángulo para cada caso concreto.
    </p>
    <p>
        ¿Para qué me puede servir esta representación textual? Pues por ejemplo para evitarnos tener
        que acceder explícitamente los valores de todos los atributos cada vez que queramos mostrar
        el estado del objeto por pantalla. Es decir, en lugar de hacer como hemos estado haciendo
        hasta el momento:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Mostramos el estado del objeto rectángulo al que apunta r1
System.out.println ("Rectángulo rec1:");
System.out.println ("Ubicación: x=" + rec1.x + " y=" + rec1.y);
System.out.println ("Dimensiones: base= " + rec1.width+ " altura= " + rec1.height);</pre>
        </div>
    </div>
    <p>
        Ahora podemos hacer simplemente:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Mostramos el estado del objeto rectángulo al que apunta r1
System.out.println( "r1= " + r1.toString() );
</pre>
        </div>
    </div>
    <p>
        Es posible que en algunos casos te encuentres con clases que no tengan implementado
        explícitamente el método
        <span>
         toString
        </span>
        . En tal caso, como ya hemos dicho, toda clase
        Java (en realidad cualquier elemento que sea de tipo "referencia") ya dispone de ese método
        implícitamente. Pero si el programador no lo ha reescrito, el resultado textual que devuelve
        es muy "pobre" y tendrá un aspecto parecido a algo como
        <span>
         &lt;nombreClase&gt;&#64;&lt;numero&gt;
        </span>
        (por ejemplo
        <span>
         java.awt.Rectangle&#64;1af7ab3
        </span>
        ). Esa información devuelta es conocida como
        "
        <em>
         <span lang="en">
          hash
         </span>
        </em>
        " y está relacionada con la posición de memoria en la
        que se almacena el objeto. Ésa es la famosa "referencia" (número) que se almacena en las
        variables de tipo referencia y a partir de la cual se consulta en memoria para obtener la
        información sobre el estado del objeto al que apunta (valor de sus atributos).
    </p>
    <p>
        Por último, es importante que sepas que para obtener la representación textual (salida del
        método
        <span>
         toString
        </span>
        ) de un objeto no es necesario llamar explícitamente al método
        <span>
         toString
        </span>
        si por ejemplo lo vas utilizar para mostrarlo en pantalla o
        concatenarlo con otra cadena
    </p>
    <p>
        Por ejemplo, en los casos anteriores podrías haber escrito directamente
        <span>
         System.out.printfln ("r1= " + r1)
        </span>
        . Es decir, que
        <strong>
            si vamos a interpretar
            una variable referencia (objeto) como un String, no es necesario invocar explícitamente
            al método&nbsp;toString
        </strong>
        pues Java lo hará implícitamente por nosotros. En tal
        caso, el código para mostrar el estado de un objeto por pantalla quedaría más simple
        todavía:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Mostramos el estado del objeto rectángulo al que apunta r1
System.out.println( "r1= " + r1 ); // Llamada "implícita" a r1.toString()</pre>
        </div>
    </div>
    <p>
    </p>
</div><h1 class="title">
    6.- Bibliotecas de clases (paquetes).
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        —¡Vaya! -exclama
        <strong>
            María
        </strong>
        - Necesito trabajar con expresiones regulares
        y no consigo encontrar la clase Pattern de la biblioteca de clases de Java.
        ¿Recuerdas dónde está?
    </p>
    <p>
        —Creo que estaba en el paquete java.util.regex, aunque lo mejor es que revises la
        jerarquía de clases que ofrece la API de Java -contesta
        <strong>
            Juan
        </strong>
        -. Se
        trata de un subpaquete que agrupa clases relacionadas entre sí, en este caso las
        relacionadas con las expresiones regulares (Pattern,
        <code>
            Matcher
        </code>
        ,
        <abbr title="etcétera">
            etc.
        </abbr>
        ).
    </p>
    <p>
        . Normalmente las clases se organizan en paquetes e incluso subpaquetes, como en una
        estructura jerárquica de directorios, para facilitar su localización.
    </p>
    <p>
        —Perfecto, ¡ya la veo! Voy a importarla en mi programa para poder usarla -añade
        <strong>
            María.
        </strong>
    </p>
</div><h1 class="title">
    6.1.- Sentencia import.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Cuando queremos utilizar una clase que está en un paquete distinto al paquete en el que se
        encuentra el programa o clase que estamos implementando, se utiliza la sentencia import. Por
        ejemplo, si queremos utilizar la clase Scanner que está en el paquete java.util de la
        Biblioteca de Clases de
        <span lang="en">
         Java
        </span>
        , tendremos que utilizar esta sentencia:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>import java.util.Scanner;</pre>
        </div>
    </div>
    <p>
        Se pueden importar todas las clases de un paquete con una sentencia import. Por ejemplo, para
        importar todas las clases del paquete java.awt, se puede hacer así:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>import java.awt.*;
</pre>
        </div>
    </div>
    <p>
        Es importante aclarar que usando el asterisco, que funciona aquí como "comodín", importamos
        las clases del paquete, pero
        <strong>
            NO se importan las clases de los subpaquetes que
            pudiera tener
        </strong>
        .
    </p>
    <p>
        Las sentencias import (puede haber varias) deben aparecer al principio de la clase, justo
        después de la sentencia package, si ésta existiese.
    </p>
    <p>
        También podemos utilizar una clase sin importarla con la sentencia import, en cuyo caso cada
        vez que queramos usarla debemos indicar su ruta completa:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>java.util.Scanner teclado = new java.util.Scanner (System.in); </pre>
        </div>
    </div>
    <p>
        La sentencia import admite una variante, conocida como import static, la cual permite el uso
        de métodos y atributos estáticos de otras clases directamente, sin tener que especificar el
        nombre de la clase importada en nuestro código.
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>import static java.lang.Math.round;
</pre>
        </div>
    </div>
    <p>
        En el import anterior round es un método de la conocida clase Math. Esto significa que
        podremos usarlo en nuestro código directamente, veamos un ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>public static void main(String[] args)
&#123;
    System.out.println(round(20.2));
&#125;</pre>
        </div>
    </div>
    <p>
        El código anterior mostraría 20 por pantalla.
    </p>
</div><h1 class="title">
    6.2.- Bibliotecas Java.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        Cuando descargamos e instalamos el entorno de compilación y ejecución de
        <span lang="en">
         Java
        </span>
        , también incluimos la
        <abbr title="Application Programming Interface.">
            API
        </abbr>
        de Java. Como ya
        sabemos, se trata de un conjunto de bibliotecas
        que nos proporciona paquetes de clases útiles para nuestros programas.
    </p>
    <p>
        Utilizar las clases y métodos de la Biblioteca de
        <span lang="en">
         Java
        </span>
        nos va a ayudar
        a reducir el tiempo de desarrollo considerablemente, por lo que es importante que aprendamos
        a consultarla y conozcamos las clases más utilizadas.
    </p>
    <p>
        Los paquetes más importantes que ofrece el lenguaje
        <span lang="en">
         Java
        </span>
        son:
    </p>
    <ul class="lista_verificacion">
        <li>
            java.io. Contiene las clases que gestionan la entrada y salida, ya sea para manipular
            ficheros, leer o escribir en pantalla, en memoria,
            <abbr title="etcétera.">
                etc
            </abbr>
            .
            Este paquete contiene por ejemplo la clase BufferedReader que se utiliza para la entrada
            por teclado.
        </li>
        <li>
            java.lang. Contiene las clases básicas del lenguaje. Este paquete no es necesario
            importarlo, ya que es importado automáticamente por el entorno de ejecución. En este
            paquete se encuentra la clase Object, que sirve como raíz para la jerarquía de clases de
            <span lang="en">
          Java
         </span>
            , o la clase System que ya hemos utilizado en algunos
            ejemplos y que representa al sistema en el que se está ejecutando la aplicación. También
            podemos encontrar en este paquete las clases que "envuelven" los tipos primitivos de
            datos, como Integer,
            <code>
                Long
            </code>
            , Float,
            <code>
                Double
            </code>
            ,
            <abbr title="etcétera.">
                etc
            </abbr>
            ., lo que proporciona una serie de métodos para cada
            tipo de dato de utilidad, como por ejemplo&nbsp; métodos para las conversiones de datos.
        </li>
        <li>
            java.util. Biblioteca de clases de utilidad general para el programador. Este paquete
            contiene por ejemplo la clase Scanner utilizada para la entrada por teclado de
            diferentes tipos de datos.
            <abbr>
            </abbr>
            <abbr title="etcétera.">
            </abbr>
        </li>
        <li>
            java.math. Contiene herramientas para trabajar con datos numéricos de mayor precisión
            que la proporcionada por los tipos primitivos tanto para enteros (clase BigInteger) como
            para reales (clase BigDecimal).
        </li>
        <li>
            java.time. Proporciona clases para el trabajo con el tiempo como por ejemplo la clase
            LocalDate, para el tratamiento de fechas o la clase&nbsp;LocalTime para el tramiento de
            horas.
        </li>
        <li>
            java.awt. Incluye las clases relacionadas con la construcción de interfaces de usuario,
            es decir, las que nos permiten construir ventanas, cajas de texto, botones,
            <abbr title="etcétera.">
                etc.
            </abbr>
            Algunas de las clases que podemos encontrar en este
            paquete son Button,
            <code>
                TextField
            </code>
            , Frame,
            <code>
                Label
            </code>
            ,
            <abbr title="etcétera.">
                etc
            </abbr>
            .
        </li>
        <li>
            java.swing. Contiene otro conjunto de clases para la construcción de interfaces
            avanzadas de usuario. Los componentes que se engloban dentro de este paquete se
            denominan componentes Swing, y suponen una alternativa mucho más potente que
            <abbr title="Abstract Window Toolkit.">
                AWT
            </abbr>
            para construir interfaces
            de usuario. Tanto este paquete como el anterior (java.awt) pueden considerarse hoy día
            desfasados y están siendo sustituidos por la tecnología
            <strong>
                JavaFX
            </strong>
            , aunque
            aún podrás ver muchas aplicaciones Java con
            <strong>
                Swing
            </strong>
            y
            <strong>
                AWT
            </strong>
            .
        </li>
        <li>
            java.net. Conjunto de clases para la programación en la red local e Internet.
        </li>
        <li>
            java.sql. Contiene las clases necesarias para programar en
            <span lang="en">
          Java
         </span>
            el acceso a las bases de datos.
        </li>
        <li>
            java.security. Biblioteca de clases para implementar mecanismos de seguridad.
        </li>
    </ul>
    <p>
        Como se puede comprobar,
        <span lang="en">
         Java
        </span>
        ofrece una completa jerarquía de clases
        organizadas a través de paquetes.
    </p>
</div><h1 class="title">
    7.- Programación de la consola: entrada y salida de la información.
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        <strong>
            Juan
        </strong>
        va a realizar algunas pruebas con el proyecto de la Clínica
        Veterinaria. Le comenta a
        <strong>
            María
        </strong>
        que lo que tienen ahora mismo es la
        estructura básica del proyecto, que básicamente se trata de la definición de algunas
        clases y objetos que se van a utilizar. Van a necesitar introducir datos por
        pantalla para ver cómo se comportan esos objetos, y mostrar por pantalla el
        resultado de manipularlos. Para ello utilizarán las clases System y
        <code>
            Scanner
        </code>
        .
    </p>
    <p>
        —Estas clases ya las hemos utilizado anteriormente, están en los paquetes java.lang y
        <code>
            java.util
        </code>
        , respectivamente, observa en el siguiente código cómo las
        utilizo —dice
        <strong>
            Juan
        </strong>
        .
    </p>
    <p>
        —De acuerdo, enséñame ese código —comenta
        <strong>
            María
        </strong>
        .
    </p>
</div><h1 class="title">
    7.1.- Conceptos sobre la clase System.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
    </div>
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>


    </div>
    <p>
        La lectura por teclado es muy importante cuando empezamos a hacer nuestros primeros
        programas. Para entender mejor en qué consiste la clase System, y en particular el objeto
        System.in vamos a describirlo más detenidamente.
    </p>
    <p>
        En el apartado anterior hemos dicho que System.in es un atributo de la clase System, que está
        dentro del paquete java.lang. Pero además, si consultamos la Biblioteca de Clases de
        <span lang="en">
         Java
        </span>
        , nos damos cuenta de que es un objeto, y como todos los objetos
        debe ser instanciado. En efecto, volviendo a consultar la biblioteca de clases nos damos
        cuenta que System.in es una instancia de una clase de
        <span lang="en">
         Java
        </span>
        que se
        llama InputStream.
    </p>
    <p>
        En
        <span lang="en">
         Java
        </span>
        , InputStream nos permite leer en
        <span lang="en">
         bytes
        </span>
        ,
        desde teclado, un archivo o cualquier otro dispositivo de entrada. Con esta clase podemos
        utilizar por ejemplo el método read() que permite leer un
        <span lang="en">
         byte
        </span>
        de la
        entrada o skip(long n), que salta
        <strong>
            n
        </strong>
        <span lang="en">
         bytes
        </span>
        de la
        entrada. Pero lo que realmente nos interesa es poder leer texto o números, no
        <span lang="en">
         bytes
        </span>
        , para hacernos más cómoda la entrada de datos. Para ello se
        utilizan las clases:
    </p>
    <ul class="lista_verificacion">
        <li>
            InputStreamReader. Convierte los
            <span lang="en">
          bytes
         </span>
            leídos en caracteres.
            Particularmente, nos va a servir para convertir el objeto System.in en otro tipo de
            objeto que nos permita leer caracteres.
        </li>
        <li>
            BufferedReader. Lee hasta un fin de línea. Esta es la clase que nos interesa utilizar,
            pues tiene un método readLine() que nos va a permitir leer caracteres hasta el final de
            línea.
        </li>
    </ul>
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>
    </div>
    <p>
        La forma de instanciar estas clases para usarlas con System.in es la siguiente:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>InputStreamReader isr = new InputStreamReader(System.in);

BufferedReader br = new BufferedReader (isr);</pre>
        </div>
    </div>
    <p>
        En el código anterior hemos creado un InputStreamReader a partir de System.in y pasamos dicho
        InputStreamReader al constructor de BufferedReader. El resultado es que las lecturas que
        hagamos con el objeto br son en realidad realizadas sobre System.in, pero con la ventaja de
        que podemos leer una línea completa. Así, por ejemplo, si escribimos una A, con:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>String cadena = br.readLine();</pre>
        </div>
    </div>
    <p>
        Obtendremos en cadena una "A".
    </p>
    <p>
        Sin embargo, seguimos necesitando hacer la conversión si queremos leer números. Por ejemplo,
        si escribimos un entero 32, en cadena obtendremos "32". Si recordamos, para convertir
        cadenas de texto a enteros se utiliza el método estático parseInt() de la clase Integer, con
        lo cual la lectura la haríamos así:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>int numero = Integer.parseInt (br.readLine());</pre>
        </div>
    </div>
    <p>
        Esa operación de conversión de cadena a número sólo funcionará si la cadena introducida
        realmente se puede convertir en número, porque representaba a un literal correcto para el
        tipo numérico de que se trata, en el caso de la sentencia anterior sería int. En caso
        contrario, se produciría una excepción de tipo NumberFormatException, (Excepción de Formato
        de número) que debe ser capturada y tratada convenientemente.
    </p>
</div><h1 class="title">
    7.2.- Entrada por teclado. Clase System.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        A continuación vamos a ver un ejemplo de cómo utilizar la clase System para la entrada de
        datos por teclado en Java.
    </p>
    <p>
        Como ya hemos visto en unidades anteriores, para compilar y ejecutar el ejemplo puedes
        utilizar las órdenes javac y
        <code>
            java
        </code>
        , o bien crear un nuevo proyecto en
        <span lang="en">
         Netbeans
        </span>
        y copiar el código que se proporciona en el archivo anterior.
    </p>
    <div class="elemento_centrado">
        <div class="elemento_centrado">

        </div>
    </div>
    <p class="enlace_centrado">
        Código
        de entrada por teclado con la clase System
        .

    </p>
    <p>
        Observa que hemos metido el código entre excepciones try-catch. Cuando en nuestro programa
        falla algo, por ejemplo la conversión de un String a
        <code>
            int
        </code>
        ,
        <span lang="en">
         Java
        </span>
        nos avisa lanzando excepciones. Si "capturamos" esa excepción en
        nuestro programa, podemos avisar al usuario de qué ha pasado. Esto es conveniente porque si
        no tratamos la&nbsp; excepción seguramente el programa se pare y no siga ejecutándose. El
        control de excepciones lo vemos más detenidamente en el siguiente apartado de la
        unidad.
    </p>
</div><h1 class="title">
    7.3.- Entrada por teclado. Clase Scanner.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
    </div>
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>

    </div>
    <p>
        La entrada por teclado que hemos visto en el apartado anterior tiene el inconveniente de que
        sólo podemos leer de manera fácil tipos de datos String. Si queremos leer otros tipos de
        datos deberemos convertir la cadena de texto leída en esos tipos de datos.
    </p>
    <p>
        El kit de desarrollo de
        <span lang="en">
         Java
        </span>
        , a partir de su versión 1.5, incorpora la
        clase java.util.Scanner, la cual permite leer tipos de datos String,
        <code>
            int
        </code>
        , long,
        <abbr title="etcétera.">
            etc.
        </abbr>
        , a través de la consola de la aplicación. Por ejemplo,
        para leer un dato de tipo entero por teclado sería:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>Scanner teclado = new Scanner (System.in);

int i = teclado.nextInt (); </pre>
        </div>
    </div>
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>
    </div>
    <p>
        O bien esta otra instrucción para leer una línea completa, incluido texto, números o lo
        que sea:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>String cadena = teclado.nextLine();</pre>
        </div>
    </div>
    <p>
        En las instrucciones anteriores hemos creado un objeto de la clase Scanner llamado teclado
        utilizando el constructor de la clase, al cual le hemos pasado como parámetro la entrada
        básica del sistema System.in que por defecto está asociada al teclado.
    </p>
    <p>
        Para conocer cómo funciona un objeto de la clase Scanner te proporcionamos el siguiente
        ejemplo:
    </p>
    <p class="enlace_centrado">
        Código
        de entrada por teclado con la clase Scanner
        .

    </p>
</div><h1 class="title">
    7.4.- Salida por pantalla.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
    </div>
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>


    </div>
    <p>
        La salida por pantalla en
        <span lang="en">
         Java
        </span>
        se hace con el objeto System.out. Este
        objeto es una instancia de la clase PrintStream del paquete java.lang. Si miramos la
        <abbr title="Application Programming Interface.">
         <span lang="en" title="Application Programming Interface.">
          API
         </span>
        </abbr>
        de
        PrintStream obtendremos la variedad de métodos para mostrar datos por pantalla, algunos de
        estos son:
    </p>
    <ul class="lista_verificacion">
        <li>
            void print(String s): escribe una cadena de texto.
        </li>
        <li>
            void println(String x): escribe una cadena de texto y termina la línea.
        </li>
        <li>
            void printf(String format, Object... args): escribe una cadena de texto utilizando
            formato.
        </li>
    </ul>
    <p>
        En la orden print() y
        <code>
            println()
        </code>
        , cuando queramos escribir un mensaje y el valor
        de una variable debemos utilizar el operador de concatenación de cadenas (+), por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>System.out.println(“Bienvenido, “ + nombre);</pre>
        </div>
    </div>
    <p>
        Escribe el mensaje de "Bienvenido, Carlos", si el valor de la variable nombre es Carlos.
    </p>
    <p>
        Las órdenes print() y
        <code>
            println()
        </code>
        consideran como cadenas de texto sin formato a
        todas las variables que escriben; por ejemplo, no sería posible indicar que escriba un
        número decimal con dos cifras decimales o redondear las cifras, o escribir los puntos de los
        miles. Para ello se utiliza la orden printf().
    </p>
    <p>
        La orden printf() utiliza unos códigos de conversión para indicar de qué tipo es el contenido
        a mostrar. Estos códigos se caracterizan porque llevan delante el símbolo %
        <code>
        </code>
        ,
        algunos de ellos son:
    </p>
    <ul class="lista_verificacion">
        <li>
            %c : escribe un carácter.
        </li>
        <li>
            %s : escribe una cadena de texto.
        </li>
        <li>
            %d : escribe un entero.
        </li>
        <li>
            %f : escribe un número en punto flotante.
        </li>
        <li>
            %e : escribe un número en punto flotante en notación científica.
        </li>
    </ul>
    <p>
        Por ejemplo, si queremos escribir el número float 12345.1684 con el punto de los miles y sólo
        dos cifras decimales la orden sería:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>System.out.printf("% ,.2f", 12345.1684);</pre>
        </div>
    </div>
    <p>
        Esta orden mostraría el número 12.345,17 por pantalla.
    </p>
    <p class="destacado">
        Es importante aclarar que estos códigos de conversión formatean la salida,
        mostrándola de una manera o de otra, pero no cambian el valor que internamente tengan las
        variables. Si en el caso anterior, en lugar de imprimir un valor concreto, 12345.1684, se
        hubiera impreso una variable con ese mismo valor, aunque se mostrara su valor como 12.345,17
        por pantalla, la variable seguiría teniendo almacenado el valor 12345.1684
    </p>
    <p>
        Estas órdenes pueden utilizar las secuencias de escape que vimos en unidades anteriores, como
        " " para crear un salto de línea, " " para introducir un salto de tabulación en el texto,
        <abbr title="etcétera.">
            etc
        </abbr>
        .
    </p>
</div><h1 class="title">
    7.5.- Salida de error.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        La salida de error está representada por el objeto System.err. Este objeto es también una
        instancia de la clase PrintStream, por lo que podemos utilizar los mismos métodos vistos
        anteriormente.
    </p>
    <p>
        <span id="result_box" lang="es">
         <span class="hps">
          La separación o diferencia entre la salida
                                    estándar y la de error
         </span>
         <span class="hps">
          se puede utilizar para
         </span>
         <span class="hps">
          redirigir los mensajes
         </span>
         <span class="hps">
          de error
         </span>
         <span class="hps">
          a un lugar diferente
         </span>
         <span class="hps">
          que los mensajes
         </span>
         <span class="hps">
          normales.
         </span>
        </span>
    </p>
    <p>
        Por defecto, tanto out como err tienen su destino en la misma pantalla, o al menos en el caso
        de la consola del sistema donde las dos salidas son representadas con el mismo color y no
        notamos diferencia alguna. En cambio, en la consola de varios entornos integrados de
        desarrollo como
        <span lang="en">
         NetBeans
        </span>
        o
        <span lang="en">
         Eclipse
        </span>
        la salida
        de err se ve en un color diferente. Teniendo el siguiente código:
    </p>
    <div class="elemento_centrado">
        <div class="elemento_centrado">
        </div>
    </div>
    <p>
        La salida de este ejemplo en
        <span lang="en">
         NetBeans
        </span>
        es:
    </p>
    <div class="elemento_centrado">
        <div class="elemento_centrado">
        </div>
    </div>
    <p>
        Como vemos, en un entorno como
        <span lang="en">
         NetBeans
        </span>
        , utilizar las dos salidas nos
        puede ayudar a una mejor depuración del código.
    </p>
    <p>
        Aunque por defecto vemos la salida de error en la consola, es posible redirigirla a un
        fichero por ejemplo, como podemos ver en el siguiente para saber más.
    </p>
</div><h1 class="title">
    8.- Manipulación de la fecha y la hora en Java.
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-CC-BY-SA" style="width: 200px;">
    </div>
    <p>
        <br>
        Java tiene una
        <abbr title="interfaz de programación de aplicaciones">
            API
        </abbr>
        de
        fechas desde el
        <abbr title="Java Development Kit">
            JDK
        </abbr>
        1.1., pero su
        diseño no fue muy afortunado debido a que se demostró que tenía algún que otro problema de
        seguridad y lo más importante, que su uso no era intuitivo. Así, por ejemplo, el mes
        comienza desde
        <strong>
            0
        </strong>
        , cuando intuitivamente el usuario de esta clase tendería a
        pensar intuitivamente que comienza en
        <strong>
            1
        </strong>
        . etc.
        <br>
        <br>
        Posteriormente se
        intentó rectificar con la introducción de la
        <abbr title="interfaz de programación de aplicaciones">
            API
        </abbr>
        <span lang="en">
         Calendar
        </span>
        en el
        <abbr title="Java Development Kit">
            JDK
        </abbr>
        1.4 pero también
        hubo problemas similares.
        <br>
        <br>
        Y finalmente,
        con el
        <abbr title="Java Development Kit">
            JDK
        </abbr>
        8 surgió una
        nueva
        <abbr title="interfaz de programación de aplicaciones">
            API
        </abbr>
        de fecha
        y hora moderna y relativamente fácil de usar.
        <br>
        <br>
        El paquete java.time contiene las
        clases relativas al tiempo (LocalDate,
        <code>
            LocalTime
        </code>
        y LocalDateTime).
        <br>
        El
        paquete&nbsp;java.time.format contiene la clase DateTimeFormatter, por si necesitamos dar
        formato a las fechas. También incluye como el uso de zonas horarios con&nbsp;ZonedDateTime
        y
        <code>
            Period
        </code>
        para determinar el periodo entre dos fechas y&nbsp;Duration para
        determinar la duración entre dos horas.
        <br>
        <br>
        <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/></p>
</div><h1 class="title">
    8.1.- LocalDate
</h1>
<div class="iDevice_content">
    <p>
        Las clases relativas al tiempo en Java utilizan métodos estáticos, que devuelven una
        referencia del tipo de la clase que se ha utilizado para ejecutarlos. Si queremos trabajar
        con fechas podemos usar la clase LocalDate. Veamos un ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>package fechas;

import java.time.LocalDate;

/**
 * Impresión de la fecha
 * &#64;author JJBH
 */
public class Fechas &#123;

    /**
     * &#64;param args the command line arguments
     */
    public static void main(String[] args) &#123;
        LocalDate ahora = LocalDate.now();
        System.out.println(ahora);
    &#125;

&#125;</pre>
        </div>
    </div>
    <p>
        El resultado de ejecutar el programa puede ser algo como:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>run:
2019-09-05
BUILD SUCCESSFUL (total time: 0 seconds)</pre>
        </div>
    </div>
    <p>
        Como ves, la impresión por consola de la fecha nos muestra primero el año, luego el mes y
        después el día, siguiendo la norma
        <abbr title="Organización Internacional de Normalización">
            ISO
        </abbr>
        8601. Más abajo hay un
        enlace a un artículo donde puedes ampliar información sobre esta norma.
    </p>
    <p>
        Puedes crear un LocalDate mediante el uso del método of(int year, int month, int dayOfMonth).
        Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>LocalDate fecha = LocalDate.of(1945, 11, 30) ;</pre>
        </div>
    </div>
    <p>
        crea una fecha correspondiente al 30 de noviembre de 1945. También se puede hacer uso del
        enumerado&nbsp;Month para dar legibilidad al código, de tal modo que ese mismo ejemplo
        podría hacerse así:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>LocalDate fecha = LocalDate.of(1945, Month.NOVEMBER, 30) ;</pre>
        </div>
    </div>
    <p>
        También se puede emplear el método&nbsp;parse para crear un objeto de tipo
        LocalDate
        <code>
        </code>
        a partir de una cadena de texto. Este método admite dos argumentos:
    </p>
    <ul>
        <li class="lista_verificacion">
            El primero es la cadena de texto que quieres transformar en
            un objeto del tipo temporal que quieras.
        </li>
        <li class="lista_verificacion">
            El segundo es el objeto de tipo&nbsp;DateTimeFormatter con el
            que le vas a decir al método&nbsp;parse cómo aparece la fecha expresada en la cadena de
            texto, para que la entienda.
        </li>
    </ul>
    <p>
        Podemos ver un breve ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>import java.time.LocalDate;

/**
 * Ejemplo parse
 * &#64;author Profesor
 */
public class EjemploParse &#123;
    /**
     * &#64;param args the command line arguments
     */
    public static void main(String[] args) &#123;

        // Crea un objeto LocalDate
        LocalDate lt = LocalDate.parse("2019-12-26");

        // Escribe el resultado
        System.out.println("LocalDate : " + lt);
    &#125;

&#125;</pre>
        </div>
    </div>
    <p>
        que dará como resultado:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>run:
LocalDate : 2019-12-26
BUILD SUCCESSFUL (total time: 0 seconds)</pre>
        </div>
    </div>
    <p>
        <br>
        <br>
        <br/><br/></p>
</div><h1 class="title">
    8.2.- LocalTime
</h1>
<div class="iDevice_content">
    <p>
        Similar a la clase LocalDate, cuando necesitamos operar con horas podremos utilizar la clase
        LocalTime. Veamos un ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>import java.time.LocalTime;

/**
 * Ejemplo de uso de LocalTime
 * &#64;author Profe
 */
public class Horas &#123;

    /**
     * &#64;param args the command line arguments
     */
    public static void main(String[] args) &#123;
        // El método of devuelve una nueva instancia de LocalTime con la hora,
        // minutos, segundos y nanosegundos.
        // Se lanza una excepción DateTimeExcepction si se proporciona algún
        // parámetro no válido
        LocalTime hora = LocalTime.of(20, 30, 45, 35);

        System.out.println(hora.toString());

        // Devuelve la instancia de la hora local del reloj del sistema
        System.out.println(LocalTime.now());

    &#125;

&#125;</pre>
        </div>
    </div>
    <p>
        El resultado de ejecutar el programa puede ser algo como:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>run:
20:30:45.000000035
14:55:50.920
BUILD SUCCESSFUL (total time: 0 seconds)</pre>
        </div>
    </div>
    <p>
        que como vemos nos imprime la hora indicada con el método of, y a continuación la hora actual
        mediante el método now().
        <br>
        <br>
        <br/><br/></p>
    <p>
        Al igual que en el caso de LocalDate, se puede emplear el método&nbsp;parse para crear un
        objeto de tipo LocalTime
        <code>
        </code>
        a partir de una cadena de texto.
    </p>
    <p>
        Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>import java.time.LocalTime;

/**
 * Ejemplo parse
 * &#64;author Profesor
 */
public class EjemploParseT &#123;
    /**
     * &#64;param args the command line arguments
     */
    public static void main(String[] args) &#123;

        // Crea un objeto LocalTime
        LocalTime localt = LocalTime.parse("10:25:45");

        // Escribe el resultado
        System.out.println("LocalTime : " + localt);
    &#125;

&#125;</pre>
        </div>
    </div>
    <p>
        que dará como resultado:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>run:
LocalTime : 10:25:45BUILD SUCCESSFUL (total time: 0 seconds)</pre>
        </div>
    </div>
</div><h1 class="title">
    8.3.- LocalDateTime
</h1>
<div class="iDevice_content">
    <p>
        Esta clase se usa para representar la fecha (año, mes, día) junto con la hora (hora, minuto,
        segundo, nanosegundo) y es la combinación de&nbsp;LocalDate y
        <code>
            LocalTime
        </code>
        .
    </p>
    <p>
        En el siguiente ejemplo podemos observar el uso de la clase mediante ejemplos:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

/**
 * Clase de ejmplo para mostrar algunos métodos de la clase LocalDateTime
 * &#64;author JJBH
 */
public class FechayHora &#123;

    /**
     * &#64;param args the command line arguments
     */
    public static void main(String[] args) &#123;

        // Construir un LocalDateTime a partir de un LocalDate y un LocalTime
        LocalDate fecha = LocalDate.of(1989, 10, 21);
        LocalTime hora = LocalTime.now();
        LocalDateTime dateTime = LocalDateTime.of(fecha, hora);
        // Y escribirlo por consola
        System.out.printf("La hora es: %s%n", dateTime.toString());

        // Probamos a sumar y restar.
        LocalDateTime ahora = LocalDateTime.now();
        System.out.printf("La hora es: %s%n", ahora);
        System.out.printf("Hace seis meses sería %s%n", LocalDateTime.now().minusMonths(6));
        System.out.printf("La hora más 20 horas más sería: %s%n", ahora.plusHours(20));
        System.out.printf("Y hace dos días: %s%n", ahora.minusDays(2));
    &#125;

&#125;</pre>
        </div>
    </div>
    <p>
        y el resultado sería:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>run:
La hora es: 1989-10-21T17:36:29.037
La hora es: 2019-09-09T17:36:29.080
Hace seis meses sería 2019-03-09T17:36:29.081
La hora más 20 horas más sería: 2019-09-10T13:36:29.080
Y hace dos días: 2019-09-07T17:36:29.080
BUILD SUCCESSFUL (total time: 0 seconds)</pre>
        </div>
    </div>
    <p>
    </p>
    <p>
        Como puedes ver, hay muchos métodos que nos permiten sumar o restar horas, meses,
        <abbr title="Etcétera">
            etc
        </abbr>
        .
    </p>
    <p>
        Puedes descargar el proyecto a continuación:
    </p>
    <p style="text-align: center;">
        FechaYhora
        <span class="exe-link-data file-size">
         (zip - 17043
         <abbr lang="en" title="Bytes">
          B
         </abbr>
         )
        </span>
        .
    </p>
    <p>
        Al igual que en los casos anteriores, en este caso también podemos usar el método&nbsp;parse
        para crear un objeto de tipo LocalDateTime
        <code>
        </code>
        a partir de una cadena de texto.
    </p>
    <p>
        Por ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>import java.time.LocalDateTime;

/**
 * Ejemplo parse
 * &#64;author Profesor
 */
public class EjemploParseDT &#123;
    /**
     * &#64;param args the command line arguments
     */
    public static void main(String[] args) &#123;

        // Crea un objeto LocalDateTime
        LocalDateTime ltt = LocalDateTime.parse("2020-11-28T19:34:50.63");

        // Escribe resultado
        System.out.println("LocalDateTime : " + ltt);
    &#125;

&#125;</pre>
        </div>
    </div>
    <p>
        que nos ofrecerá como resultado:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>run:
LocalDateTime : 2020-11-28T19:34:50.630
BUILD SUCCESSFUL (total time: 0 seconds)</pre>
        </div>
    </div>
</div><h1 class="title">
    8.4.- Formateado de fechas
</h1>
<div class="iDevice_content">
    <div class="exe-figure exe-image float-right license-copyright" style="width: 200px;">
    </div>
    <p>
        <br>
        Nos puede interesar dar formato a las fechas, y en ese caso usaremos la clase
        DateTimeFormatter.
        <br/></p>
    <p>
        Comentamos anteriormente que la norma
        <abbr title="Organización Internacional de Normalización">
            ISO
        </abbr>
        8601 establece el
        formato predeterminado en las fechas y horas. Esto significa que, al imprimirlas vamos a
        obtener una fecha u hora con este formato.
    </p>
    <p>
        Hay que tener en cuenta lo siguiente, hay unas constantes que podemos usar con la clase y que
        son:
    </p>
    <ul>
        <li class="lista_verificacion">
            ISO_LOCAL_DATE&nbsp;puede utilizarse con LocalDate y
            <code>
                LocalDateTime
            </code>
            (contienen una fecha).
        </li>
        <li class="lista_verificacion">
            ISO_LOCAL_TIME&nbsp;puede utilizarse con LocalTime y
            <code>
                LocalDateTime
            </code>
            (contienen una hora).
        </li>
        <li class="lista_verificacion">
            ISO_LOCAL_DATE_TIME puede utilizarse solo con LocalDateTime
            (contiene una fecha y una hora).
        </li>
    </ul>
    <p>
        Valiéndonos de un ejemplo, veamos algunas cosas:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

/**
 * Probando el formateo en el tiempo, con Java
 * &#64;author jjber
 */
public class Formateando &#123;

    /**
     * &#64;param args the command line arguments
     */
    public static void main(String[] args) &#123;
        LocalDateTime fecha = LocalDateTime.now();

        DateTimeFormatter isoFecha = DateTimeFormatter.ISO_LOCAL_DATE;
        System.out.println("Sin formato: " + fecha);
        System.out.println("Con formato: " + fecha.format(isoFecha));

        DateTimeFormatter isoHora = DateTimeFormatter.ISO_LOCAL_TIME;
        System.out.println(fecha.format(isoHora));

        LocalTime hora = LocalTime.now();
        DateTimeFormatter f = DateTimeFormatter.ofPattern("'Son las' h 'y' mm");
        //System.out.println(hora);
        System.out.println(hora.format(f));


        LocalDateTime otraHora = LocalDateTime.now();
        DateTimeFormatter formato = DateTimeFormatter.ofPattern("hh:MM");
        System.out.println("Hora:mes = " + otraHora.format(formato));
        DateTimeFormatter formato2 = DateTimeFormatter.ofPattern("hh:mm");
        System.out.println("Hora:minutos = " + otraHora.format(formato2));
    &#125;

&#125;
</pre>
        </div>
    </div>
    <p>
        cuyo resultado por consola da:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>run:
Sin formato: 2019-09-09T17:58:10.454
Con formato: 2019-09-09
17:58:10.454
Son las 5 y 58
Hora:mes = 05:09
Hora:minutos = 05:58
BUILD SUCCESSFUL (total time: 0 seconds)</pre>
        </div>
    </div>
    <p>
    </p>
    <p>
        Fíjate en el uso del método&nbsp;ofPattern que acepta un&nbsp;String y permite darle
        cualquier formato a un objeto de tipo LocalDate,
        <code>
            LocalTime
        </code>
        o&nbsp;LocalDateTime (date cuenta cómo si usamos m en minúsculas se refiere a minutos y si
        es en mayúsculas se refiere a mes). En la cadena de texto que utilizamos como patrón puede
        haber letras que simbolizan un elemento temporal. La lista completa podemos verla en
        API de la
        clase
        o texto entre comillas simples, que aparece tal cual al imprimir.
    </p>
    <p>
    </p>
    <p>
        El método&nbsp;parse se utiliza para crear un objeto de tipo
        LocalDate,
        <code>
            LocalTime
        </code>
        o&nbsp;LocalDateTime a partir de una cadena de texto.
        Este método admite dos argumentos:
    </p>
    <ul>
        <li class="lista_verificacion">
            El primero es la cadena de texto que quieres transformar en
            un objeto del tipo temporal que quieras.
        </li>
        <li class="lista_verificacion">
            El segundo es el objeto de tipo&nbsp;DateTimeFormatter con el
            que le vas a decir al método&nbsp;parse cómo aparece la fecha expresada en la cadena de
            texto, para que la entienda.
        </li>
    </ul>
    <p>
        El primer argumento se ha de corresponder con el formato que se vaya a utilizar para
        "traducirlo" a una instancia de alguna clase relativa al tiempo en Java. El
        método&nbsp;parse puede aceptar un único argumento si la cadena de texto se corresponde con
        el formato
        <abbr title="Organización Internacional de Normalización">
            ISO
        </abbr>
        predeterminado.
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 *
 * &#64;author Profesor
 */
public class EjemploParse &#123;
    /**
     * &#64;param args the command line arguments
     */
    public static void main(String[] args) &#123;
        LocalDateTime hora = LocalDateTime.parse("2019-03-27T18:14:01.184");
        DateTimeFormatter formato = DateTimeFormatter.ofPattern("'Hoy es' d 'del mes' M 'del año' yyyy. 'Y son las' kk 'horas'.");
        System.out.println(hora.format(formato));
    &#125;

&#125;</pre>
        </div>
    </div>
    <p>
        que mostrará por consola:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>run:
Hoy es 27 del mes 3 del año 2019. Y son las 18 horas.
BUILD SUCCESSFUL (total time: 0 seconds)</pre>
        </div>
    </div>
    <p>
    </p>
    <p>
    </p>
</div><h1 class="title">
    8.5.- ChronoUnit
</h1>
<div class="iDevice_content">
    <p>
        El enumerado&nbsp;ChronoUnit define las unidades utilizadas para medir el tiempo.
    </p>
    <p>
        Por ejemplo, el método&nbsp;ChronoUnit.between es útil cuando queremos medir una cantidad de
        tiempo en una unidad de tiempo sencilla, como días o segundos. Es decir, trabaja con objetos
        basados en tiempo pero retorna una unidad simple. En el siguiente código podemos ver
        ejemplos de uso:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

/**
 * Ejemplo CronoUnit
 * &#64;author Profe
 */
public class CronoUnit &#123;
    /**
     * &#64;param args the command line arguments
     */
    public static void main(String[] args) &#123;

        // Fecha actual
        LocalDate hoy = LocalDate.now();
        System.out.println("Fecha actual: " + hoy);

        // Añadir una semana a la fecha actual
        LocalDate semanaSig = hoy.plus(1, ChronoUnit.WEEKS);
        System.out.println("Una semana después: " + semanaSig);

        // Añadir un mes a la fecha actual
        LocalDate mesSig = hoy.plus(1, ChronoUnit.MONTHS);
        System.out.println("Un mes después: " + mesSig);

        // Añadir un año
        LocalDate sigYear = hoy.plus(1, ChronoUnit.YEARS);
        System.out.println("Un año después: " + sigYear);

        // Añadir una década
        LocalDate sigDecada = hoy.plus(1, ChronoUnit.DECADES);
        System.out.println("Una década después: " + sigDecada);

    &#125;

&#125;</pre>
        </div>
    </div>
    <p>
        que nos mostrará por consola algo similar a:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>run:
Fecha actual: 2019-09-13
Una semana después: 2019-09-20
Un mes después: 2019-10-13
Un año después: 2020-09-13
Una década después: 2029-09-13
BUILD SUCCESSFUL (total time: 0 seconds)</pre>
        </div>
    </div>
    <p>
        En este ejemplo comentado línea a línea puedes aprender más sobre operaciones con fechas:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>import java.time.LocalDate;
import java.time.Month;
import java.time.Period;
import java.time.temporal.ChronoUnit;

/**
 * CronoUnit ejemplo.
 * &#64;author Profesor
 */
public class EjemplosChrono &#123;
    /**
     * &#64;param args the command line arguments
     */
    public static void main(String[] args) &#123;

        // Fecha del cumpleaños
        LocalDate cumple = LocalDate.of(1982, Month.NOVEMBER, 19);
        // Fecha de hoy
        LocalDate fechaHoy = LocalDate.now();

        // El método withYear devuelve una nueva copia de esta fecha con el
        // campo 'year' cambiado al que se pasa como parámetro.
        LocalDate proximoCumple = cumple.withYear(fechaHoy.getYear());

        // Si tu cumple ha ocurrido ya este año, añadir al año
        if (proximoCumple.isBefore(fechaHoy) || proximoCumple.isEqual(fechaHoy)) &#123;
            proximoCumple = proximoCumple.plusYears(1);
        &#125;

        // Con la clase Period se puede obtener la diferencia entre dos fechas
        // o utilizarlo para modificar valores de alguna fecha
        Period periodo = Period.between(fechaHoy, proximoCumple);

        // Calcular la diferencia entre la feha de hoy y la del próximo cumple
        long per2 = ChronoUnit.DAYS.between(fechaHoy, proximoCumple);
        System.out.println("Faltan " + periodo.getMonths() + " meses, y " +
                   periodo.getDays() + " días hasta tu próximo cumpleaños. (" +
                   per2 + " días en total)");

    &#125;
&#125;</pre>
        </div>
    </div>
    <p>
        que mostrará por consola:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>run:
Faltan 2 meses, y 6 días hasta tu próximo cumpleaños. (67 días en total)
BUILD SUCCESSFUL (total time: 0 seconds)</pre>
        </div>
    </div>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
</div><h1 class="title">
    9.- Excepciones.
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>


    </div>
    <p>
        Para que las aplicaciones desarrolladas por
        <strong>
            BK Programación
        </strong>
        mantengan una valoración positiva a lo largo del tiempo por parte de sus clientes,
        es necesario que éstas no se vean comprometidas durante su ejecución. Hay
        innumerables ocasiones en las que programas que aparentemente son formidables (por
        su interfaz, facilidad de uso,
        <abbr title="etcétera.">
            etc
        </abbr>
        .) comienzan a
        generar errores en tiempo de ejecución que hacen que el usuario desconfíe de ellos
        día a día.
    </p>
    <p>
        Para evitar estas situaciones,
        <strong>
            Ada
        </strong>
        va a fomentar en
        <strong>
            María
        </strong>
        y
        <strong>
            Juan
        </strong>
        la cultura de la detección, control y
        solución de errores a través de las poderosas herramientas que
        <span lang="en">
           Java
          </span>
        les ofrece.
    </p>
</div><h1 class="title">
    9.1.- Capturar una excepción con try.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Para poder capturar excepciones, emplearemos la estructura de captura de excepciones
        try-
        <code>
            catch
        </code>
        -finally.
    </p>
    <p>
        Básicamente, para capturar una excepción lo que haremos será
        <strong>
            declarar bloques de
            código donde es posible que ocurra una excepción.
        </strong>
    </p>
    <p>
        Esto lo haremos mediante un bloque try (intentar). Si ocurre una excepción dentro de estos
        bloques, se lanza una excepción. Estas excepciones lanzadas se pueden capturar por medio de
        bloques catch. Será dentro de este tipo de bloques donde se hará el manejo de las
        excepciones.
    </p>
    <p>
        <strong>
            Su sintaxis es:
        </strong>
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>try&#123;

    código que puede generar excepciones;

&#125;catch (Tipo_excepcion_1 objeto_excepcion)&#123;

    instrucciones para manejar excepción de Tipo_excepcion_1;

&#125;catch (Tipo_excepcion_2 objeto_excepcion)&#123;

    instrucciones para manejar excepción de Tipo_excepcion_2;

&#125;catch (...)&#123;
    ...
&#125;finally&#123;

    instrucciones que se ejecutan siempre

&#125;

</pre>
        </div>
    </div>
    <p>
        En esta estructura, la parte catch puede repetirse tantas veces como excepciones diferentes
        se deseen capturar. La parte finally es opcional y, si aparece, solo podrá hacerlo una sola
        vez.
    </p>
    <p>
        Cada catch maneja un tipo de excepción. Cuando se produce una excepción, se busca el catch
        que posea el manejador de excepción adecuado, será el que utilice el mismo tipo de excepción
        que se ha producido. Esto puede causar problemas si no se tiene cuidado, ya que la clase
        Exception es la superclase de todas las demás. Por lo que si se produjo, por ejemplo, una
        excepción de tipo AritmethicException y el primer catch captura el tipo genérico Exception,
        será ese catch el que se ejecute y no los demás.
    </p>
    <p>
        Por eso el último catch debe ser el que capture excepciones genéricas y los primeros deben
        ser los más específicos. Lógicamente si vamos a tratar a todas las excepciones (sean del
        tipo que sean) igual, entonces basta con un solo catch que capture objetos Exception.
    </p>
    <p>
        En la bibliografía sobre excepciones en
        <span lang="en">
         Java
        </span>
        , frecuentemente se
        cuestiona la utilidad de la cláusula finally, debido a que al ser instrucciones que se
        ejecutan siempre, bien podrían sacarse del bloque de manejo de la excepción. Es cierto que
        finally no aporta la posibilidad de hacer nada que no se pueda conseguir hacer de forma
        igualmente clara sin finally, por lo que en lo que a este curso respecta, su uso queda a
        criterio del gusto de quien programa. Eso sí, hay que saber que existe y cómo funciona.
    </p>
</div><h1 class="title">
    9.2.- El manejo de excepciones con catch.
</h1>
<div class="iDevice_content">
    <p>
        ¿Es obligatorio entonces el manejo de excepciones, o podemos dejar que sea la propia máquina
        virtual en última instancia quien las capture y las trate?
    </p>
    <p>
        Como hemos comentado,
        <strong>
            siempre debemos controlar las excepciones
        </strong>
        que se
        puedan producir o de lo contrario nuestro
        <span lang="en">
         software
        </span>
        quedará expuesto a
        fallos. Que las excepciones las trate la propia máquina virtual, significa haber dejado que
        "ocurra la catástrofe", y que el programa se termine de forma abrupta, lo que nunca es
        deseable.
    </p>
    <p>
        Las excepciones pueden tratarse de dos formas:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Interrupción.
            </strong>
            En este caso se asume que el programa ha encontrado un
            error irrecuperable.
            <strong>
                La operación que dio lugar a la excepción se anula
            </strong>
            y se entiende que no hay manera de regresar al código que provocó la excepción para
            intentar reconducir la situación.
        </li>
        <li>
            <strong>
                Reanudación.
            </strong>
            Se puede manejar el error y regresar de nuevo al código
            que provocó el error.
        </li>
    </ul>
    <p>
        <span lang="en">
         Java
        </span>
        emplea la primera forma, pero puede simularse la segunda mediante
        la utilización de un bloque try en el interior de un while, que se repetirá hasta que el
        error deje de existir. En la siguiente imagen tienes un ejemplo de cómo llevar a cabo esta
        simulación.
    </p>
    <div class="elemento_centrado">
        <div class="elemento_centrado">
            <div class="elemento_centrado">
                <div class="elemento_centrado titulo">
                    Ejemplo de estructura try-catch
                </div>
                <div class="elemento_centrado">

                </div>

            </div>
        </div>
    </div>
    <p>
        En este ejemplo, a través de la función de generación de números aleatorios (de la clase Math
        que incorpora Java), se obtiene el valor del índice i. Con dicho valor se accede a una
        posición del
        <span lang="en">
         array
        </span>
        que contiene cinco cadenas de caracteres. Este
        acceso, a veces puede generar un error del tipo ArrayIndexOutOfBoundsException, que debemos
        gestionar a través de un catch. Al estar el bloque catch dentro de un while, se seguirá
        intentando el acceso hasta que no haya error, momento en que se mostrará el contenido del
        array para el índice elegido, y se terminará la ejecución del ciclo.
    </p>
</div><h1 class="title">
    Condiciones y términos de uso de los materiales
</h1>
<div class="iDevice_content">
    <div title="Información acerca de la licencia de los materiales">
        <p align="center" style="margin: 2px 2px;">
            <strong>
                Materiales desarrollados inicialmente
                por el Ministerio de Educación, Cultura y Deporte y actualizados por el
                profesorado de la Junta de Andalucía bajo licencia Creative Commons
                <abbr title="Reconocimiento-NoComercial-CompartirIgual">
                    BY-NC-SA.
                </abbr>
            </strong>
        </p>
        <p align="center" style="font-size: 0.8em; margin: 2px 2px;">
            <strong>
            </strong>
        </p>
        <p align="center" style="font-size: 0.8em; margin: 2px 2px;">
          <span>
           Antes de cualquier
                                        uso leer detenidamente el siguente
          </span>
            Aviso
            legal
        </p>
    </div>
</div>

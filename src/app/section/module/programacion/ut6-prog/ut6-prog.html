<h1 class="title">
    Utilización avanzada de clases.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        En las últimas semanas,
        <strong>
            María
        </strong>
        y
        <strong>
            Juan
        </strong>
        han avanzado
        muchísimo a lo largo de su recorrido por las
        <strong>
            estructuras de
            almacenamiento
        </strong>
        y el
        <strong>
            desarrollo de clases
        </strong>
        , pero
        <strong>
            María
        </strong>
        es consciente de que aún quedan cosas por ver en lo que respecta a la
        <strong>
            Programación
            Orientada
        </strong>
        <strong>
            a Objetos
        </strong>
        . Aún recuerda que cuando aprendió a
        escribir sus propias clases, con sus
        atributos
        y sus
        métodos
        , se quedaron
        muchos conceptos sin terminar de aclarar y que serían estudiados más adelante:
        utilización de&nbsp; la
        <strong>
            herencia
        </strong>
        , creación&nbsp;
        de
        <strong>
            interfaces
        </strong>
        ,
        clases
        abstractas
        ,
        <strong>
            jerarquías de clases
        </strong>
        ,
        <abbr title="etcétera">
            etc
        </abbr>
        .
    </p>
    <p>
        Ambos saben que faltan unos cuantos conceptos por asimilar y que sin duda les van a
        proporcionar más herramientas a la hora de desarrollar sus proyectos. En realidad,
        muchas de estas nociones ya las han intuido al trabajar con las bibliotecas de clases de
        la
        API
        de Java y en
        cierto modo ya las han utilizado. Parece que ha llegado el momento de formalizar algunos
        de estos conocimientos para poder emplearlos en sus programas.
    </p>
    <div class="exe-tooltip-text" id="t6249e699-8e06-1878-46c5-d87a78ca5a1c">
        <p>
            Una propiedad o información específica contenida en el interior de un objeto.
        </p>
    </div>
    <div class="exe-tooltip-text" id="t61ddf1e3-06b6-9103-b0ab-c635d7454db6">
        <p>
            Elementos de una clase u objeto compuestos por una serie de sentencias que sirven
            para describir las acciones a realizar con esa clase u objeto.
        </p>
    </div>
    <div class="exe-tooltip-text" id="tbee5c04c-d384-6392-9055-5ab068d1b3f2">
        <p>
            Mecanismo mediante el cual una clase puede derivar de otra (clase base, clase padre o
            superclase) de manera que se extiende la funcionalidad de la primera
            (especialización).
        </p>
    </div>
    <div class="exe-tooltip-text" id="t8145f132-8437-7f44-df15-417494bc7d45">
        <p>
            Una interfaz (o interface) en Java es una especie de clase especial donde todos sus
            métodos son declarados como&nbsp;abstract (métodos abstractos). Es misión del
            programador implementar sus correspondientes métodos.
        </p>
    </div>
    <div class="exe-tooltip-text" id="tadfef2b3-fc14-ca44-2d06-b43cce87afa6">
        <p>
            Una clase abstracta en
            <span lang="en">
            Java
           </span>
            es aquella que contiene al menos
            un método abstracto. Para declarar una clase abstracta en Java se utiliza el
            modificador abstract.
        </p>
    </div>
    <div class="exe-tooltip-text" id="t69f59a98-29ba-fe46-96f6-041b1e8b846a">
        <p>
            Una interfaz de programación de aplicaciones o
            <abbr title="Application Programming Interface">
                API
            </abbr>
            (del inglés
            <span lang="en">
            Application Programming Interface
           </span>
            ) consiste en el conjunto de
            clases, interfaces, métodos, funciones, constantes,
            <abbr title="etcétera">
                etc.
            </abbr>
            , que ofrece cierta biblioteca para ser
            utilizado por otro
            <span lang="en">
            software
           </span>
            como una capa de abstracción.
        </p>
    </div>
</div><h1 class="title">
    1.- Relaciones entre clases.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        Cuando estudiaste el concepto de clase, ésta fue descrita como una especie de mecanismo de
        definición (plantillas), en el que se basaría el entorno de ejecución a la hora de construir un
        objeto: un
        <strong>
            mecanismo de definición de objetos
        </strong>
        .
    </p>
    <p>
        Por tanto, a la hora de diseñar un conjunto de clases para modelar el conjunto de información
        cuyo tratamiento se desea automatizar, es importante establecer apropiadamente las posibles
        relaciones que puedan existir entre unas clases y otras.
    </p>
    <p>
        En algunos casos es posible que no exista relación alguna entre unas clases y otras, pero lo más
        habitual es que sí exista: una clase puede ser una
        especialización
        de otra, o bien una
        generalización
        , o una
        clase contiene en su interior objetos de otra, o una clase utiliza a otra,
        <abbr title="etcétera">
            etc
        </abbr>
        . Es decir, que entre unas clases y otras habrá que definir
        cuál es su relación (si es que existe alguna).
    </p>
    <p>
        Se pueden distinguir diversos tipos de relaciones entre clases:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Clientela
            </strong>
            . Cuando una clase utiliza objetos de otra clase (por ejemplo al
            pasarlos como parámetros a través de un método).
        </li>
        <li>
            <strong>
                Composición
            </strong>
            . Cuando alguno de los atributos de una clase es un objeto de
            otra clase.
        </li>
        <li>
            <strong>
                Anidamiento
            </strong>
            . Cuando se definen clases en el interior de otra clase.
        </li>
        <li>
            <strong>
                Herencia
            </strong>
            . Cuando una clase comparte determinadas características con otra
            (clase base), añadiéndole alguna funcionalidad específica (especialización).
        </li>
    </ul>
    <p>
        La relación de
        <strong>
            clientela
        </strong>
        la llevas utilizando desde que has empezado a programar
        en Java, pues desde tu clase principal (clase con método
        <strong>
            main
        </strong>
        ) has estado
        declarando, creando y utilizando objetos de otras clases. Por ejemplo: si utilizas un objeto
        <strong>
            String
        </strong>
        dentro de la clase principal de tu programa, éste será cliente de la
        clase
        <strong>
            String
        </strong>
        (como sucederá con prácticamente cualquier programa que se escriba
        en Java). Es la relación fundamental y más habitual entre clases (la utilización de unas clases
        por parte de otras) y, por supuesto, la que más vas a utilizar tú también. De hecho ya la has
        estado utilizando y lo seguirás haciendo.
    </p>
    <p>
    </p>
    <p>
        La relación de
        <strong>
            composición
        </strong>
        es posible que ya la hayas tenido en cuenta si has
        definido clases que contenían (tenían como atributos) otros objetos en su interior, lo cual es
        bastante habitual. Por ejemplo, si implementas una clase donde alguno de sus atributos es un
        objeto de tipo
        <strong>
            String
        </strong>
        , ya se está produciendo una relación de tipo
        <strong>
            composición
        </strong>
        (tu clase “tiene” un
        <strong>
            String
        </strong>
        , es decir, está compuesta por un objeto
        <strong>
            String
        </strong>
        y por algunos elementos más).
    </p>
    <p>
        La relación de
        <strong>
            anidamiento
        </strong>
        (o
        <strong>
            anidación
        </strong>
        ) es quizá menos
        habitual, pues implica declarar unas clases dentro de otras (
        <strong>
            clases internas
        </strong>
        o
        <strong>
            anidadas
        </strong>
        ). En algunos casos puede resultar útil para tener un nivel más de
        encapsulamiento
        y
        ocultación
        de
        información. Un ejemplo típico de anidamiento es el de las
        <strong>
            clases anónimas
        </strong>
        , que
        suelen utilizarse en en contextos donde hay que definir
        <strong>
            manejadores de eventos
        </strong>
        como puede ser el caso de las
        <strong>
            interfaces gráficas de usuario
        </strong>
        .
    </p>
    <p>
        En el caso de la relación de
        <strong>
            herencia
        </strong>
        se trata de unas clases que derivan de
        otras. Un ejemplo en el que se produce habitualmente es en el caso de los objetos que forman
        parte de las
        <strong>
            interfaces gráficas
        </strong>
        , donde un componente hereda propiedades de sus
        ascendientes. Más delante lo verás al declarar componentes gráficos que hereden de algún otro
        componente (
        <strong>
            JFrame
        </strong>
        ,
        <strong>
            JDialog
        </strong>
        , etc.).
    </p>
    <p>
        Podría decirse que tanto la
        <strong>
            composición
        </strong>
        como la
        <strong>
            anidación
        </strong>
        son
        casos particulares de
        <strong>
            clientela
        </strong>
        , pues en realidad en todos esos casos una clase
        está haciendo uso de otra (al contener atributos que son objetos de la otra clase, al definir
        clases dentro de otras clases, al utilizar objetos en el paso de parámetros, al declarar
        variables locales utilizando otras clases,
        <abbr title="etcétera.">
            etc.
        </abbr>
        ).
    </p>
    <p>
        A lo largo de la unidad, irás viendo distintas posibilidades de implementación de clases haciendo
        uso de todas estas relaciones, centrándonos especialmente en el caso de la
        <strong>
            herencia
        </strong>
        , que es la que permite establecer las relaciones más complejas.
    </p>
    <div class="exe-tooltip-text" id="tba24b69a-5374-7de6-b0fb-87bfc41a4d38">
        <p>
            Relación entre dos clases donde una de ellas (la subclase) es una versión más especializada
            que la otra (la superclase), compartiendo características en común pero añadiendo ciertas
            características específicas que la especializan. El punto de vista inverso sería la
            <strong>
                generalización
            </strong>
            .
        </p>
    </div>
    <div class="exe-tooltip-text" id="t3f6ed979-11db-98b3-9f98-c5d09392ff87">
        <p>
            Relación entre dos clases donde una de ellas (la superclase) es una versión más genérica que
            la otra (la subclase), compartiendo características en común pero sin las propiedades
            específicas que caracterizan a la subclase. El punto de vista inverso sería la
            especialización.
        </p>
    </div>
    <div class="exe-tooltip-text" id="td9561cea-2f16-ad0b-3c1d-ea34ebf05d94">
        <p>
            Consiste en el ocultamiento del estado de un objeto (de sus datos miembro o atributos) de
            manera que sólo se puede cambiar mediante las operaciones (métodos) definidas para ese
            objeto. Cada objeto está aislado del exterior de manera que se protegen los datos contra su
            modificación por quien no tenga derecho a acceder a ellos, eliminando efectos secundarios y
            colaterales no deseados. Este modo de proceder permite que el usuario de una clase pueda
            obviar la implementación de los métodos y propiedades para concentrarse sólo en cómo
            usarlos. Por otro lado se evita que el usuario pueda cambiar su estado de manera imprevista
            e incontrolada.
        </p>
    </div>
    <div class="exe-tooltip-text" id="tf08b236b-902a-debb-e720-c5695a80483a">
        <p>
            Es el efecto que se consigue gracias a la encapsulación: se evita la visibilidad de
            determinados miembros de una clase al resto del código del programa para de ese modo
            comunicarse con los objetos de la clase únicamente a través de su interfaz (métodos).
        </p>
    </div>
</div><h1 class="title">
    1.1.- Composición.
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Cuando en un sistema de información, una determinada entidad A contiene a otra B como una de sus
        partes, se suele decir que se está produciendo una relación de
        <strong>
            composición
        </strong>
        . Es
        decir, el objeto de la clase A contiene a uno o varios objetos de la clase B.
    </p>
    <p>
        Por ejemplo, si describes una entidad
        <strong>
            País
        </strong>
        compuesta por una serie de atributos,
        entre los cuales se encuentra una lista de comunidades autónomas, podrías decir que los objetos
        de la clase
        <strong>
            País
        </strong>
        contienen varios objetos de la clase
        <strong>
            ComunidadAutonoma
        </strong>
        . Por otro lado, los objetos de la clase
        <strong>
            ComunidadAutonoma
        </strong>
        podrían contener como atributos objetos de la clase
        <strong>
            Provincia
        </strong>
        , la cual a su vez
        también podría contener objetos de la clase
        <strong>
            Municipio
        </strong>
        .
    </p>
    <p>
        Como puedes observar, la
        <strong>
            composición
        </strong>
        puede encadenarse todas las veces que sea
        necesario hasta llegar a objetos básicos del lenguaje o hasta tipos primitivos que ya no
        contendrán otros objetos en su interior. Ésta es la forma más habitual de definir clases:
        mediante otras clases ya definidas anteriormente. Es una manera eficiente y sencilla de
        gestionar la reutilización de todo el código ya escrito. Si se definen clases que describen
        entidades distinguibles y con funciones claramente definidas, podrán utilizarse cada vez que
        haya que representar objetos similares dentro de otras clases.
    </p>
    <p class="destacado">
        <strong>
            La
            <em>
                composición
            </em>
            se da cuando una clase contiene algún atributo
            que es una referencia a un objeto de otra clase.
        </strong>
    </p>
    <p>
        Una forma sencilla de plantearte si la relación que existe entre dos clases A y B es de
        <strong>
            composición
        </strong>
        podría ser mediante la expresión idiomática “
        <strong>
            tiene un
        </strong>
        ”: “la clase A tiene uno o
        varios objetos de la clase B”, o visto de otro modo: “Objetos de la clase B pueden formar parte
        de la clase A”.
    </p>
    <p>
        Algunos ejemplos de composición podrían ser:
    </p>
    <ul class="lista_verificacion">
        <li>
            Un
            <strong>
                coche
            </strong>
            tiene un
            <strong>
                motor
            </strong>
            y tiene cuatro
            <strong>
                ruedas
            </strong>
            .
        </li>
        <li>
            Una
            <strong>
                persona
            </strong>
            tiene un
            <strong>
                nombre
            </strong>
            , una
            <strong>
                fecha de
                nacimiento
            </strong>
            , una
            <strong>
                cuenta bancaria
            </strong>
            asociada para ingresar la nómina,
            etc.
        </li>
        <li>
            Un
            <strong>
                cocodrilo
            </strong>
            bajo investigación científica que tiene un número de
            <strong>
                dientes
            </strong>
            determinado, una
            <strong>
                edad
            </strong>
            , unas
            <strong>
                coordenadas
            </strong>
            de ubicación
            geográfica (medidas con
            <abbr title="Global System Positioning.">
                GPS
            </abbr>
            ),
            etc.
        </li>
        <li>
            Una clase
            <strong>
                Rectangulo
            </strong>
            podría contener en su interior dos objetos de la clase
            <strong>
                Punto
            </strong>
            para almacenar los vértices inferior izquierdo y superior derecho.
        </li>
        <li>
            Una clase
            <strong>
                Empleado
            </strong>
            podría contener en su interior un objeto de la clase
            <strong>
                &lt;acronym title="Documento Nacional de Identidad."&gt;DNI&lt;/acronym&gt;
            </strong>
            para almacenar su
            <abbr title="Documento Nacional de Identidad.">
                DNI
            </abbr>
            /
            <abbr title="Número de Identificación Fiscal.">
                NIF
            </abbr>
            , y otro objeto de la clase
            <strong>
                CuentaBancaria
            </strong>
            para guardar la cuenta en la que se realizan los ingresos en
            nómina.
        </li>
        <li>
            Una clase
            <strong>
                JFrame
            </strong>
            (
            <strong>
                javax.Swing.JFrame
            </strong>
            ) de la
            <strong>
                interfaz
                gráfica
            </strong>
            contiene en su interior referencias a objetos de las clases
            <strong>
                JRootPane
            </strong>
            ,
            <strong>
                JMenuBar
            </strong>
            o
            <strong>
                JLayeredPane
            </strong>
            , pues contiene menús, paneles,
            etc.
        </li>
    </ul>
</div><h1 class="title">
    1.2.- Herencia.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        El mecanismo que permite crear clases basándose en otras que ya existen es conocido como
        <strong>
            herencia
        </strong>
        .
        Como ya has visto en unidades anteriores, Java implementa la herencia mediante la utilización de
        la palabra reservada
        <strong>
            extends
        </strong>
        .
    </p>
    <p>
        El concepto de
        <strong>
            herencia
        </strong>
        es algo bastante simple y sin embargo muy potente:
        cuando se desea definir una nueva clase y ya existen clases que, de alguna manera, implementan
        parte de la funcionalidad que se necesita, es posible crear una nueva
        <strong>
            clase
            derivada
        </strong>
        de la que ya tienes. Al hacer esto se posibilita la reutilización de todos
        los atributos y métodos de la clase que se ha utilizado como
        <strong>
            base
        </strong>
        (
        <strong>
            clase
            padre
        </strong>
        o
        <strong>
            superclase
        </strong>
        ), sin la necesidad de tener que escribirlos de
        nuevo.
    </p>
    <p>
        Una
        <strong>
            subclase
        </strong>
        hereda todos los miembros de su
        <strong>
            clase padre
        </strong>
        (atributos, métodos y clases internas). Los
        <strong>
            constructores
        </strong>
        no se heredan, aunque
        se pueden invocar desde la
        <strong>
            subclase
        </strong>
        .
    </p>
    <p>
        Algunos ejemplos de herencia podrían ser:
    </p>
    <ul class="lista_verificacion">
        <li>
            Un
            <strong>
                coche
            </strong>
            es un
            <strong>
                vehículo
            </strong>
            (heredará atributos como la
            <strong>
                velocidad máxima
            </strong>
            o métodos como
            <strong>
                parar
            </strong>
            y
            <strong>
                arrancar
            </strong>
            ).
        </li>
        <li>
            Un
            <strong>
                empleado
            </strong>
            es una
            <strong>
                persona
            </strong>
            (heredará atributos como el
            <strong>
                nombre
            </strong>
            o la
            <strong>
                fecha de nacimiento
            </strong>
            ).
        </li>
        <li>
            Un
            <strong>
                rectángulo
            </strong>
            es una
            <strong>
                figura geométrica
            </strong>
            en el plano
            (heredará métodos como el cálculo de la
            <strong>
                superficie
            </strong>
            o de su
            <strong>
                perímetro
            </strong>
            ).
        </li>
        <li>
            Un
            <strong>
                cocodrilo
            </strong>
            es un
            <strong>
                reptil
            </strong>
            (heredará atributos como por
            ejemplo el
            <strong>
                número de dientes
            </strong>
            ).
        </li>
    </ul>
    <p>
        En este caso la expresión idiomática que puedes usar para plantearte si el tipo de relación entre
        dos clases A y B es de herencia podría ser “
        <strong>
            es un
        </strong>
        ”: “la clase A es un tipo
        específico de la clase B” (
        <strong>
            especialización
        </strong>
        ), o visto de otro modo: “la clase B
        es un caso general de la clase A” (
        <strong>
            generalización
        </strong>
        ).
    </p>
    <p>
        Otros ejemplos de herencia, relacionados con las interfaces gráficas, que veremos más adelante en
        otra unidad, podrían ser:
    </p>
    <ul class="lista_verificacion">
        <li>
            Una
            <strong>
                ventana
            </strong>
            en una
            <strong>
                aplicación gráfica
            </strong>
            puede ser una clase
            que herede de
            <strong>
                JFrame
            </strong>
            (componente
            <strong>
                Swing
            </strong>
            :
            <strong>
                javax.swing.JFrame
            </strong>
            ),
            de esta manera esa clase será un marco que dispondrá de todos los métodos y atributos de
            <strong>
                JFrame
            </strong>
            más aquéllos que tú decidas incorporarle al rellenarlo de
            componentes gráficos.
        </li>
        <li>
            Una
            <strong>
                caja de diálogo
            </strong>
            puede ser un tipo de
            <strong>
                JDialog
            </strong>
            (otro
            componente
            <strong>
                Swing: &lt;strong&gt;javax.swing.JDialog&lt;/strong&gt;
            </strong>
            ).
        </li>
    </ul>
    <p>
        En Java, la clase
        <strong>
            Object
        </strong>
        (dentro del paquete
        <strong>
            java.lang
        </strong>
        ) define
        e implementa el comportamiento común a todas las clases (incluidas aquellas que tú escribas).
        Como recordarás, ya se dijo que en Java cualquier clase deriva en última instancia de la clase
        <strong>
            Object
        </strong>
        .
    </p>
    <p>
        Todas las clases tienen una
        <strong>
            clase padre
        </strong>
        , que a su vez también posee una
        <strong>
            superclase
        </strong>
        ,
        y así sucesivamente hasta llegar a la clase
        <strong>
            Object
        </strong>
        . De esta manera, se
        construye lo que habitualmente se conoce como una
        <strong>
            jerarquía de clases
        </strong>
        , que en
        el caso de Java tendría a la clase
        <strong>
            Object
        </strong>
        en la raíz.
    </p>
    <p>

    </p>
</div><h1 class="title">
    1.3.- ¿Herencia o composición?
</h1>
<div class="iDevice_content">
    <p>
        Cuando escribas tus propias clases, debes intentar tener claro en qué casos utilizar la
        <strong>
            composición
        </strong>
        y cuándo la
        <strong>
            herencia
        </strong>
        :
    </p>
    <p>
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Composición
            </strong>
            : cuando una clase está formada por objetos de otras clases. En
            estos casos se incluyen objetos de esas clases, pero no necesariamente se comparten
            características con ellos (no se heredan características de esos objetos, sino que
            directamente se utilizarán sus atributos y sus métodos). Esos objetos incluidos no son más
            que atributos miembros de la clase que se está definiendo.
        </li>
        <li>
            <strong>
                Herencia
            </strong>
            : cuando una clase cumple todas las características de otra. En
            estos casos la clase derivada es una
            <strong>
                especialización
            </strong>
            (o
            <strong>
                particularización
            </strong>
            ,
            <strong>
                extensión
            </strong>
            o
            <strong>
                restricción
            </strong>
            ) de la clase base. Desde otro
            punto de vista se diría que la clase base es una
            <strong>
                generalización
            </strong>
            de las
            clases derivadas.
        </li>
    </ul>
    <p>
    </p>
    <p>
        Por ejemplo, imagina que dispones de una clase
        <strong>
            Punto
        </strong>
        (ya la has utilizado en
        otras ocasiones) y decides definir una nueva clase llamada
        <strong>
            Círculo
        </strong>
        . Dado que un
        punto tiene como atributos sus coordenadas en plano (
        <strong>
            x1
        </strong>
        ,
        <strong>
            y1
        </strong>
        ),
        decides que es buena idea aprovechar esa información e incorporarla en la clase
        <strong>
            Circulo
        </strong>
        que estás escribiendo. Para ello utilizas la
        <strong>
            herencia
        </strong>
        ,
        de manera que al derivar la clase
        <strong>
            Círculo
        </strong>
        de la clase
        <strong>
            Punto
        </strong>
        ,
        tendrás disponibles los atributos
        <strong>
            x1
        </strong>
        e
        <strong>
            y1
        </strong>
        . Ahora solo faltaría
        añadirle algunos atributos y métodos más como por ejemplo el
        <strong>
            radio
        </strong>
        del círculo,
        el cálculo de su
        <strong>
            área
        </strong>
        y su
        <strong>
            perímetro
        </strong>
        , etc.
    </p>
    <p>
        En principio parece que la idea pueda funcionar pero es posible que más adelante, si continúas
        construyendo una
        <strong>
            jerarquía de clases
        </strong>
        , observes que puedas llegar a conclusiones
        incongruentes al suponer que un círculo es una especialización de un punto (un tipo de punto).
        ¿Todas aquellas figuras que contengan uno o varios puntos deberían ser tipos de punto? ¿Y si
        tienes varios puntos? ¿Cómo accedes a ellos? ¿Un rectángulo también tiene sentido que herede de
        un punto? No parece muy buena idea.
    </p>
    <p>
    </p>
    <p>
        Parece que en este caso habría resultado mejor establecer una relación de
        <strong>
            composición
        </strong>
        . Analízalo detenidamente: ¿cuál de estas dos situaciones te suena
        mejor?
    </p>
    <ol>
        <li>
            “
            <strong>
                Un círculo es un punto
            </strong>
            (su centro)”, y por tanto heredará las coordenadas
            <strong>
                x1
            </strong>
            e
            <strong>
                y1
            </strong>
            que tiene todo punto. Además tendrá otras
            características específicas como el
            <strong>
                radio
            </strong>
            o métodos como el cálculo de la
            <strong>
                longitud
            </strong>
            de su perímetro o el cálculo de su
            <strong>
                área
            </strong>
            .
        </li>
        <li>
            “
            <strong>
                Un círculo tiene un punto
            </strong>
            (su centro)”, junto con algunos atributos más
            como por ejemplo el
            <strong>
                radio
            </strong>
            . También tendrá métodos para el cálculo de su
            <strong>
                área
            </strong>
            o de la longitud de su
            <strong>
                perímetro
            </strong>
            .
        </li>
    </ol>
    <p>
        Parece que en este caso la
        <strong>
            composición
        </strong>
        refleja con mayor fidelidad la relación
        que existe entre ambas clases. Normalmente suele ser suficiente con plantearse las preguntas
        “
        <strong>
            ¿A es un tipo de B?
        </strong>
        ” o“¿
        <strong>
            A contiene elementos de tipo B?
        </strong>
        ”.
    </p>
</div><h1 class="title">
    2.- Composición.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        <strong>
            María
        </strong>
        es consciente de que las relaciones que pueden existir entre dos
        clases pueden ser de
        <strong>
            clientela
        </strong>
        ,
        <strong>
            composición
        </strong>
        ,
        <strong>
            herencia
        </strong>
        ,
        etc. También sabe que una forma muy práctica de distinguir entre la necesidad de una
        composición de un herencia suele ser mediante las preguntas “
        <strong>
            ¿Es la clase A un
            tipo de clase B?
        </strong>
        ” o “¿
        <strong>
            Tiene la clase A elementos de la clase
            B
        </strong>
        ”? Normalmente, ese método le suele funcionar a la hora de decidirse por
        la
        <strong>
            composición
        </strong>
        o por la
        <strong>
            herencia
        </strong>
        .
    </p>
    <p>
        Pero, ¿qué hay que hacer para establecer una relación de composición? ¿Es necesario
        indicar algún modificador al definir las clases? En tal caso, ¿se indicaría en la clase
        continente o en la contenida? ¿Afecta de alguna manera al código que hay que escribir?
        En definitiva, ¿cómo se indica que una clase contiene instancias de otra clase en su
        interior?
    </p>
    <p>
        Mientras
        <strong>
            María
        </strong>
        piensa en voz alta,
        <strong>
            Ada
        </strong>
        se acerca con
        una carpeta en la mano y se la entrega:
    </p>
    <p>
        – “Bueno, aquí tienes algunas clases básicas que nos hacen falta para el proyecto de la
        <strong>
            Clínica Veterinaria
        </strong>
        . A ver qué tal os quedan…”.
    </p>
</div><h1 class="title">
    2.1.- Sintaxis de la composición.
</h1>
<div class="iDevice_content">
    <p>
        Para indicar que una clase contiene objetos de otra clase no es necesaria
        <strong>
            ninguna
            sintaxis especial
        </strong>
        . Cada uno de esos objetos no es más que un atributo y, por tanto,
        debe ser declarado como tal:
    </p>
    <div style="width: 50%; float: right;">
        <div class="elemento_centrado">
            <div class="elemento_derecha">
                <div class="elemento_centrado">
                </div>

            </div>
        </div>
    </div>
    <div class="highlighted-code language-java">
        <div>
         <pre>
             class &lt;nombreClase&gt; &#123;
            [modificadores] &lt;NombreClase1&gt; nombreAtributo1;
            [modificadores] &lt;NombreClase2&gt; nombreAtributo2;
            …
            &#125;
         </pre>
        </div>
    </div>
    <p>
        En unidades anteriores has trabajado con la clase
        <strong>
            Punto
        </strong>
        , que definía las
        coordenadas de un punto en el plano, y con la clase
        <strong>
            Rectangulo,
        </strong>
        que definía una
        figura de tipo rectángulo también en el plano a partir de dos de sus
        <strong>
            vértices
        </strong>
        (
        <strong>
            inferior
            izquierdo
        </strong>
        y
        <strong>
            superior derecho
        </strong>
        ). Tal y como hemos formalizado ahora
        los tipos de relaciones entre clases, parece bastante claro que aquí tendrías un caso de
        <strong>
            composición
        </strong>
        : “
        <strong>
            un rectángulo contiene puntos
        </strong>
        ”. Por tanto,
        podrías ahora redefinir los atributos de la clase
        <strong>
            Rectangulo
        </strong>
        (cuatro
        <strong>
            números
            reales
        </strong>
        ) como dos objetos de tipo
        <strong>
            Punto
        </strong>
        :
    </p>
    <div style="width: 50%; float: right;">
        <div class="elemento_centrado">
            <div class="elemento_derecha">
                <div class="elemento_centrado">
                </div>

            </div>
        </div>
    </div>
    <div class="highlighted-code language-java">
        <div>
         <pre>class Rectangulo &#123;
     private Punto vertice1;
     private Punto vertice2;
…
&#125;</pre>
        </div>
    </div>
    <p>
        Ahora los métodos de esta clase deberán tener en cuenta que ya no hay cuatro atributos de tipo
        <strong>
            double
        </strong>
        , sino dos atributos de tipo
        <strong>
            Punto
        </strong>
        (cada uno de los
        cuales contendrá en su interior dos atributos de tipo
        <strong>
            double
        </strong>
        ).
    </p>
</div><h1 class="title">
    2.2.- Uso de la composición (I). Preservación de la
    ocultación.
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Como ya has observado, la relación de
        <strong>
            composición
        </strong>
        no tiene más misterio a la
        hora de implementarse que simplemente declarar
        <strong>
            atributos
        </strong>
        de las clases que
        necesites dentro de la clase que estés diseñando.
    </p>
    <p>
        Ahora bien, cuando escribas clases que contienen objetos de otras clases (lo cual será lo más
        habitual) deberás tener un poco de precaución con aquellos métodos que devuelvan información
        acerca de los
        <strong>
            atributos
        </strong>
        de la clase (métodos “
        <strong>
            obtenedores
        </strong>
        ” o
        de tipo
        <strong>
         <span lang="en">
          get
         </span>
        </strong>
        ).
    </p>
    <p>
        Como ya viste en la unidad dedicada a la creación de clases, lo normal suele ser declarar los
        <strong>
            atributos
        </strong>
        como
        <strong>
            privados
        </strong>
        (o
        <strong>
            protegidos
        </strong>
        , como
        veremos un poco más adelante) para ocultarlos a los posibles
        <strong>
            clientes
        </strong>
        de la
        clase (otros objetos que en el futuro harán uso de la clase). Para que otros objetos puedan
        acceder a la información contenida en los
        <strong>
            atributos,
        </strong>
        o al menos a una parte de
        ella, deberán hacerlo a través de
        <strong>
            métodos que sirvan de interfaz
        </strong>
        , de manera que
        sólo se podrá tener acceso a aquella información que el creador de la clase haya considerado
        oportuna. Del mismo modo, los
        <strong>
            atributos
        </strong>
        solamente serán modificados desde los
        métodos de la clase, que decidirán cómo y bajo qué circunstancias deben realizarse esas
        modificaciones. Con esa metodología de acceso se tenía perfectamente separada la parte de
        manipulación interna de los atributos de la
        <strong>
            interfaz
        </strong>
        con el exterior.
    </p>
    <p>
        Hasta ahora los métodos de tipo
        <strong>
         <span lang="en">
          get
         </span>
        </strong>
        devolvían
        <strong>
            tipos
            primitivos
        </strong>
        , es decir, copias del contenido (a veces con algún tipo de modificación o de
        formato) que había almacenado en los
        <strong>
            atributos
        </strong>
        , pero los atributos seguían “a
        salvo” como elementos privados de la clase. Pero, a partir de este momento, al tener objetos
        dentro de las clases y no sólo tipos primitivos, es posible que en un determinado momento
        interese devolver un
        <strong>
            objeto completo
        </strong>
        .
    </p>
    <p>
        Ahora bien, cuando vayas a devolver un objeto habrás de obrar con mucha precaución. Si en un
        método de la clase devuelves directamente un objeto que es un atributo, estarás ofreciendo
        directamente una
        <strong>
            referencia
        </strong>
        a un objeto atributo que probablemente has definido
        como privado. ¡De esta forma estás
        <strong>
            volviendo a hacer público un atributo que
            inicialmente era privado
        </strong>
        !
    </p>
    <p>
        Para evitar ese tipo de situaciones (ofrecer al exterior referencias a objetos privados) puedes
        optar por diversas alternativas, procurando siempre evitar la devolución directa de un atributo
        que sea un objeto:
    </p>
    <ul class="lista_verificacion">
        <li>
            Una opción podría ser devolver siempre tipos primitivos.
        </li>
        <li>
            Dado que esto no siempre es posible, o como mínimo poco práctico, otra posibilidad es crear
            un nuevo objeto que sea una copia del atributo que quieres devolver y utilizar ese objeto
            como valor de retorno. Es decir,
            <strong>
                crear una copia del objeto
            </strong>
            especialmente
            para devolverlo. De esta manera, el código cliente de ese método podrá manipular a su antojo
            ese nuevo objeto, pues no será una referencia al atributo original, sino un nuevo objeto con
            el mismo contenido.
        </li>
    </ul>
    <p>
        Por último, debes tener en cuenta que es posible que en algunos casos sí se necesite realmente la
        referencia al atributo original (algo muy habitual en el caso de atributos estáticos). En tales
        casos, no habrá problema en devolver directamente el atributo para que el código llamante
        (cliente) haga el uso que estime oportuno de él.
    </p>
    <p class="destacado">
        <strong>
            Debes evitar por todos los medios la devolución de un atributo que sea
            un objeto (estarías dando directamente una referencia al atributo, visible y manipulable desde
            fuera), salvo que se trate de un caso en el que deba ser así.
        </strong>
    </p>
    <p>
        Para entender estas situaciones un poco mejor, podemos volver al objeto
        <strong>
            Rectangulo
        </strong>
        y observar sus nuevos métodos de tipo
        <strong>
         <span lang="en">
          get
         </span>
        </strong>
        .
    </p>
</div><h1 class="title">
    2.2.1.- Uso de la composición (II). Llamadas a
    constructores.
</h1>
<div class="iDevice_content">
    <p>
        Otro factor que debes considerar, a la hora de escribir clases que contengan como atributos
        objetos de otras clases, es su comportamiento a la hora de instanciarse. Durante el proceso de
        creación de un objeto (
        <strong>
            constructor
        </strong>
        ) de la clase contenedora habrá que tener en
        cuenta también la creación (llamadas a
        <strong>
            constructores
        </strong>
        ) de aquellos objetos que
        son contenidos.
    </p>
    <p class="destacado">
        <strong>
            El constructor de la clase contenedora debe invocar a los constructores
            de las clases de los objetos contenidos.
        </strong>
    </p>
    <p>
    </p>
    <p>
        En este caso hay que tener cuidado con las referencias a
        <strong>
            objetos que se pasan como
            parámetros
        </strong>
        para rellenar el contenido de los atributos. Es conveniente hacer una copia
        de esos objetos y utilizar esas copias para los atributos pues si se utiliza la referencia que
        se ha pasado como parámetro, el código cliente de la clase podría tener acceso a ella sin
        necesidad de pasar por la interfaz de la clase (volveríamos a dejar abierta una
        <strong>
            puerta
            pública
        </strong>
        a algo que quizá sea privado).
    </p>
    <p>
        Además, si el
        <strong>
            objeto parámetro
        </strong>
        que se pasó al
        <strong>
            constructor
        </strong>
        formaba parte de otro objeto, esto podría ocasionar un desagradable efecto colateral si esos
        objetos son modificados en el futuro desde el código cliente de la clase, ya que no sabes de
        dónde provienen esos objetos, si fueron creados especialmente para ser usados por el nuevo
        objeto creado o si pertenecen a otro objeto que podría modificarlos más tarde. Es decir,
        correrías el riesgo de estar “compartiendo” esos objetos con otras partes del código, sin ningún
        tipo de control de acceso y con las nefastas consecuencias que eso podría tener: cualquier
        cambio de ese objeto afectaría a partes del programa supuestamente independientes, que entienden
        ese objeto como suyo.
    </p>
    <p class="destacado">
        <strong>
            En el fondo los objetos no son más que variables de tipo referencia a
            la zona de memoria en la que se encuentra toda la información del objeto en sí mismo. Esto es,
            puedes tener un único objeto y múltiples referencias a él. Pero sólo se trata de un objeto, y
            cualquier modificación desde una de sus referencias afectaría a todas las demás, pues estamos
            hablando del mismo objeto.
        </strong>
    </p>
    <p>
        Recuerda también que sólo se crean objetos cuando se llama a un constructor (uso de
        <strong>
            new
        </strong>
        ). Si realizas asignaciones o pasos de parámetros, no se están copiando o
        pasando copias de los objetos, sino simplemente de las referencias, y por tanto se tratará
        siempre del mismo objeto.
    </p>
    <p>
        Se trata de un efecto similar al que sucedía en los métodos de tipo
        <strong>
         <span lang="en">
          get
         </span>
        </strong>
        , pero en este caso en sentido contrario (en lugar de que
        nuestra clase “regale” al exterior uno de sus atributos objeto mediante una referencia, en esta
        ocasión se “adueña” de un parámetro objeto que probablemente pertenezca a otro objeto y que es
        posible que en el futuro haga uso de él).
    </p>
    <p>
        Para entender mejor estos posibles efectos podemos continuar con el ejemplo de la clase
        <strong>
            Rectangulo
        </strong>
        que contiene en su interior dos objetos de la clase
        <strong>
            Punto
        </strong>
        . En los constructores
        del rectángulo habrá que incluir todo lo necesario para crear dos instancias de la clase
        <strong>
            Punto
        </strong>
        evitando las referencias a parámetros (haciendo copias).
    </p>
</div><h1 class="title">
    2.3.- Clases anidadas o internas.
</h1>
<div class="iDevice_content">
    <p>

    </p>
    <p>
        En algunos lenguajes, es posible definir una clase dentro de otra clase (
        <strong>
            clases
            internas
        </strong>
        ):
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>class ClaseContenedora &#123;
     // Cuerpo de la clase
…
     class ClaseInterna &#123;
          // Cuerpo de la clase interna
…
     &#125;
&#125;</pre>
        </div>
    </div>
    <p>
        Se pueden distinguir varios tipos de
        <strong>
            clases internas
        </strong>
        :
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Clases internas estáticas
            </strong>
            (o
            <strong>
                clases anidadas
            </strong>
            ), declaradas
            con el modificador
            <strong>
                static
            </strong>
            .
        </li>
        <li>
            <strong>
                Clases internas miembro
            </strong>
            , conocidas habitualmente como
            <strong>
                clases
                internas
            </strong>
            . Declaradas al máximo nivel de la clase contenedora y no estáticas.
        </li>
        <li>
            <strong>
                Clases internas locales
            </strong>
            , que se declaran en el interior de un bloque de
            código (normalmente dentro de un método).
        </li>
        <li>
            <strong>
                Clases anónimas
            </strong>
            , similares a las internas locales, pero sin nombre (sólo
            existirá un objeto de ellas y, al no tener nombre, no tendrán constructores). Se suelen usar
            en la
            <strong>
                gestión de eventos
            </strong>
            en las
            <strong>
                interfaces gráficas
            </strong>
            .
        </li>
    </ul>
    <p>
        <span style="font-size: 1em;">
         Aquí tienes algunos ejemplos:
        </span>
    </p>
    <div style="width: 50%; float: right;">
        <div class="elemento_centrado">
        </div>
    </div>
    <div class="highlighted-code language-java">
        <div>
         <pre>class ClaseContenedora &#123;
…
     static class ClaseAnidadaEstatica &#123;
…
     &#125;
     class ClaseInterna &#123;
…
     &#125;</pre>
        </div>
    </div>
    <p>
        Las
        <strong>
            clases anidadas
        </strong>
        , como miembros de una clase que son (miembros de
        <strong>
            claseExterna
        </strong>
        ),
        pueden ser declaradas con los modificadores
        <strong>
            public
        </strong>
        ,
        <strong>
            protected
        </strong>
        ,
        <strong>
            private
        </strong>
        o
        <strong>
            de paquete
        </strong>
        , como el resto de miembros.
    </p>
    <p>
        Las
        <strong>
            clases internas
        </strong>
        (no estáticas) tienen acceso a otros miembros de la clase
        dentro de la que está definida aunque sean privados (se trata en cierto modo de un miembro más
        de la clase), mientras que las anidadas (estáticas) no.
    </p>
    <p>
        Las
        <strong>
            clases internas
        </strong>
        se utilizan en algunos casos para:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Agrupar
            </strong>
            clases que sólo tiene sentido que existan en el entorno de la clase
            en la que han sido definidas, de manera que se oculta su existencia al resto del código.
        </li>
        <li>
            Incrementar el nivel de
            <strong>
                encapsulación
            </strong>
            y
            <strong>
                ocultamiento
            </strong>
            .
        </li>
        <li>
            Proporcionar un
            <strong>
                código fuente más legible y fácil de mantener
            </strong>
            (el código de
            las
            <strong>
                clases internas
            </strong>
            y
            <strong>
                anidadas
            </strong>
            está más cerca de donde es
            usado).
        </li>
    </ul>
    <p>
        En
        <span lang="en">
         Java
        </span>
        es posible definir
        <strong>
            clases internas
        </strong>
        y
        <strong>
            anidadas
        </strong>
        ,
        permitiendo todas esas posibilidades. Aunque para los ejemplos con los que vas a trabajar no las
        vas a necesitar por ahora.
    </p>
</div><h1 class="title">
    3.- Herencia.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        <strong>
            María
        </strong>
        ha estado desarrollando junto con
        <strong>
            Juan
        </strong>
        algunas
        clases para el proyecto de la
        <strong>
            Clínica Veterinaria
        </strong>
        . Hasta el momento
        todo ha ido bien. Han tenido que crear clases que contenían en su interior instancias de
        otras clases (atributos que eran objetos). Han tenido cuidado con los
        <strong>
            constructores
        </strong>
        y las
        <strong>
            referencias
        </strong>
        a los atributos internos y parece que, por ahora,
        todo funciona perfectamente. Pero ahora necesitan aprovechar algunas de las
        características que tienen algunas de las clases que ya han escrito, y no quieren tener
        que volver a escribir todos esos métodos en las nuevas clases.
        <strong>
            María
        </strong>
        sabe que es una ocasión perfecta para utilizar el concepto de herencia:
    </p>
    <p>
        – “Si la clase A tiene características en común (atributos y métodos) con la clase B
        aportando algunas características nuevas, puede decirse que
        <strong>
            la clase A es una
            especialización de la clase B
        </strong>
        , ¿no es así?”. – Le pregunta
        <strong>
            María
        </strong>
        a
        <strong>
            Juan
        </strong>
        .
        <br>
        – “Así es. Es un caso claro de
        <strong>
            herencia
        </strong>
        . La clase A hereda de la clase B”. – Contesta
        <strong>
            Juan
        </strong>
        .
        <br>
        – “De acuerdo. Pues vamos manos a la obra. ¿Cómo indicábamos
        que una clase heredaba de otra? Creo recordar que se usaba la palabra reservada
        <strong>
            extends
        </strong>
        .
        ¿Había que hacer algo más?” – Dice
        <strong>
            María
        </strong>
        con entusiasmo.
        <br>
        – “Parece
        que ha llegado el momento de repasar la sintaxis de la
        <strong>
            herencia
        </strong>
        en
        Java”.
        <br/><br/><br/></p>
</div><h1 class="title">
    3.1.- Sintaxis de la herencia.
</h1>
<div class="iDevice_content">
    <p>
        En Java la
        <strong>
            herencia
        </strong>
        se indica mediante la palabra reservada
        <strong>
            extends
        </strong>
        :
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>[modificador] class ClasePadre &#123;
     // Cuerpo de la clase
     …
&#125;

[modificador] class ClaseHija extends ClasePadre &#123;
// Cuerpo de la clase
…
&#125;</pre>
        </div>
    </div>
    <p>
        Imagina que tienes una clase
        <strong>
            Persona
        </strong>
        que contiene atributos como
        <strong>
            nombre
        </strong>
        ,
        <strong>
            apellidos
        </strong>
        y
        <strong>
            fechaNacimiento
        </strong>
        :
    </p>
    <div style="width: 50%; float: right;">
        <div class="elemento_centrado">

        </div>
    </div>
    <div class="highlighted-code language-java">
        <div>
         <pre>/**
 * Clase que representa a una persona
 */
public class Persona &#123;
     private String nombre;
     private String apellidos;
     private LocalDate fechaNacimiento;
     …
&#125;</pre>
        </div>
    </div>
    <p>

    </p>
    <p>
        Es posible que, más adelante, necesites una clase
        <strong>
            Alumno
        </strong>
        que compartirá esos
        atributos (dado que todo alumno es una persona, pero con algunas características específicas que
        lo
        <strong>
            especializan
        </strong>
        ). En tal caso tendrías la posibilidad de crear una clase
        <strong>
            Alumno
        </strong>
        que repitiera todos esos atributos o bien
        <strong>
            heredar
        </strong>
        de la
        clase
        <strong>
            Persona
        </strong>
        :
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>/**
 * Clase que representa a un alumno
 */
public class Alumno extends Persona &#123;
     private String grupo;
     private double notaMedia;
     …
&#125;</pre>
        </div>
    </div>
    <p>
        A partir de ahora, un objeto de la clase
        <strong>
            Alumno
        </strong>
        contendrá los atributos
        <strong>
            grupo
        </strong>
        y
        <strong>
            notaMedia
        </strong>
        (propios de la clase
        <strong>
            Alumno
        </strong>
        ), pero también
        <strong>
            nombre
        </strong>
        ,
        <strong>
            apellidos
        </strong>
        y
        <strong>
            fechaNacimiento
        </strong>
        (propios
        de su
        <strong>
            clase base
        </strong>
        <strong>
            Persona
        </strong>
        y que por tanto ha heredado).
    </p>
</div><h1 class="title">
    3.2.- Acceso a miembros heredados.
</h1>
<div class="iDevice_content">
    <p>
        Como ya has visto anteriormente, no es posible acceder a miembros
        <strong>
            privados
        </strong>
        de
        una superclase. Para poder acceder a ellos podrías pensar en hacerlos
        <strong>
            públicos
        </strong>
        ,
        pero entonces estarías dando la opción de acceder a ellos a cualquier objeto externo y es
        probable que tampoco sea eso lo deseable. Para ello se inventó el modificador
        <strong>
            protected
        </strong>
        (
        <strong>
            protegido
        </strong>
        ) que permite el
        <strong>
            acceso desde
            clases heredadas
        </strong>
        , pero no desde fuera de las clases (estrictamente hablando, desde
        fuera del
        <strong>
            paquete
        </strong>
        ), que serían como miembros
        <strong>
            privados
        </strong>
        .
    </p>
    <p>
        En la unidad dedicada a la utilización de clases ya estudiaste los posibles modificadores de
        acceso que podía tener un miembro:
        <strong>
            sin modificador
        </strong>
        (acceso
        <strong>
            de
            paquete
        </strong>
        ),
        <strong>
            público
        </strong>
        ,
        <strong>
            privado
        </strong>
        o
        <strong>
            protegido
        </strong>
        . Aquí tienes de nuevo el resumen:
    </p>
    <table class="tabla">
        <caption>
            Cuadro de niveles accesibilidad a los atributos de una clase
        </caption>
        <thead>
        <tr>
            <th scope="col">
            </th>
            <th scope="col">
                Misma clase
            </th>
            <th scope="col">
                <p>
                    Otra clase del
                </p>
                <p>
                    mismo paquete
                </p>
            </th>
            <th scope="col">
                <p>
                    Subclase (aunque sea
                </p>
                <p>
                    de diferente paquete)
                </p>
            </th>
            <th scope="col">
                <p>
                    Otra clase (no subclase)
                </p>
                <p>
                    de diferente paquete
                </p>
            </th>
        </tr>
        </thead>
        <tbody>
        <tr align="center">
            <th scope="row">
                public&lt;code&gt;
            </th>
            <td>
                X
            </td>
            <td>
                X
            </td>
            <td>
                X
            </td>
            <td>
                X
            </td>
        </tr>
        <tr align="center">
            <th scope="row">
                protected
            </th>
            <td>
                X
            </td>
            <td>
                X
            </td>
            <td>
                X
            </td>
            <td>
            </td>
        </tr>
        <tr align="center">
            <th scope="row">
                Sin modificador (paquete)
            </th>
            <td>
                X
            </td>
            <td>
                X
            </td>
            <td>
            </td>
            <td>
            </td>
        </tr>
        <tr align="center">
            <th scope="row">
                private
            </th>
            <td>
                X
            </td>
            <td>
            </td>
            <td>
            </td>
            <td>
            </td>
        </tr>
        </tbody>
    </table>
    <p>
    </p>
    <p>
        Si en el ejemplo anterior de la clase
        <strong>
            Persona
        </strong>
        se hubieran definido sus atributos
        como
        <strong>
            private
        </strong>
        :
    </p>
    <div style="width: 50%; float: right;">
        <div class="elemento_centrado">

        </div>
    </div>
    <div class="highlighted-code language-java">
        <div>
         <pre>public class Persona &#123;
     private String nombre;
     private String apellidos;
     …
&#125;</pre>
        </div>
    </div>
    <p>
        Al definir la clase
        <strong>
            Alumno
        </strong>
        como heredera de
        <strong>
            Persona
        </strong>
        , no habrías
        tenido acceso a esos atributos, pudiendo ocasionar un grave problema de operatividad al intentar
        manipular esa información. Por tanto, en estos casos lo más recomendable habría sido declarar
        esos atributos como
        <strong>
            protected
        </strong>
        :
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>public class Persona &#123;
     protected String nombre;
     protected String apellidos;
     …
&#125;</pre>
        </div>
    </div>
</div><h1 class="title">
    3.3.- Utilización de miembros heredados (I). Atributos.
</h1>
<div class="iDevice_content">
    <p>
        Los
        <strong>
            atributos heredados
        </strong>
        por una clase son, a efectos prácticos, iguales que
        aquellos que sean definidos específicamente en la nueva
        <strong>
            clase derivada
        </strong>
        .
    </p>
    <p>
        En el ejemplo anterior la clase
        <strong>
            Persona
        </strong>
        disponía de tres atributos y la clase
        <strong>
            Alumno
        </strong>
        , que heredaba de ella, añadía dos atributos más. Desde un punto de vista
        funcional podrías considerar que la clase
        <strong>
            Alumno
        </strong>
        tiene cinco atributos: tres
        por ser
        <strong>
            Persona
        </strong>
        (
        <strong>
            nombre
        </strong>
        ,
        <strong>
            apellidos
        </strong>
        ,
        <strong>
            fechaNacimiento
        </strong>
        )
        y otros dos más por ser
        <strong>
            Alumno
        </strong>
        (
        <strong>
            grupo
        </strong>
        y
        <strong>
            notaMedia
        </strong>
        ).
    </p>
    <p>

    </p>
</div><h1 class="title">
    3.3.1- Utilización de miembros heredados (II). Métodos.
</h1>
<div class="iDevice_content">
    <p>
        Del mismo modo que se heredan los
        <strong>
            atributos
        </strong>
        , también se heredan los
        <strong>
            métodos
        </strong>
        ,
        convirtiéndose a partir de ese momento en otros
        <strong>
            métodos
        </strong>
        más de la
        <strong>
            clase
            derivada
        </strong>
        , junto a los que hayan sido definidos específicamente.
    </p>
    <p>
        En el ejemplo de la clase
        <strong>
            Persona
        </strong>
        , si dispusiéramos de métodos
        <strong>
         <span lang="en">
          get
         </span>
        </strong>
        y
        <strong>
         <span lang="en">
          set
         </span>
        </strong>
        para cada uno de
        sus tres atributos (
        <strong>
            nombre
        </strong>
        ,
        <strong>
            apellidos
        </strong>
        ,
        <strong>
            fechaNacimiento
        </strong>
        ), tendrías seis métodos que podrían ser heredados por sus
        <strong>
            clases derivadas
        </strong>
        . Podrías decir entonces que la clase
        <strong>
            Alumno
        </strong>
        ,
        derivada de
        <strong>
            Persona
        </strong>
        , tiene diez métodos:
    </p>
    <ul class="lista_verificacion">
        <li>
            <p>
                Seis por ser
                <strong>
                    Persona
                </strong>
                (
                <strong>
                    getNombre
                </strong>
                ,
                <strong>
                    getApellidos
                </strong>
                ,
                <strong>
                    getFechaNacimiento
                </strong>
                ,
                <strong>
                    setNombre
                </strong>
                ,
                <strong>
                    setApellidos
                </strong>
                ,
                <strong>
                    setFechaNacimiento
                </strong>
                ).
            </p>
        </li>
        <li>
            <p>
                Oros cuatro más por ser
                <strong>
                    Alumno
                </strong>
                (
                <strong>
                    getGrupo
                </strong>
                ,
                <strong>
                    setGrupo
                </strong>
                ,
                <strong>
                    getNotaMedia
                </strong>
                ,
                <strong>
                    setNotaMedia
                </strong>
                ).
            </p>
        </li>
    </ul>
    <p>
        Sin embargo, sólo tendrías que definir esos cuatro últimos (los
        <strong>
            específicos
        </strong>
        )
        pues los
        <strong>
            genéricos
        </strong>
        ya los has heredado de la
        <strong>
            superclase
        </strong>
        .
    </p>
    <p>

    </p>
</div><h1 class="title">
    3.4.- Redefinición de métodos heredados.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        Una clase puede
        <strong>
            redefinir
        </strong>
        algunos de los métodos que ha heredado de su
        <strong>
            clase
            base
        </strong>
        . En tal caso, el nuevo método (
        <strong>
            especializado
        </strong>
        ) sustituye al
        <strong>
            heredado
        </strong>
        . Este procedimiento también es conocido como de
        <strong>
            sobrescritura
            de métodos
        </strong>
        .
    </p>
    <p>
        En cualquier caso, aunque un método sea
        <strong>
            sobrescrito
        </strong>
        o
        <strong>
            redefinido
        </strong>
        , aún es posible acceder a él a través de la referencia
        <strong>
            super
        </strong>
        , aunque sólo se podrá acceder a métodos de la
        <strong>
            clase
            padre
        </strong>
        y no a métodos de clases superiores en la
        <strong>
            jerarquía de
            herencia
        </strong>
        .
    </p>
    <p>
        Los
        <strong>
            métodos redefinidos
        </strong>
        pueden
        <strong>
            ampliar su accesibilidad
        </strong>
        con
        respecto a la que ofrezca el método original de la
        <strong>
            superclase
        </strong>
        , pero
        <strong>
            nunca
            restringirla
        </strong>
        . Por ejemplo, si un método es declarado como
        <strong>
            protected
        </strong>
        o
        <strong>
            de paquete
        </strong>
        en la clase base, podría ser redefinido
        como
        <strong>
            public
        </strong>
        en una clase derivada.
    </p>
    <p class="destacado">
        <strong>
            Los
            <em>
                métodos estáticos
            </em>
            o de clase no pueden ser sobrescritos.
            Los originales de la clase base permanecen inalterables a través de toda la
            <em>
                jerarquía de
                herencia
            </em>
            .
        </strong>
    </p>
    <p>
        En el ejemplo de la clase
        <strong>
            Alumno
        </strong>
        , podrían redefinirse algunos de los métodos
        heredados. Por ejemplo, imagina que el método
        <strong>
            getApellidos
        </strong>
        devuelva la cadena
        “Alumno:” junto con los apellidos del alumno. En tal caso habría que rescribir ese método para
        que realizara esa modificación:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>public String getApellidos () &#123;
     return “Alumno: “ + apellidos;
&#125;</pre>
        </div>
    </div>
    <p>
        Cuando sobrescribas un método heredado en
        <span lang="en">
         Java
        </span>
        puedes incluir la
        <strong>
            anotación
        </strong>
        <strong>
            &#64;Override
        </strong>
        . Esto indicará al compilador que tu intención es
        <strong>
            sobrescribir
            el método de la clase padre
        </strong>
        . De este modo, si te equivocas (por ejemplo, al
        escribir el nombre del método) y no lo estás realmente sobrescribiendo, el compilador producirá
        un error y así podrás darte cuenta del fallo. En cualquier caso, no es necesario indicar
        <strong>
            &#64;Override
        </strong>
        , pero puede resultar de ayuda a la hora de localizar este tipo de
        errores (crees que has sobrescrito un
        <strong>
            método heredado
        </strong>
        y al confundirte en una
        letra estás realmente creando un nuevo método diferente). En el caso del ejemplo anterior
        quedaría:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>&#64;Override
public String getApellidos ()</pre>
        </div>
    </div>
</div><h1 class="title">
    3.5.- Ampliación de métodos heredados.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        Hasta ahora, has visto que para
        <strong>
            redefinir
        </strong>
        o
        <strong>
            sustituir
        </strong>
        un
        <strong>
            método
        </strong>
        de una
        <strong>
            superclase
        </strong>
        es suficiente con crear otro método
        en la
        <strong>
            subclase
        </strong>
        que tenga el mismo nombre que el método que se desea
        <strong>
            sobrescribir
        </strong>
        .
        Pero, en otras ocasiones, puede que lo que necesites no sea sustituir completamente el
        comportamiento del método de la superclase, sino simplemente
        <strong>
            ampliarlo
        </strong>
        .
    </p>
    <p>
        Para poder hacer esto necesitas poder
        <strong>
            preservar el comportamiento antiguo
        </strong>
        (el de
        la
        <strong>
            superclase
        </strong>
        ) y
        <strong>
            añadir el nuevo
        </strong>
        (el de la
        <strong>
            subclase
        </strong>
        ). Para ello, puedes invocar desde el método
        “
        <strong>
            ampliador
        </strong>
        ” de la
        <strong>
            clase derivada
        </strong>
        al método
        “
        <strong>
            ampliado
        </strong>
        ” de la clase superior (teniendo ambos métodos el mismo nombre). ¿Cómo
        se puede conseguir eso? Puedes hacerlo mediante el uso de la referencia
        <strong>
            super
        </strong>
        .
    </p>
    <p>
        La palabra reservada
        <strong>
            super
        </strong>
        es una referencia a la
        <strong>
            clase padre
        </strong>
        de la clase en la que te encuentres en cada momento (es algo similar a
        <strong>
            this
        </strong>
        ,
        que representaba una referencia a la
        <strong>
            clase actual
        </strong>
        ). De esta manera, podrías
        invocar a cualquier método de tu
        <strong>
            superclase
        </strong>
        (si es que se tiene acceso a él).
    </p>
    <p>
        Por ejemplo, imagina que la clase
        <strong>
            Persona
        </strong>
        dispone de un método que permite
        mostrar el contenido de algunos datos personales de los objetos de este tipo
        (
        <strong>
            nombre
        </strong>
        ,
        <strong>
            apellidos
        </strong>
        , e
        <abbr title="etcétera">
            tc.
        </abbr>
        ). Por
        otro lado, la clase
        <strong>
            Alumno
        </strong>
        también necesita un método similar, pero que muestre
        también su información especializada (
        <strong>
            grupo
        </strong>
        ,
        <strong>
            nota media
        </strong>
        ,
        <abbr title="etcétera">
            etc.
        </abbr>
        ). ¿Cómo podrías aprovechar el método de la
        <strong>
            superclase
        </strong>
        para no tener que volver a escribir su contenido en la subclase?
    </p>
    <p>
        Podría hacerse de una manera tan sencilla como la siguiente:
    </p>
    <div class="highlighted-code language-java hightlight-13">
        <div>
         <pre>/**
 * Representación en forma de String del contenido del objeto Alumno
 * Aprovecha el método toString de la clase Persona mediante una llamada a
 * super.toString(). Es decir, se está ampliando la funcionalidad de la clase
 * Persona.
 * &#64;return
*/
&#64;Override
public String toString () &#123;
    StringBuilder resultado;

    // Llamada al método “toString” de la superclase
    resultado= new StringBuilder (super.toString());

    // A continuación añadimos la información “especializada” de esta subclase
    resultado.append("\⁣n");
    resultado.append ("Grupo: ").append(this.grupo).append("\⁣n");
    resultado.append ("Nota media: ").append(String.format("%6.2f", this.notaMedia));

    return resultado.toString();
&#125;</pre>
        </div>
    </div>
    <p>
        Este tipo de
        <strong>
            ampliaciones de métodos
        </strong>
        resulta especialmente útil en el caso de
        los
        <strong>
            constructores
        </strong>
        , donde se podría ir llamando a los
        <strong>
            constructores
        </strong>
        de cada
        <strong>
            superclase
        </strong>
        encadenadamente hasta el
        <strong>
            constructor
        </strong>
        de la clase en la
        <strong>
            cúspide de la jerarquía
        </strong>
        (el
        <strong>
            constructor
        </strong>
        de la clase
        <strong>
            Object
        </strong>
        ). En el caso de los
        constructores se usa directamente el método super() para invocar al constructor de la
        superclase.
    </p>
    <p>
        El ejemplo anterior para el método toString() sirve para proporcionar una representación como
        String de los objetos de la clase. La parte que convierte en cadena los atributos comunes de la
        superclase la haría el método toString() de la superclase, por lo que dentro del método
        toString() de la subclase lo invocaríamos como super.toString(), y a la cadena que devuelve, le
        añadiríamos la conversión en cadena de los atributos específicos de la subclase.
    </p>
</div><h1 class="title">
    3.6.- Constructores y herencia.
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Recuerda que cuando estudiaste los
        <strong>
            constructores
        </strong>
        viste que un
        <strong>
            constructor
        </strong>
        de una clase puede llamar a otro
        <strong>
            constructor
        </strong>
        de la misma clase, previamente
        definido, a través del método
        <strong>
            this()
        </strong>
        . En estos casos, la utilización de
        <strong>
            this()
        </strong>
        sólo podía hacerse en la primera línea de código del
        <strong>
            constructor
        </strong>
        .
    </p>
    <p>
        Como ya has visto, un
        <strong>
            constructor
        </strong>
        de una
        <strong>
            clase derivada
        </strong>
        puede
        hacer algo parecido para llamar al
        <strong>
            constructor
        </strong>
        de su
        <strong>
            clase
            base
        </strong>
        mediante el uso del método
        <strong>
            super()
        </strong>
        . De esta manera, el
        <strong>
            constructor
        </strong>
        de una
        <strong>
            clase derivada
        </strong>
        puede llamar primero al
        <strong>
            constructor
        </strong>
        de su
        <strong>
            superclase
        </strong>
        para que inicialice los
        <strong>
            atributos
            heredados
        </strong>
        y posteriormente se inicializarán los
        <strong>
            atributos
            específicos
        </strong>
        de la clase. Nuevamente, esta llamada también
        <strong>
            debe ser la
            primera sentencia de un constructor
        </strong>
        (con la única excepción de que exista una
        llamada a otro constructor de la clase mediante
        <strong>
            this()
        </strong>
        ).
    </p>
    <p>
        Si no se incluye una llamada a
        <strong>
            super()
        </strong>
        dentro de un
        <strong>
            constructor
        </strong>
        ,
        el compilador incluye automáticamente una llamada al constructor por defecto de
        <strong>
            clase
            base
        </strong>
        (llamada a super()). Esto da lugar a una
        <strong>
            llamada en cadena de
            constructores de superclase
        </strong>
        hasta llegar a la clase más alta de la jerarquía (que
        en Java es la clase
        <strong>
            Object
        </strong>
        ).
    </p>
    <p>
        En el caso del
        <strong>
            constructor por defecto
        </strong>
        (el que crea el compilador si el
        programador no ha escrito ninguno), el compilador añade lo primero de todo, antes de la
        inicialización de los atributos a sus valores por defecto, una llamada al constructor de la
        <strong>
            clase base
        </strong>
        mediante
        <strong>
            super()
        </strong>
        .
    </p>
    <p>
        A la hora de destruir un objeto (método
        <strong>
            finalize()
        </strong>
        ) es importante llamar a los
        finalizadores en el
        <strong>
            orden inverso
        </strong>
        a como fueron llamados los constructores
        (
        <strong>
            primero se liberan los recursos de la clase derivada y después los de la clase
            base
        </strong>
        mediante la llamada
        <strong>
            super.finalize()
        </strong>
        ).
    </p>
    <p>
        Si la clase
        <strong>
            Persona
        </strong>
        tuviera un constructor de este tipo:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>/**
 * Constructor de la clase Persona
 * &#64;param nombre            Nombre de la persona
 * &#64;param apellidos         Apellidos de la persona
 * &#64;param fechaNacimiento   Fecha de nacimiento de la persona
 */
public Persona (String nombre, String apellidos, LocalDate fechaNacimiento) &#123;
     this.nombre= nombre;
     this.apellidos= apellidos;
     this.fechaNacimiento= fechaNacimiento;

&#125;</pre>
        </div>
    </div>
    <p>
        Podrías llamarlo desde un constructor de una clase derivada (por ejemplo
        <strong>
            Alumno
        </strong>
        )
        de la siguiente forma:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>/**
 * Constructor de la clase Alumno
 * &#64;param nombre            Nombre del alumno
 * &#64;param apellidos         Apellidos del alumno
 * &#64;param fechaNacimiento   Fecha de nacimiento del alumno
 * &#64;param grupo             Grupo al que pertenece el alumno
 * &#64;param notaMedia         Nota media del alumno
 */
public Alumno (String nombre, String apellidos, LocalDate fechaNacimiento, String grupo, double notaMedia) &#123;
     super (nombre, apellidos, fechaNacimiento);
     this.grupo= grupo;
     this.notaMedia= notaMedia;
&#125;</pre>
        </div>
    </div>
    <p>
        En realidad se trata de otro recurso más para optimizar la
        <strong>
            reutilización de
            código
        </strong>
        , en este caso del código del
        <strong>
            constructor
        </strong>
        , que aunque no es
        heredado sí puedes invocarlo para no tener que rescribirlo. Al hacerlo recuerda siempre que:
    </p>
    <p class="destacado">
        <strong>
            La utilización del método
            <strong>
                super()
            </strong>
            para llamar al
            constructor de la clase padre sólo puede hacerse desde la primera línea de código de un
            constructor (con la única excepción de que exista antes una llamada a otro constructor de la
            clase mediante
            <strong>
                this()
            </strong>
            ).
        </strong>
    </p>
</div><h1 class="title">
    3.7.- Creación y utilización de clases derivadas.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        Ya has visto cómo crear una
        <strong>
            clase derivada
        </strong>
        , cómo acceder a los
        <strong>
            miembros
            heredados
        </strong>
        de las
        <strong>
            clases superiores
        </strong>
        , cómo redefinir algunos de ellos e
        incluso cómo invocar a un
        <strong>
            constructor
        </strong>
        de la
        <strong>
            superclase
        </strong>
        . Ahora
        se trata de poner en práctica todo lo que has aprendido para que puedas crear tus propias
        <strong>
            jerarquías de clases,
        </strong>
        o basarte en clases que ya existan en Java para heredar
        de ellas, y usarlas de manera adecuada para que tus aplicaciones sean más fáciles de escribir y
        mantener.
    </p>
    <p>
        La idea de la
        <strong>
            herencia
        </strong>
        no es complicar los programas, sino todo lo contrario:
        <strong>
            simplificarlos al máximo
        </strong>
        . Procurar que haya que escribir la menor cantidad
        posible de código repetitivo e intentar facilitar en lo posible la realización de cambios (bien
        para corregir errores bien para incrementar la funcionalidad).
    </p>
</div><h1 class="title">
    3.8.- La clase Object en Java.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        Todas las clases en
        <span lang="en">
         Java
        </span>
        son descendientes (directos o indirectos) de la
        clase
        <strong>
            Object
        </strong>
        . Esta clase define los
        <strong>
            estados y comportamientos básicos
            que deben tener todos los objetos
        </strong>
        . Entre estos comportamientos, se encuentran:
    </p>
    <ul class="lista_verificacion">
        <li>
            La posibilidad de compararse.
        </li>
        <li>
            La capacidad de convertirse a cadenas.
        </li>
        <li>
            La habilidad de devolver la clase del objeto.
        </li>
    </ul>
    <p>
        Entre los métodos que incorpora la clase
        <strong>
            Object
        </strong>
        , y que por tanto hereda
        cualquier clase en
        <span lang="en">
         Java
        </span>
        , tienes:
    </p>
    <table class="tabla">
        <caption>
            Principales métodos de la clase&nbsp;Object
        </caption>
        <thead>
        <tr>
            <th scope="col">
                Método
            </th>
            <th scope="col">
                Descripción
            </th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th scope="row">
                Object ()
            </th>
            <td>
                Constructor.
            </td>
        </tr>
        <tr>
            <th scope="row">
                clone ()
            </th>
            <td>
                Método
                <strong>
                    clonador
                </strong>
                : crea y devuelve una copia del objeto ("clona" el
                objeto).
            </td>
        </tr>
        <tr>
            <th scope="row">
                boolean equals (Object obj)
            </th>
            <td>
                Indica si el objeto pasado como parámetro es igual a este objeto.
            </td>
        </tr>
        <tr>
            <th scope="row">
                void finalize ()
            </th>
            <td>
                Método llamado por el
                <strong>
                    recolector de basura
                </strong>
                cuando éste considera que no
                queda ninguna referencia a este objeto en el entorno de ejecución.
            </td>
        </tr>
        <tr>
            <th scope="row">
                int hashCode ()
            </th>
            <td>
                Devuelve un
                código hash
                para el
                objeto.
            </td>
        </tr>
        <tr>
            <th scope="row">
                toString ()
            </th>
            <td>
                Devuelve una representación del objeto en forma de
                <strong>
                    String
                </strong>
                .
            </td>
        </tr>
        </tbody>
    </table>
    <p>
    </p>
    <p>
        La clase
        <strong>
            Object
        </strong>
        representa la
        <strong>
            superclase
        </strong>
        que se encuentra en la
        cúspide de la
        <strong>
            jerarquía de herencia
        </strong>
        en Java. Cualquier clase (incluso las que
        tú implementes) acaban heredando de ella.
    </p>
    <p>

    </p>
    <div class="exe-tooltip-text" id="t8f87c969-fb62-def5-5d94-0c48364ee009">
        <p>
            Los
            <span lang="en">
          hash
         </span>
            o funciones de resumen son algoritmos que crean a partir de
            una entrada (por ejemplo un texto o un archivo) una salida alfanumérica de longitud
            normalmente fija. Esa cadena de salida representa un resumen de toda la información que la
            función ha recibido como entrada. A partir de los datos de la entrada se crea una cadena que
            solo puede volverse a crear con esos mismos datos. Por eso se dice a veces que es algo así
            como una especie de "firma" o "resumen" de esos datos.
        </p>
    </div>
</div><h1 class="title">
    3.9.- Herencia múltiple.
</h1>
<div class="iDevice_content">
    <p>

        En determinados casos
        podrías considerar la posibilidad de que se necesite
        <strong>
            heredar de más de una
            clase
        </strong>
        , para así disponer de los miembros de dos (o más) clases disjuntas (que no
        derivan una de la otra). La
        <strong>
            herencia múltiple
        </strong>
        permite hacer eso: recoger las
        distintas características (atributos y métodos) de clases diferentes formando una nueva clase
        derivada de varias clases base.
    </p>
    <p>
        El problema en estos casos es la posibilidad que existe de que se produzcan ambigüedades. Así, si
        tuviéramos miembros con el mismo identificador en clases base diferentes, ¿qué miembro se
        hereda? ¿de qué clase padre? Para evitar esto, los compiladores suelen solicitar que ante casos
        de ambigüedad, se especifique de manera explícita la clase de la cual se quiere utilizar un
        determinado miembro que pueda ser ambiguo.
    </p>
    <p>
        Ahora bien, la posibilidad de
        <strong>
            herencia múltiple
        </strong>
        no está disponible en todos los
        lenguajes orientados a objetos, ¿lo estará en Java? La respuesta es negativa.
    </p>
    <p>

    </p>
    <p class="destacado">
        <strong>
            En
            <span lang="en">
          Java
         </span>
            no existe la herencia múltiple de
            clases.
        </strong>
    </p>
</div><h1 class="title">
    4.- Clases abstractas.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        <strong>
            María
        </strong>
        está desarrollando nuevas clases para el proyecto de la
        <strong>
            Clínica
            Veterinaria
        </strong>
        y se ha dado cuenta de que, para aprovechar toda la potencia de la
        <strong>
            herencia
        </strong>
        , le vendría bien definir algunas clases que, sin embargo,
        nunca va a llegar a instanciar:
    </p>
    <p>
        – ¡Qué raro! Estoy definiendo una clase de la que nunca voy a tener objetos. Voy a
        instanciar a sus
        <strong>
            subclases
        </strong>
        , pero nunca a la
        <strong>
            superclase
        </strong>
        …
        –piensa
        <strong>
            María
        </strong>
        en voz alta.
    </p>
    <p>
        – ¡No te preocupes! En realidad no es tan raro –le contesta
        <strong>
            Juan
        </strong>
        , que
        acaba de llegar.
    </p>
    <p>
        – ¿Ah no? ¿Tú crees?
    </p>
    <p>
        – Totalmente. Es más habitual de lo que piensas. Son las
        <strong>
            clases
            abstractas
        </strong>
        . Y si has llegado tú misma a la conclusión de que las necesitas,
        mejor todavía, pues vas a entender con más facilidad su funcionamiento.
    </p>
    <p>
        – ¡Genial! Cuéntame más…
    </p>
</div><h1 class="title">
    4.1.- Declaración de una clase abstracta.
</h1>
<div class="iDevice_content">
    <p>
        Ya has visto que una
        <strong>
            clase abstracta
        </strong>
        es una clase que no se puede instanciar, es
        decir, que no se pueden crear objetos a partir de ella. La idea es permitir que otras clases
        deriven de ella, proporcionando un
        <strong>
            modelo genérico
        </strong>
        y algunos
        <strong>
            métodos de
            utilidad general
        </strong>
        .
    </p>
    <p>
    </p>
    <p>
        Las
        <strong>
            clases abstractas
        </strong>
        se declaran mediante el modificador
        <strong>
            abstract
        </strong>
        :
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>[modificador_acceso] abstract class nombreClase  [herencia] [interfaces] &#123;
     …
&#125;</pre>
        </div>
    </div>
    <p>
        Una clase puede contener en su interior métodos declarados como
        <strong>
            abstract
        </strong>
        (métodos para los cuales sólo se indica la cabecera, pero no se proporciona su implementación).
        En tal caso, la clase tendrá que ser necesariamente también
        <strong>
            abstract
        </strong>
        . Esos
        métodos tendrán que ser posteriormente implementados en sus
        <strong>
            clases derivadas
        </strong>
        .
    </p>
    <p>
        Por otro lado, una
        <strong>
            clase abstracta
        </strong>
        también puede contener
        <strong>
            métodos
            totalmente implementados
        </strong>
        (
        <strong>
            no abstractos
        </strong>
        ), los cuales serán heredados
        por sus
        <strong>
            clases derivadas
        </strong>
        y podrán ser utilizados sin necesidad de definirlos
        (pues ya están implementados).
    </p>
    <p>
        Cuando trabajes con
        <strong>
            clases abstractas
        </strong>
        debes tener en cuenta:
    </p>
    <ul class="lista_verificacion">
        <li>
            Una
            <strong>
                clase abstracta
            </strong>
            sólo puede usarse para crear nuevas clases derivadas.
            No se puede hacer un new&nbsp;de una
            <strong>
                clase abstracta
            </strong>
            . Se produciría un
            <strong>
                error de compilación
            </strong>
            .
        </li>
        <li>
            Una
            <strong>
                clase abstracta
            </strong>
            puede contener
            <strong>
                métodos totalmente
                definidos
            </strong>
            (
            <strong>
                no abstractos
            </strong>
            ) y
            <strong>
                métodos sin definir
            </strong>
            (
            <strong>
                métodos
                abstractos
            </strong>
            ).
        </li>
    </ul>
</div><h1 class="title">
    4.2.- Métodos abstractos.
</h1>
<div class="iDevice_content">
    <p>
        Un
        método abstracto
        es un
        método cuya implementación no se define, sino que se declara únicamente su
        <strong>
            interfaz
        </strong>
        (cabecera) para que su cuerpo sea implementado más adelante en una
        <strong>
            clase derivada
        </strong>
        .
    </p>
    <p>
    </p>
    <p>
        Un método se declara como abstracto mediante el uso del modificador abstract (como en las
        <strong>
            clases abstractas
        </strong>
        ):
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>[modificador_acceso] abstract  &lt;tipo&gt; &lt;nombreMetodo&gt; ([parámetros]) [excepciones]; </pre>
        </div>
    </div>
    <p>
        Estos métodos tendrán que ser
        <strong>
            obligatoriamente redefinidos
        </strong>
        (en realidad
        “definidos”, pues aún no tienen contenido) en las
        <strong>
            clases derivadas
        </strong>
        . Si en una
        <strong>
            clase derivada
        </strong>
        se deja algún
        <strong>
            método abstracto sin implementar
        </strong>
        ,
        esa
        <strong>
            clase derivada
        </strong>
        será también una
        <strong>
            clase abstracta
        </strong>
        .
    </p>
    <p class="destacado">
        <strong>
            Cuando una clase contiene un
            <em>
                método abstracto
            </em>
            tiene que
            declararse como
            <em>
                abstracta
            </em>
            obligatoriamente.
        </strong>
    </p>
    <p>

    </p>
    <p>
        Imagina que tienes una clase
        <strong>
            Empleado
        </strong>
        genérica para diversos tipos de empleado y
        tres
        <strong>
            clases derivadas
        </strong>
        :
        <strong>
            EmpleadoFijo
        </strong>
        (tiene un salario fijo más
        ciertos complementos),
        <strong>
            EmpleadoTemporal
        </strong>
        (salario fijo más otros complementos
        diferentes) y
        <strong>
            EmpleadoComercial
        </strong>
        (una parte de salario fijo y unas comisiones
        por cada operación). La clase
        <strong>
            Empleado
        </strong>
        podría contener un
        <strong>
            método
            abstracto
        </strong>
        <strong>
            calcularNomina
        </strong>
        , pues sabes que se método será necesario
        para cualquier tipo de empleado (todo empleado cobra una nómina). Sin embargo el cálculo en sí
        de la nómina será diferente si se trata de un empleado fijo, un empleado temporal o un empleado
        comercial, y será dentro de las clases especializadas de
        <strong>
            Empleado
        </strong>
        (
        <strong>
            EmpleadoFijo¸
        </strong>
        <strong>
            EmpleadoTemporal
        </strong>
        ,
        <strong>
            EmpleadoComercial
        </strong>
        ) donde se implementen de
        manera específica el cálculo de las mismas.
    </p>
    <p>
        Debes tener en cuenta al trabajar con métodos abstractos:
    </p>
    <ul class="lista_verificacion">
        <li>
            Un
            <strong>
                método abstracto
            </strong>
            implica que la clase a la que pertenece tiene que ser
            <strong>
                abstracta
            </strong>
            , pero eso no significa que todos los métodos de esa clase tengan
            que ser abstractos.
        </li>
        <li>
            Un
            <strong>
                método abstracto
            </strong>
            no puede ser
            <strong>
                privado
            </strong>
            (no se podría
            implementar, dado que las
            <strong>
                clases derivadas
            </strong>
            no tendrían acceso a él).
        </li>
        <li>
            Los
            <strong>
                métodos abstractos
            </strong>
            no pueden ser
            <strong>
                estáticos
            </strong>
            , pues los
            <strong>
                métodos estáticos
            </strong>
            no pueden ser redefinidos (y los
            <strong>
                métodos
                abstractos
            </strong>
            necesitan ser redefinidos).
        </li>
    </ul>
    <div class="exe-tooltip-text" id="td5632ffc-786b-1d12-889d-8314451da4f9">
        <p>
            Un método abstracto en
            <span lang="en">
          Java
         </span>
            es un método declarado en una clase para
            el cual esa clase no proporciona la implementación. Si una clase dispone de al menos un
            método abstracto se dice que es una clase abstracta. Toda clase que herede (sea subclase) de
            una clase abstracta debe implementar todos los métodos abstractos de su superclase o bien
            volverlos a declarar como abstractos (y por tanto también sería abstracta). Para declarar un
            método abstracto en
            <span lang="en">
          Java
         </span>
            se utiliza el modificador abstract.
        </p>
        <p>
            La gran utilidad de incluir en la superclase un método abstracto es que estamos obligando a
            las clases que deriven de ella a que implementen su propia versión del método. Es decir,
            cualquier clase derivada (salvo que sea a su vez abstracta) estará obligada a implementar un
            determinado "comportamiento" asociado a ese método.
        </p>
    </div>
</div><h1 class="title">
    4.3.- Clases y métodos finales.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        En unidades anteriores has visto el modificador
        <strong>
            final
        </strong>
        , aunque sólo lo has
        utilizado por ahora para
        <strong>
            atributos
        </strong>
        y
        <strong>
            variables
        </strong>
        (por ejemplo
        para declarar
        <strong>
            atributos constantes
        </strong>
        , que una vez que toman un valor ya no pueden
        ser modificados). Pero este modificador también puede ser utilizado con clases y con métodos
        (con un comportamiento que no es exactamente igual, aunque puede encontrarse cierta analogía: no
        se permite heredar o no se permite redefinir).
    </p>
    <p>
        <strong>
            Una clase declarada como final no puede ser heredada
        </strong>
        , es decir,
        <strong>
            no puede
            tener clases derivadas
        </strong>
        . La jerarquía de clases a la que pertenece acaba en ella (no
        tendrá clases hijas):
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>[modificador_acceso] final class nombreClase  [herencia] [interfaces]</pre>
        </div>
    </div>
    <p>
        Un
        <strong>
            método
        </strong>
        también puede ser declarado como
        <strong>
            final
        </strong>
        , en tal caso,
        ese método no podrá ser redefinido en una
        <strong>
            clase derivada
        </strong>
        :
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>[modificador_acceso] final &lt;tipo&gt; &lt;nombreMetodo&gt; ([parámetros]) [excepciones]</pre>
        </div>
    </div>
    <p class="destacado">
        <strong>
            Si intentas redefinir un método final en una subclase se producirá un
            <em>
                error de compilación
            </em>
            .
        </strong>
    </p>
</div><h1 class="title">
    5.- Interfaces.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        <strong>
            María
        </strong>
        y
        <strong>
            Juan
        </strong>
        continúan con su tarea de desarrollo de
        clases para el proyecto de la
        <strong>
            Clínica Veterinaria
        </strong>
        . Ya han utilizado la
        <strong>
            herencia
        </strong>
        en diversas ocasiones e incluso han escrito alguna
        <strong>
            clase
            abstracta
        </strong>
        para luego generar clases especializadas basadas en ella.
    </p>
    <p>
        Pero ahora se les ha planteado un nuevo problema: tienen pensadas algunas clases entre
        las que no existe ninguna relación de
        <strong>
            herencia
        </strong>
        , cada una hereda de unos
        ancestros diferentes que no tienen nada que ver, pero sin embargo, sí podrían compartir
        una buena parte de sus
        <strong>
            comportamientos
        </strong>
        (
        <strong>
            métodos
        </strong>
        ). No
        es posible hacer que las dos hereden de la misma
        <strong>
            clase base
        </strong>
        porque
        hemos dicho que no se parecen en nada a ese respecto (cada una tiene su
        <strong>
            clase
            base
        </strong>
        , sin relación entre ellas), y tampoco pueden heredar de una nueva
        <strong>
            clase abstracta
        </strong>
        que contenga la interfaz de ese comportamiento, pues la
        <strong>
            herencia múltiple
        </strong>
        no está permitida en
        <span lang="en">
           Java
          </span>
        :
    </p>
    <p>
          <span>
           —
          </span>
        ¿Qué hacemos entonces?, ¿repetimos la misma
        <strong>
            interfaz
        </strong>
        en las dos
        <strong>
            jerarquías
        </strong>
        de clases? No me cuadra tener que hacer eso.
        <span>
           —
          </span>
        le
        pregunta
        <strong>
            María
        </strong>
        a
        <strong>
            Juan
        </strong>
        .
    </p>
    <p>
          <span>
           —
          </span>
        A mí tampoco. No me suena muy bien"
        <span>
           —
          </span>
        le contesta
        <strong>
            Juan
        </strong>
        .
    </p>
    <p>
          <span>
           —
          </span>
        Así es. Tiene que haber una solución más elegante que no nos haga
        tener que repetir ese código una y otra vez. ¿Alguna idea?
    </p>
    <p>
          <span>
           —
          </span>
        "Quizá exista una forma de resolver el problema. ¿Recuerdas que
        <strong>
            Ada
        </strong>
        nos habló el otro día de las
        <strong>
            interfaces
        </strong>
        ?
    </p>
</div><h1 class="title">
    5.1.- Concepto de interfaz.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        Una
        <strong>
            interfaz
        </strong>
        en
        <span lang="en">
         Java
        </span>
        consiste esencialmente en una lista
        de declaraciones de métodos sin implementar, junto con un conjunto de constantes.
    </p>
    <p>
    </p>
    <p>
        Estos métodos sin implementar indican un
        <strong>
            comportamiento
        </strong>
        , un tipo de conducta,
        aunque no especifican cómo será ese
        <strong>
            comportamiento
        </strong>
        (
        <strong>
            implementación
        </strong>
        ), pues eso dependerá de las características específicas de cada
        clase que decida implementar esa
        <strong>
            interfaz
        </strong>
        . Podría decirse que una
        <strong>
            interfaz
        </strong>
        se encarga de establecer qué
        <strong>
            comportamientos
        </strong>
        hay que tener (qué
        <strong>
            métodos
        </strong>
        ), pero no dice nada de cómo deben llevarse a cabo esos
        <strong>
            comportamientos
        </strong>
        (
        <strong>
            implementación
        </strong>
        ). Se indica sólo la
        <strong>
            forma
        </strong>
        , no la
        <strong>
            implementación
        </strong>
        .
    </p>
    <p>
        En cierto modo podrías imaginar el concepto de
        <strong>
            interfaz
        </strong>
        como un
        <strong>
            guión
        </strong>
        que dice: "éste es el protocolo de comunicación que deben presentar todas
        las clases que implementen esta interfaz". Se proporciona una lista de
        <strong>
            métodos
            públicos
        </strong>
        y, si quieres dotar a tu clase de esa
        <strong>
            interfaz
        </strong>
        , tendrás
        que definir todos y cada uno de esos
        <strong>
            métodos públicos
        </strong>
        .
    </p>
    <p>
    </p>
    <p>
        En conclusión:
        <strong>
            una interfaz se encarga de establecer unas líneas generales sobre los
            comportamientos (métodos) que deberían tener los objetos de toda clase que implemente esa
            interfaz, es decir, que no indican lo que el objeto es
        </strong>
        (de eso se encarga la clase y
        sus
        <strong>
            superclases
        </strong>
        )
        <strong>
            , sino acciones (capacidades) que el objeto debería ser
            capaz de realizar
        </strong>
        . Es por esto que el nombre de muchas interfaces en
        <span lang="en">
         Java
        </span>
        termina con sufijos del tipo "-
        <strong>
            able
        </strong>
        ", "-
        <strong>
            or
        </strong>
        ",
        "
        <strong>
            -ente
        </strong>
        ",&nbsp;, "
        <strong>
            -ante
        </strong>
        " y cosas del estilo, que significan
        algo así como
        <strong>
            capacidad o habilidad
        </strong>
        para hacer o ser receptores de algo
        (
        <strong>
            configurable
        </strong>
        ,
        <strong>
            serializable
        </strong>
        ,
        <strong>
            modificable
        </strong>
        ,
        <strong>
            clonable
        </strong>
        ,
        <strong>
            ejecutable
        </strong>
        ,
        <strong>
            imprimible
        </strong>
        ,
        <strong>
            movible
        </strong>
        ,
        <strong>
            administrador
        </strong>
        ,
        <strong>
            servidor, buscador
        </strong>
        ,
        <strong>
            depredador
        </strong>
        ,
        <strong>
            luchador
        </strong>
        ,
        <strong>
            atacante
        </strong>
        ,
        <strong>
            andante
        </strong>
        ,
        <abbr title="etcétera">
            etc.
        </abbr>
        ), dando así la idea de que se tiene la capacidad de llevar
        a cabo el conjunto de acciones especificadas en la
        <strong>
            interfaz
        </strong>
        .
    </p>
    <p>
    </p>
    <p>
        Imagínate por ejemplo la clase
        <strong>
            Coche
        </strong>
        ,
        <strong>
            subclase
        </strong>
        de
        <strong>
            Vehículo
        </strong>
        .
        Los coches son
        <strong>
            vehículos a motor
        </strong>
        , lo cual implica una serie de acciones como,
        por ejemplo,
        <strong>
            arrancar el motor
        </strong>
        o
        <strong>
            detener el motor
        </strong>
        . Esa acción
        no la puedes heredar de
        <strong>
            Vehículo
        </strong>
        , pues no todos los vehículos tienen por qué
        ser a motor (piensa por ejemplo en una clase
        <strong>
            Bicicleta
        </strong>
        ), y no puedes heredar de
        otra clase pues ya heredas de
        <strong>
            Vehículo
        </strong>
        . Una solución podría ser crear una
        <strong>
            interfaz Arrancable
        </strong>
        , que proporcione los métodos típicos de un
        <strong>
            objeto a
            motor
        </strong>
        (no necesariamente vehículos). De este modo la clase
        <strong>
            Coche
        </strong>
        sigue siendo subclase de
        <strong>
            Vehículo
        </strong>
        , pero también implementaría los
        comportamientos de la interfaz
        <strong>
            Arrancable
        </strong>
        , los cuales podrían ser también
        implementados por otras clases, hereden o no de
        <strong>
            Vehículo
        </strong>
        (por ejemplo una clase
        <strong>
            Motocicleta
        </strong>
        o bien una clase
        <strong>
            Motosierra
        </strong>
        ). La clase
        <strong>
            Coche
        </strong>
        implementará su método
        <strong>
            arrancar
        </strong>
        de una manera, la clase
        <strong>
            Motocicleta
        </strong>
        lo hará de otra (aunque bastante parecida) y la clase
        <strong>
            Motosierra
        </strong>
        de otra forma probablemente muy diferente, pero todos tendrán su propia versión del método
        <strong>
            arrancar
        </strong>
        como parte de la interfaz
        <strong>
            Arrancable
        </strong>
        .
    </p>
    <p>
        Según esta concepción, podrías hacerte la siguiente pregunta:
        <strong>
            ¿podrá una clase
            implementar varias interfaces?
        </strong>
        La respuesta en este caso sí es afirmativa.
    </p>
    <p class="destacado">
        <strong>
            Una clase puede adoptar distintos modelos de comportamiento
            establecidos en diferentes interfaces. Es decir una clase puede implementar varias
            interfaces.
        </strong>
    </p>
</div><h1 class="title">
    5.1.1.- ¿Clase abstracta o interfaz?
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        Observando el concepto de
        <strong>
            interfaz
        </strong>
        que se acaba de proponer, podría caerse en la
        tentación de pensar que es prácticamente lo mismo que una
        <strong>
            clase abstracta
        </strong>
        en la
        que
        <strong>
            todos sus métodos sean abstractos
        </strong>
        .
    </p>
    <p>
        Es cierto que en ese sentido existe un gran
        <strong>
            parecido formal
        </strong>
        entre una
        <strong>
            clase
            abstracta
        </strong>
        y una
        <strong>
            interfaz
        </strong>
        , pudiéndose en ocasiones utilizar
        indistintamente una u otra para obtener un mismo fin. Pero, a pesar de ese gran parecido,
        existen algunas diferencias, no sólo formales, sino también conceptuales, muy importantes:
    </p>
    <ul class="lista_verificacion" type="square">
        <li>
            <strong>
                Una clase no puede heredar de varias clases
            </strong>
            , aunque sean abstractas
            (
            <strong>
                herencia múltiple
            </strong>
            ). Sin embargo sí puede
            <strong>
                implementar una o varias
                interfaces
            </strong>
            y además seguir heredando de una clase.
        </li>
        <li>
            <strong>
                Una interfaz no puede definir métodos
            </strong>
            (
            <strong>
                no implementa su
                contenido
            </strong>
            ), tan solo los declara o enumera.
        </li>
        <li>
            <strong>
                Una interfaz puede hacer que dos clases tengan un mismo comportamiento
            </strong>
            independientemente de sus ubicaciones en una determinada jerarquía de clases (no tienen que
            heredar las dos de una misma superclase, pues no siempre es posible según la naturaleza y
            propiedades de cada clase).
        </li>
        <li>
            <strong>
                Una interfaz permite establecer un comportamiento de clase sin apenas dar
                detalles
            </strong>
            , pues esos detalles aún no son conocidos (dependerán del modo en que cada
            clase decida implementar la
            <strong>
                interfaz
            </strong>
            ).
        </li>
        <li>
            <strong>
                Las interfaces tienen su propia jerarquía
            </strong>
            , diferente e independiente de la
            jerarquía de clases.
        </li>
    </ul>
    <p>
        De todo esto puede deducirse que
        <strong>
            una clase abstracta proporciona una interfaz disponible
            sólo a través de la herencia
        </strong>
        . Sólo quien herede de esa
        <strong>
            clase abstracta
        </strong>
        dispondrá de esa
        <strong>
            interfaz
        </strong>
        . Si una clase no pertenece a esa misma jerarquía (no
        hereda de ella) no podrá tener esa
        <strong>
            interfaz
        </strong>
        . Eso significa que para poder
        disponer de la
        <strong>
            interfaz
        </strong>
        podrías:
    </p>
    <p>
    </p>
    <ol>
        <li>
            Volver a escribirla para esa jerarquía de clases. Lo cual no parece una buena solución.
        </li>
        <li>
            Hacer que la clase herede de la superclase que proporciona la
            <strong>
                interfaz
            </strong>
            que
            te interesa, sacándola de su jerarquía original y convirtiéndola en
            <strong>
                clase
                derivada
            </strong>
            de algo de lo que conceptualmente no debería ser una
            <strong>
                subclase
            </strong>
            . Es decir, estarías forzando una relación "
            <strong>
                es un
            </strong>
            "
            cuando en realidad lo más probable es que esa relación no exista. Tampoco parece la mejor
            forma de resolver el problema.
        </li>
    </ol>
    <p>
        Sin embargo,
        <strong>
            una interfaz sí puede ser implementada por cualquier clase
        </strong>
        ,
        permitiendo que clases que no tengan ninguna relación entre sí (pertenecen a distintas
        jerarquías) puedan compartir un determinado comportamiento (una interfaz) sin tener que forzar
        una relación de herencia que no existe entre ellas.
    </p>
    <p>
        A partir de ahora podemos hablar de otra posible relación entre clases: la de
        <strong>
            compartir
            un determinado comportamiento (interfaz)
        </strong>
        . Dos clases podrían tener en común un
        determinado conjunto de comportamientos sin que necesariamente exista una relación jerárquica
        entre ellas. Tan solo cuando haya realmente una relación de tipo "
        <strong>
            es un
        </strong>
        " se
        producirá
        <strong>
            herencia
        </strong>
        .
    </p>
</div><h1 class="title">
    5.2.- Definición de interfaces.
</h1>
<div class="iDevice_content">
    <p>
        La
        <strong>
            declaración de una interfaz
        </strong>
        en
        <span lang="en">
         Java
        </span>
        es similar a la
        declaración de una clase, aunque con algunas variaciones:
    </p>
    <ul class="lista_verificacion" type="square">
        <li>
            Se utiliza la palabra reservada interface en lugar de class.
        </li>
        <li>
            Puede utilizarse el modificador public. Si incluye este modificador la
            <strong>
                interfaz
            </strong>
            debe tener el mismo nombre que el archivo&nbsp;.java en el que se
            encuentra (exactamente igual que sucedía con las clases). Si no se indica el modificador
            public, el acceso será por omisión o "
            <strong>
                de paquete
            </strong>
            " (como sucedía con las
            clases).
        </li>
        <li>
            Todos los
            <strong>
                miembros
            </strong>
            de la
            <strong>
                interfaz
            </strong>
            (atributos y métodos)
            son public de manera implícita. No es necesario indicar el modificador public, aunque puede
            hacerse.
        </li>
        <li>
            Todos los
            <strong>
                atributos
            </strong>
            son de tipo final y
            <code>
                public
            </code>
            (tampoco es
            necesario especificarlo), es decir,
            <strong>
                constantes
            </strong>
            y
            <strong>
                públicos
            </strong>
            .
            Hay que darles un
            <strong>
                valor inicial
            </strong>
            .
        </li>
        <li>
            Todos los
            <strong>
                métodos
            </strong>
            son
            <strong>
                abstractos
            </strong>
            también de manera
            implícita (tampoco hay que indicarlo). No tienen cuerpo, tan solo la cabecera.
        </li>
    </ul>
    <p>
        Como puedes observar, una
        <strong>
            interfaz
        </strong>
        consiste esencialmente en una lista de
        <strong>
            atributos finales constantes
        </strong>
        y
        <strong>
            métodos abstractos (sin
            implementar
        </strong>
        ). Su sintaxis quedaría entonces:
    </p>
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <div class="elemento_centrado" style="text-align: left;">
        <div class="highlighted-code language-java">
            <div>
          <pre>[public] interface &lt;NombreInterfaz&gt; &#123;
                [public] [final] &lt;tipo1&gt; &lt;atributo1&gt;= &lt;valor1&gt;;
                [public] [final] &lt;tipo2&gt; &lt;atributo2&gt;= &lt;valor2&gt;;
                ...
                [public] [abstract] &lt;tipo_devuelto1&gt;  &lt;nombreMetodo1&gt; ([lista_parámetros]);
                [public] [abstract] &lt;tipo_devuelto2&gt;  &lt;nombreMetodo2&gt; ([lista_parámetros]);
                ...
                &#125;
          </pre>
            </div>
        </div>
    </div>
    <p>
        Si te fijas, la declaración de los métodos termina en punto y coma, pues no tienen cuerpo, al
        igual que sucede con los
        <strong>
            métodos abstractos
        </strong>
        de las
        <strong>
            clases
            abstractas
        </strong>
        .
    </p>
    <p>
        El ejemplo de la interfaz Depredador
        <strong>
        </strong>
        que hemos visto antes podría quedar
        entonces así:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>public interface Depredador &#123;
  void localizar (Animal presa);
  void cazar (Animal presa);
  ...
&#125; </pre>
        </div>
    </div>
    <p>
        <span style="font-size: 1em;">
         Serán las clases que implementen esta interfaz (Leon
        </span>
        <span style="font-size: 1em;">
         , Leopardo
        </span>
        <span style="font-size: 1em;">
         , Cocodrilo
        </span>
        <span style="font-size: 1em;">
         , Rana
        </span>
        <span style="font-size: 1em;">
         , Lagarto
        </span>
        <span style="font-size: 1em;">
         , Hombre
        </span>
        <span style="font-size: 1em;">
         ,
         <abbr title="etcétera">
          etc.
         </abbr>
         ) las que definan cada uno de los métodos por dentro.
        </span>
    </p>
</div><h1 class="title">
    5.3.- Implementación de interfaces.
</h1>
<div class="iDevice_content">
    <p>
        Como ya has visto, todas las clases que implementan una determinada
        <strong>
            interfaz
        </strong>
        están obligadas a proporcionar una
        <strong>
            definición (implementación) de los métodos de esa
            interfaz
        </strong>
        , adoptando el modelo de comportamiento propuesto por ésta.
    </p>
    <p>
        Dada una
        <strong>
            interfaz
        </strong>
        , cualquier clase puede especificar dicha
        <strong>
            interfaz
        </strong>
        mediante el mecanismo denominado
        <strong>
            implementación de
            interfaces
        </strong>
        . Para ello se utiliza la palabra reservada implements:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>class NombreClase implements NombreInterfaz &#123;</pre>
        </div>
    </div>
    <p>
        De esta manera, la clase está diciendo algo así como "
        <strong>
            la interfaz indica los métodos que
            debo implementar, pero voy a ser yo (la clase) quien los implemente
        </strong>
        ".
    </p>
    <p>
        Es posible indicar varios nombres de
        <strong>
            interfaces
        </strong>
        separándolos por comas:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>class NombreClase implements NombreInterfaz1, NombreInterfaz2,... &#123;</pre>
        </div>
    </div>
    <p>
        Cuando una clase implementa una
        <strong>
            interfaz
        </strong>
        , tiene que redefinir sus métodos
        nuevamente con
        <strong>
            acceso público
        </strong>
        . Con otro tipo de acceso se producirá un
        <strong>
            error
            de compilación
        </strong>
        . Es decir, que del mismo modo que no se podían restringir permisos
        de acceso en la
        <strong>
            herencia de clases
        </strong>
        , tampoco se puede hacer en la
        <strong>
            implementación
            de interfaces
        </strong>
        .
    </p>
    <p>
        Una vez implementada una
        <strong>
            interfaz
        </strong>
        en una clase, los métodos de esa interfaz
        tienen exactamente el mismo tratamiento que cualquier otro método, sin ninguna diferencia,
        pudiendo ser invocados, heredados, redefinidos,
        <abbr title="etcétera">
            etc.
        </abbr>
    </p>
    <div class="elemento_derecha">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        En el ejemplo de los depredadores, al definir la clase Leon, habría que indicar que implementa la
        <strong>
            interfaz
        </strong>
        Depredador:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>class Leon implements Depredador &#123;</pre>
        </div>
    </div>
    <p>
        Y en su interior habría que implementar aquellos métodos que contenga la
        <strong>
            interfaz
        </strong>
        :
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>void localizar (Animal presa) &#123;
// Implementación del método localizar para un león
...
&#125; </pre>
        </div>
    </div>
    <p>
        <span style="font-size: 1em;">
         En el caso de clases que pudieran ser a la vez Depredador
        </span>
        <span style="font-size: 1em;">
         y Presa
        </span>
        <span style="font-size: 1em;">
         , tendrían que implementar ambas interfaces, como podría suceder con la clase Rana
        </span>
        <span style="font-size: 1em;">
         :
        </span>
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>class Rana implements Depredador, Presa &#123;</pre>
        </div>
    </div>
    <p>
        Y en su interior habría que implementar aquellos métodos que contengan ambas
        <strong>
            interfaces
        </strong>
        , tanto las de Depredador&nbsp;(
        <code>
            localizar
        </code>
        , cazar,
        <abbr title="etcétera">
            etc.
        </abbr>
        ) como las de Presa&nbsp;(
        <code>
            observar
        </code>
        , huir,
        <abbr title="etcétera">
            etc.
        </abbr>
        ).
    </p>
</div><h1 class="title">
    5.3.1.- Un ejemplo de implementación de interfaces.
</h1>
<div class="iDevice_content">
    <div class="elemento_derecha">
    </div>
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>

    </div>
    <p>
        El trabajo con
        <strong>
            interfaces
        </strong>
        es algo habitual en el desarrollo de aplicaciones en
        <span lang="en">
         Java
        </span>
        . Es por tanto muy importante comprender correctamente su
        funcionamiento y la interacción con las distintas
        <strong>
            bibliotecas
        </strong>
        (
        <strong>
            paquetes
            de clases
        </strong>
        e
        <strong>
            interfaces
        </strong>
        ) que proporcionan las
        <span lang="en" title="Application Programming Interface">
         API
        </span>
        . Estas
        <strong>
            clases
        </strong>
        e
        <strong>
            interfaces
        </strong>
        son fundamentales para la creación de
        aplicaciones y tendrás que utilizarlas en multitud de ocasiones (además, por supuesto, de las
        que tengas que desarrollar por ti mismo).
    </p>
    <p>
        Vamos a ver un ejemplo de una
        <strong>
            interfaz
        </strong>
        proporcionada por la
        <abbr title="Application Programming Interface">
            API
        </abbr>
        de
        <span lang="en">
         Java
        </span>
        que puede ser implementada por alguna clase creada por ti dentro de
        una pequeña aplicación. Hemos escogido la interfaz Comparable. Más adelante, en la unidad de
        interfaces gráficas, veremos otro ejemplo bastante ilustrativo con la interfaz ActionListener.
        Esta interfeaz es de gran utilidad para las clases que quieran realizar una determinada acción
        cada vez que se produzca cierto
        <strong>
            evento
        </strong>
        en el sistema. Este tipo de
        <strong>
            interfaces
        </strong>
        se encuentran dentro de los
        <strong>
         <span lang="en">
          Event Listeners
         </span>
        </strong>
        u "
        <strong>
            oyentes
            de eventos
        </strong>
        " y son útiles para detectar que se ha producido un determinado
        <strong>
            evento
            asíncrono
        </strong>
        durante la ejecución
        de tu aplicación como pulsación de una tecla, clic de ratón,
        <abbr title="etcétera">
            etc.
        </abbr>
        Son intensivamente utilizadas en el desarrollo de las
        <strong>
            interfaces gráficas de usuario
        </strong>
        .
    </p>
    <div class="exe-tooltip-text" id="t353dd465-1a13-00fb-de1a-daeb794b035d">
        <p>
            Un fenómeno, acción o evento se dice que es asíncrono cuando tiene lugar en cualquier momento
            sin saber exactamente el momento en el que pueda producirse.
        </p>
    </div>
</div><h1 class="title">
    5.4.- Simulación de la herencia múltiple mediante el uso de
    interfaces.
</h1>
<div class="iDevice_content">
    <p>
        Una
        <strong>
            interfaz
        </strong>
        no tiene
        <strong>
            espacio de almacenamiento
        </strong>
        asociado (no se
        van a declarar objetos de un tipo de interfaz), es decir, no tiene
        <strong>
            implementación
        </strong>
        .
    </p>
    <p>
        En algunas ocasiones es posible que interese representar la situación de que "una clase
        <strong>
            X
        </strong>
        es de tipo
        <strong>
            A
        </strong>
        , de tipo
        <strong>
            B
        </strong>
        , y de tipo
        <strong>
            C
        </strong>
        ",
        siendo
        <strong>
            A
        </strong>
        ,
        <strong>
            B
        </strong>
        ,
        <strong>
            C
        </strong>
        <strong>
            clases
            disjuntas
        </strong>
        (no heredan unas de otras). Hemos visto que sería un caso de
        <strong>
            herencia
            múltiple
        </strong>
        que
        <span lang="en">
         Java
        </span>
        no permite.
    </p>
    <p>
        Para poder simular algo así, podrías definir tres
        <strong>
            interfaces
        </strong>
        <strong>
            A
        </strong>
        ,
        <strong>
            B
        </strong>
        ,
        <strong>
            C
        </strong>
        que indiquen los comportamientos (métodos) que se
        deberían tener según se pertenezca a una supuesta clase
        <strong>
            A
        </strong>
        ,
        <strong>
            B
        </strong>
        ,
        o
        <strong>
            C
        </strong>
        , pero sin implementar ningún método concreto ni atributos de objeto (sólo
        interfaz).
    </p>
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>
    </div>
    <p>
        De esta manera la clase
        <strong>
            X
        </strong>
        podría a la vez:
    </p>
    <ol start="1" type="1">
        <li>
            Implementar las interfaces
            <strong>
                A
            </strong>
            ,
            <strong>
                B
            </strong>
            ,
            <strong>
                C
            </strong>
            , que
            la dotarían de los comportamientos que deseaba heredar de las clases
            <strong>
                A
            </strong>
            ,
            <strong>
                B
            </strong>
            ,
            <strong>
                C
            </strong>
            .
        </li>
        <li>
            Heredar de otra clase
            <strong>
                Y
            </strong>
            , que le proporcionaría determinadas características
            dentro de su taxonomía o jerarquía de objeto (atributos, métodos implementados y métodos
            abstractos).
        </li>
    </ol>
    <p>
        En el ejemplo que hemos visto de las interfaces Depredador&nbsp;y
        <code>
            Presa
        </code>
        , tendrías un
        ejemplo de esto: la clase Rana, que es subclase de Anfibio, implementa una serie de
        <strong>
            comportamientos
        </strong>
        propios de un Depredador&nbsp;y, a la vez, otros más propios de una Presa. Esos
        <strong>
            comportamientos
        </strong>
        (
        <strong>
            métodos
        </strong>
        ) no forman parte de la
        <strong>
            superclase
        </strong>
        Anfibio, sino de
        las
        <strong>
            interfaces
        </strong>
        . Si se decide que la clase Rana&nbsp;debe de llevar a cabo
        algunos otros
        <strong>
            comportamientos adicionales
        </strong>
        , podrían añadirse a una
        <strong>
            nueva
            interfaz
        </strong>
        y la clase Rana
        <strong>
            implementaría
        </strong>
        una tercera
        <strong>
            interfaz
        </strong>
        .
    </p>
    <p>
        De este modo, con el mecanismo "
        <strong>
            una herencia pero varias interfaces
        </strong>
        ", podrían
        conseguirse resultados similares a los obtenidos con la
        <strong>
            herencia múltiple
        </strong>
        .
    </p>
    <p>
        Ahora bien, del mismo modo que sucedía con la
        <strong>
            herencia múltiple
        </strong>
        , puede darse el
        problema de la
        <strong>
            colisión de nombres
        </strong>
        al implementar dos
        <strong>
            interfaces
        </strong>
        que tengan un
        <strong>
            método con el mismo identificador
        </strong>
        . En
        tal caso puede suceder lo siguiente:
    </p>
    <ul class="lista_verificacion" type="square">
        <li>
            Si los dos métodos tienen
            <strong>
                diferentes parámetros
            </strong>
            no habrá problema aunque
            tengan el mismo nombre pues se realiza una
            <strong>
                sobrecarga
            </strong>
            de métodos.
        </li>
        <li>
            Si los dos métodos se diferencian solo en su
            <strong>
                valor de retorno que es de un tipo
                diferente
            </strong>
            , se producirá un
            <strong>
                error de compilación
            </strong>
            (al igual que
            sucede en la sobrecarga cuando la única diferencia entre dos métodos es ésa).
        </li>
    </ul>
    <p>
        Si los dos métodos son
        <strong>
            exactamente iguales en identificador, parámetros y tipo
            devuelto
        </strong>
        , entonces solamente se podrá
        <strong>
            implementar uno de los dos
            métodos
        </strong>
        . En realidad se trata de un solo método pues ambos tienen la misma interfaz
        (mismo identificador, mismos parámetros y mismo tipo devuelto).
    </p>
</div><h1 class="title">
    5.5.- Herencia de interfaces.
</h1>
<div class="iDevice_content">
    <p>

        Las
        <strong>
            interfaces
        </strong>
        , al igual
        que las
        <strong>
            clases
        </strong>
        , también permiten la
        <strong>
            herencia
        </strong>
        . Para indicar que
        una
        <strong>
            interfaz
        </strong>
        hereda de otra se indica nuevamente con la palabra reservada
        extends. Pero en este caso sí se permite la
        <strong>
            herencia múltiple de interfaces
        </strong>
        . Si
        se hereda de más de una
        <strong>
            interfaz
        </strong>
        se indica con la lista de
        <strong>
            interfaces
        </strong>
        separadas por comas.
    </p>
    <p>
        Por ejemplo, dadas las interfaces InterfazUno&nbsp;e
        <code>
            InterfazDos
        </code>
        :
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>public interface InterfazUno &#123;

                // Métodos y constantes de la interfaz Uno

&#125;</pre>
        </div>
    </div>
    <div class="highlighted-code language-java">
        <div>
         <pre>public interface InterfazDos &#123;

                // Métodos y constantes de la interfaz Dos

&#125;</pre>
        </div>
    </div>
    <p>
        Podría definirse una nueva
        <strong>
            interfaz
        </strong>
        que heredara de ambas:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>public interface InterfazCompleja extends InterfazUno, InterfazDos &#123;

                // Métodos y constantes de la interfaz compleja

&#125;</pre>
        </div>
    </div>
</div><h1 class="title">
    6.- Polimorfismo.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        <strong>
            María
        </strong>
        está desarrollando algunas clases que representan categorías de
        <strong>
            animales
        </strong>
        para el proyecto de la
        <strong>
            Clínica Veterinaria
        </strong>
        .
        En algunos casos declara objetos de un tipo de animal y en ciertas ocasiones de otros,
        según las necesidades que tenga en cada momento. La clase Animal&nbsp;es demasiado
        genérica como para poder utilizarla en determinados casos y necesita clases más
        específicas para poder trabajar, pues tendrá que usar unas u otras versiones de sus
        métodos.
        <strong>
            Juan
        </strong>
        también está haciendo algo parecido y ambos intuyen que
        el código que están escribiendo podría ser mucho más sencillo y flexible si pudieran
        declarar inicialmente objetos de la clase Animal&nbsp;y más tarde, durante la ejecución
        de la aplicación, utilizar objetos de tipo Animal, pero de clases más especializadas
        (
        <strong>
            subclases de Animal
        </strong>
        ) en función de lo que suceda en cada momento.
        Sería muy interesante poder hacer algo así.
        <strong>
            Ada
        </strong>
        lleva algunos minutos
        escuchándolos y decide intervenir:
    </p>
    <p>
          <span>
           —
          </span>
        Veo que habéis llegado a la conclusión de que necesitáis trabajar con
        objetos cuya clase aún no está clara en tiempo de compilación, ¿no?
        <span>
           —
          </span>
        les
        pregunta a ambos.
    </p>
    <p>
          <span>
           —
          </span>
        Así es. Pero eso no se puede hacer, el compilador no nos lo va a permitir
        <span>
           —
          </span>
        le responden casi al unísono.
    </p>
    <p>
          <span>
           —
          </span>
        Bueno, es lógico que el compilador tenga que saber a qué clase
        pertenece un objeto para poder analizar si se está accediendo a los miembros correctos y
        con la sintaxis apropiada, ¿no crees?
    </p>
    <p>
          <span>
           —
          </span>
        Totalmente de acuerdo.
        <span>
           —
          </span>
        le contesta
        <strong>
            María
        </strong>
        .
    </p>
    <p>
          <span>
           —
          </span>
        Pero si declaramos un objeto de una clase que sea
        <strong>
            superclase
        </strong>
        de otras, quizá podríamos más tarde intentar para ese objeto
        instanciar una
        <strong>
            subclase
        </strong>
        más específica. Al fin y al cabo, una clase de
        tipo MascotaDomestica&nbsp;sigue siendo también Animal, pues ha heredado de ella, ¿no es
        así?
    </p>
    <p>
          <span>
           —
          </span>
        ¿Quieres decir que podríamos utilizar en el programa objetos de
        clases cuyos métodos llamados no sabemos exactamente cuáles van a ser porque dependerá
        de la
        <strong>
            subclase
        </strong>
        concreta que se instancie en tiempo de ejecución?
        <span>
           —l
          </span>
        e
        responde
        <strong>
            María
        </strong>
        muy interesada.
    </p>
    <p>
        Parece que ha llegado el momento de que empecéis a trabajar con el polimorfismo y la
        ligadura dinámica
        —les contesta
        satisfecha.
    </p>
    <div class="exe-tooltip-text" id="t1b6f9565-e679-6153-ed3b-b44959b23e72">
        <p>
            Indica que la vinculación que se produce en la llamada a un método con la clase a la
            que pertenece ese método se realiza en tiempo de ejecución. Es decir, que al generar
            el código ejecutable no se conoce exactamente el método (a qué clase pertenece) que
            será llamado. Sólo se sabrá cuando el programa esté en ejecución.
        </p>
    </div>
</div><h1 class="title">
    6.1.- Concepto de polimorfismo.
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        El
        <strong>
            polimorfismo
        </strong>
        consiste en la capacidad de poder utilizar una referencia a un
        objeto de una determinada clase como si fuera de otra clase (en concreto una
        <strong>
            subclase
        </strong>
        ). Es una manera de decir que una clase podría tener varias (poli)
        formas (morfismo).
    </p>
    <p>
        Un método "
        <strong>
            polimórfico
        </strong>
        " ofrece la posibilidad de ser distinguido (saber a qué
        clase pertenece) en
        <strong>
            tiempo de ejecución
        </strong>
        en lugar de en
        <strong>
            tiempo de
            compilación
        </strong>
        . Para poder hacer algo así es necesario utilizar métodos que pertenecen
        a una
        <strong>
            superclase
        </strong>
        y que en cada
        <strong>
            subclase
        </strong>
        se implementan de una
        forma en particular. En
        <strong>
            tiempo de compilación
        </strong>
        se invocará al método sin saber
        exactamente si será el de una subclase u otra (pues se está invocando al de la
        <strong>
            superclase
        </strong>
        ).
        Sólo en
        <strong>
            tiempo de ejecución
        </strong>
        (una vez instanciada una u otra
        <strong>
            subclase
        </strong>
        ) se conocerá realmente qué método (de qué
        <strong>
            subclase
        </strong>
        )
        es el que finalmente va a ser invocado.
    </p>
    <p>
        Esta forma de trabajar te va a permitir hasta cierto punto "desentenderte" del tipo de objeto
        <strong>
            específico
        </strong>
        (
        <strong>
            subclase
        </strong>
        ) para centrarte en el tipo de objeto
        <strong>
            genérico
        </strong>
        (
        <strong>
            superclase
        </strong>
        ). De este modo podrás manipular objetos
        hasta cierto punto "desconocidos" en tiempo de compilación y que sólo durante la ejecución del
        programa se sabrá exactamente de qué tipo de objeto (
        <strong>
            subclase
        </strong>
        ) se trata.
    </p>
    <p class="destacado">
        <strong>
            El
            <em>
                polimorfismo
            </em>
            ofrece la
            <em>
                posibilidad de que toda
                referencia a un objeto de una superclase pueda tomar la forma de una referencia a un objeto de
                una de sus subclase
            </em>
            s. Esto te va a permitir escribir programas que procesen objetos de
            clases que formen parte de la misma jerarquía como si todos fueran objetos de sus
            <em>
                superclases
            </em>
            .
        </strong>
    </p>
    <p class="destacado">
        <strong>
            El
            <em>
                polimorfismo
            </em>
            puede llevarse a cabo tanto con
            <em>
                superclases
            </em>
            (abstractas o no) como con
            <em>
                interfaces.
            </em>
        </strong>
    </p>
    <p>
        Dada una
        <strong>
            superclase
        </strong>
        <strong>
            X
        </strong>
        , con un método
        <strong>
            m
        </strong>
        , y dos
        <strong>
            subclases
        </strong>
        <strong>
            A
        </strong>
        y
        <strong>
            B
        </strong>
        , que redefinen ese método
        <strong>
            m
        </strong>
        , podrías declarar un objeto
        <strong>
            O
        </strong>
        de tipo
        <strong>
            X
        </strong>
        que
        durante la
        <strong>
            ejecución
        </strong>
        podrá ser de tipo
        <strong>
            A
        </strong>
        o de tipo
        <strong>
            B
        </strong>
        (algo desconocido en
        <strong>
            tiempo de compilación
        </strong>
        ). Es decir,
        podemos tener declarada una referencia
        <strong>
            O
        </strong>
        de tipo
        <strong>
            X
        </strong>
        en tiempo
        de compilación, que en tiempo de ejecución podrá acabar apuntando a un objeto concreto de tipo
        <strong>
            A
        </strong>
        o de tipo
        <strong>
            B
        </strong>
        , ya que todo objeto de las subclases "lleva
        dentro" un objeto de la superclase, que puede ser apuntado sin problemas con la referencia de la
        superclase. Esto significa que&nbsp; al invocarse el método
        <strong>
            m
        </strong>
        de
        <strong>
            X
        </strong>
        (
        <strong>
            superclase
        </strong>
        ), se estará en realidad invocando al método
        <strong>
            m
        </strong>
        de
        <strong>
            A
        </strong>
        o de
        <strong>
            B
        </strong>
        (alguna de sus
        <strong>
            subclases
        </strong>
        ),
        sin que sepamos cuál hasta que llegue ese momento a la hora de ejecutar el programa. Por
        ejemplo:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Declaración de una referencia a un objeto de tipo X
ClaseX obj;  // Objeto de tipo X (superclase)
...

// Zona del programa donde se instancia un objeto de tipo A (subclase) y se le asigna a la referencia obj.

// La variable obj adquiere la forma de la subclase A. (Todo objeto A lleva dentro un objeto de su superclase ClaseX)
obj = new ClaseA ();
...

// Otra zona del programa.

// Aquí se instancia un objeto de tipo B (subclase) y se le asigna a la referencia obj.

// La variable obj adquiere la forma de la subclase B. (Todo objeto A lleva dentro un objeto de su superclase ClaseX)
obj = new ClaseB ();
...

// Zona donde se utiliza el método m sin saber realmente qué subclase se está utilizando.

// (Sólo se sabrá durante la ejecución del programa)
obj.m ()  // Llamada al método m (sin saber si será el método m de A o de B). Se asociará o "ligará" al m() adecuado
          //durante la ejecución, que será cuando se sabrá si obj apunta a un objeto tipo A o tipo B. (por eso se llama ligadura dinámica).
...</pre>
        </div>
    </div>
    <p>
        <span style="font-size: 1em;">
         Imagina que estás trabajando con las clases
        </span>
        Alumno
        <span style="font-size: 1em;">
         y
        </span>
        Profesor
        <span style="font-size: 1em;">
         y que en determinada zona del código podrías tener objetos, tanto de un tipo como de otro, pero eso sólo se sabrá según vaya discurriendo la ejecución del programa. En algunos casos, es posible que un determinado objeto pudiera ser de la clase
        </span>
        Alumno
        <span style="font-size: 1em;">
         y en otros de la clase
        </span>
        Profesor
        <span style="font-size: 1em;">
         , pero en cualquier caso serán objetos de la clase
        </span>
        Persona
        <span style="font-size: 1em;">
         . Eso significa que la llamada a un método de la clase
        </span>
        Persona
        <span style="font-size: 1em;">
         (por ejemplo
        </span>
        getContenidoString
        <span style="font-size: 1em;">
         ) en realidad será en unos casos a un método (con el mismo nombre) de la clase
        </span>
        Alumno
        <span style="font-size: 1em;">
         y en otros, a un método (con el mismo nombre también) de la clase
        </span>
        Profesor
        <span style="font-size: 1em;">
         . Esto será posible hacerlo gracias a la
        </span>
        <strong style="font-size: 1em;">
            ligadura dinámica
        </strong>
        <span style="font-size: 1em;">
         .
        </span>
    </p>
</div><h1 class="title">
    6.2.- Ligadura dinámica.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        La conexión que tiene lugar durante una llamada a un método suele ser llamada
        ligadura
        ,
        <strong>
            vinculación
        </strong>
        o
        <strong>
            enlace
        </strong>
        (en inglés
        <strong>
         <span lang="en">
          binding
         </span>
        </strong>
        ). Si esta
        <strong>
            vinculación
        </strong>
        se lleva a cabo durante el proceso de compilación, se le suele
        llamar
        <strong>
            ligadura estática
        </strong>
        (también
        conocido como
        <strong>
            vinculación temprana
        </strong>
        ). En los lenguajes tradicionales, no
        orientados a objetos, ésta es la única forma de poder resolver la
        <strong>
            ligadura
        </strong>
        (en
        <strong>
            tiempo de compilación
        </strong>
        ). Sin embargo, en los
        <strong>
            lenguajes orientados a
            objetos
        </strong>
        existe otra posibilidad: la
        <strong>
            ligadura dinámica
        </strong>
        (también
        conocida como
        <strong>
            vinculación tardía, enlace tardío
        </strong>
        o
        <strong>
         <span lang="en">
          late binding
         </span>
        </strong>
        ).
    </p>
    <p>
        La
        <strong>
            ligadura dinámica
        </strong>
        hace posible que sea el
        <strong>
            tipo de objeto
        </strong>
        instanciado (obtenido mediante el
        <strong>
            constructor
        </strong>
        finalmente utilizado para crear
        el objeto) y no el
        <strong>
            tipo de la referencia
        </strong>
        (el tipo indicado en la declaración de
        la variable que apuntará al objeto) lo que determine qué versión del método va a ser invocada.
        El
        <strong>
            tipo de objeto
        </strong>
        al que apunta la variable de tipo referencia sólo podrá ser
        conocido durante la
        <strong>
            ejecución
        </strong>
        del programa y por eso el
        <strong>
            polimorfismo
        </strong>
        necesita la
        <strong>
            ligadura dinámica
        </strong>
        .
    </p>
    <p>
        En el ejemplo anterior de la clase
        <strong>
            X
        </strong>
        y sus
        <strong>
            subclases
        </strong>
        <strong>
            A
        </strong>
        y
        <strong>
            B
        </strong>
        , la llamada al método
        <strong>
            m
        </strong>
        sólo puede
        resolverse mediante ligadura dinámica, pues es imposible saber en tiempo de compilación si el
        método
        <strong>
            m
        </strong>
        que debe ser invocado será el definido en la subclase
        <strong>
            A
        </strong>
        o el definido en la subclase B:
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>// Llamada al método m (sin saber si será el método m de A o de B).
obj.m ()  // Esta llamada será resuelta en tiempo de ejecución (ligadura dinámica)</pre>
        </div>
    </div>
    <div class="exe-tooltip-text" id="t892f4849-e206-861c-1a40-ab34f81bbc93">
        <p>
            Es la conexión o vinculación que tiene lugar durante una llamada a un método para saber qué
            código debe ser ejecutado. Puede ser estática o dinámica.
        </p>
    </div>
    <div class="exe-tooltip-text" id="ta2f0b153-c560-9d47-bea7-d47717576a88">
        <p>
            Indica que la vinculación que se produce en la llamada a un método con la clase a la que
            pertenece ese método se realiza en tiempo de compilación. Es decir, que antes de generar el
            código ejecutable se conoce exactamente el método (a qué clase pertenece) que será
            llamado.
        </p>
    </div>
    <div class="exe-tooltip-text" id="t916c977f-5376-f92c-44e0-515574eb9244">
        <p>
            Indica que la vinculación que se produce en la llamada a un método con la clase a la que
            pertenece ese método se realiza en tiempo de ejecución. Es decir, que al generar el código
            ejecutable no se conoce exactamente el método (a qué clase pertenece) que será llamado. Sólo
            se sabrá cuando el programa esté en ejecución.
        </p>
    </div>
</div><h1 class="title">
    6.3.- Limitaciones de la ligadura dinámica.
</h1>
<div class="iDevice_content">
    <p>
        Como has podido comprobar, el
        <strong>
            polimorfismo
        </strong>
        se basa en la utilización de
        <strong>
            referencias
        </strong>
        de un tipo más "amplio" (
        <strong>
            superclases
        </strong>
        ) que los objetos a los que luego realmente
        van a apuntar (
        <strong>
            subclases
        </strong>
        ). Ahora bien, existe una importante
        <strong>
            restricción
        </strong>
        en el uso de esta capacidad, pues el tipo de referencia limita cuáles son los métodos que se
        pueden utilizar y los atributos a los que se pueden acceder.
    </p>
    <p class="destacado">
        <strong>
            No se puede acceder a los
            <em>
                miembros específicos
            </em>
            de una
            <em>
                subclase
            </em>
            a través de una
            <em>
                referencia
            </em>
            a una superclase. Sólo se pueden utilizar los miembros
            declarados en la
            <em>
                superclase
            </em>
            , aunque la definición que finalmente se utilice en su
            ejecución sea la de la
            <em>
                subclase
            </em>
            .
        </strong>
    </p>
    <p>
    </p>
    <p>
        Veamos un ejemplo: si dispones de una clase
        <strong>
            A
        </strong>
        que es subclase de
        <strong>
            B
        </strong>
        y declaras una variable como referencia un objeto de tipo
        <strong>
            B
        </strong>
        .
        Aunque más tarde esa variable haga referencia a un objeto de tipo
        <strong>
            A
        </strong>
        (
        <strong>
            subclase
        </strong>
        ),
        los miembros a los que podrás acceder sin que el compilador produzca un error serán los miembros
        de
        <strong>
            A
        </strong>
        que hayan sido heredados de
        <strong>
            B
        </strong>
        (
        <strong>
            superclase
        </strong>
        ). De este modo, se garantiza que los métodos que se intenten llamar
        van a existir cualquiera que sea la subclase de
        <strong>
            B
        </strong>
        a la que se apunte desde esa
        referencia.
    </p>
    <p>
        En el ejemplo de las clases Persona,
        <code>
            Profesor
        </code>
        y Alumno, el
        <strong>
            polimorfismo
        </strong>
        nos permitiría declarar variables de tipo Persona&nbsp;y más tarde
        hacer con ellas referencia a objetos de tipo Profesor&nbsp;o
        <code>
            Alumno
        </code>
        , pero no
        deberíamos intentar acceder con esa variable a métodos que sean específicos de la clase Profesor&nbsp;o
        de la clase Alumno, tan solo a métodos que sabemos que van a existir seguro en ambos tipos de
        objetos (métodos de la
        <strong>
            superclase
        </strong>
        Persona).
    </p>
</div><h1 class="title">
    6.4.- Interfaces y polimorfismo.
</h1>
<div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">
        </div>

    </div>
    <p>
        Es posible también llevar a cabo el
        <strong>
            polimorfismo
        </strong>
        mediante el uso de
        <strong>
            interfaces
        </strong>
        .
        Un objeto puede tener una referencia cuyo tipo sea una
        <strong>
            interfaz
        </strong>
        , pero para que
        el compilador te lo permita, la clase cuyo
        <strong>
            constructor
        </strong>
        se utilice para crear el
        objeto deberá implementar esa
        <strong>
            interfaz
        </strong>
        (bien por si misma o bien porque la
        implemente alguna
        <strong>
            superclase
        </strong>
        ). Un objeto cuya referencia sea de tipo
        <strong>
            interfaz
        </strong>
        sólo puede utilizar aquellos métodos definidos en la
        <strong>
            interfaz
        </strong>
        , es decir, que no
        podrán utilizarse los atributos y métodos específicos de su clase, tan solo los de la
        <strong>
            interfaz
        </strong>
        .
    </p>
    <p>
        Las referencias de tipo
        <strong>
            interfaz
        </strong>
        permiten unificar de una manera bastante
        estricta la forma de utilizar objetos que pertenezcan a clases muy diferentes (pero que todas
        ellas implementan la misma
        <strong>
            interfaz
        </strong>
        ). De este modo podrías hacer referencia a
        diferentes objetos que no tienen ninguna relación jerárquica entre sí utilizando la misma
        variable (referencia a la
        <strong>
            interfaz
        </strong>
        ). Lo único que los distintos objetos
        tendrían en común es que implementan la misma
        <strong>
            interfaz
        </strong>
        . En este caso sólo
        podrás llamar a los métodos de la
        <strong>
            interfaz
        </strong>
        y no a los específicos de las
        clases.
    </p>
    <p>
        Por ejemplo, si tenías una variable de tipo referencia a la interfaz Arrancable, podrías
        instanciar objetos de tipo Coche&nbsp;o
        <code>
            Motosierra
        </code>
        y asignarlos a esa
        referencia (teniendo en cuenta que ambas clases no tienen una relación de herencia). Sin
        embargo, tan solo podrás usar en ambos casos los métodos y los atributos de la interfaz
        Arrancable&nbsp;(por ejemplo arrancar) y no los de Coche&nbsp;o los de Motosierra&nbsp;(sólo los
        genéricos, nunca los específicos).
    </p>
    <p>
        En el caso de las clases Persona,
        <code>
            Alumno
        </code>
        y Profesor, podrías declarar, por ejemplo,
        variables del tipo Imprimible:
    </p>
    <div class="highlighted-code language-java">
        <div>
            <pre>Imprimible objeto ;                // Imprimible es una interfaz y no una clase</pre>
        </div>
    </div>
    <p>
        <span style="font-size: 1em;">
         Con este tipo de referencia podrías luego apuntar a objetos tanto de tipo Profesor
        </span>
        <span style="font-size: 1em;">
         como de tipo Alumno
        </span>
        <span style="font-size: 1em;">
         , pues ambos implementan la interfaz Imprimible
        </span>
        <span style="font-size: 1em;">
         :
        </span>
    </p>
    <div class="highlighted-code language-java hightlight-2and5">
        <div>
         <pre>// En algunas circunstancias podría suceder esto:
objeto = new Alumno (nombre, apellidos, fecha, grupo, nota) ; // Polimorfismo con interfaces
...
// En otras circunstancias podría suceder esto:
objeto = new Profesor (nombre, apellidos, fecha, especialidad, salario) ; // Polimorfismo con interfaces
...</pre>
        </div>
    </div>
    <p>
        <span style="font-size: 1em;">
         Y más adelante hacer uso de la
        </span>
        <strong style="font-size: 1em;">
            ligadura dinámica
        </strong>
        <span style="font-size: 1em;">
         :
        </span>
    </p>
    <div class="highlighted-code language-java hightlight-3">
        <div>
         <pre>// Llamadas sólo a métodos de la interfaz
String contenido ;
contenido = objeto.devolverContenidoString() ;  // Ligadura dinámica con interfaces</pre>
        </div>
    </div>
</div><h1 class="title">
    6.5.- Conversión de objetos.
</h1>
<div class="iDevice_content">
    <p>
    </p>
    <p>
        Como ya has visto, en principio no se puede acceder a los
        <strong>
            miembros específicos
        </strong>
        de una
        <strong>
            subclase
        </strong>
        a través de una
        <strong>
            referencia
        </strong>
        a una
        <strong>
            superclase
        </strong>
        .
        Si deseas tener acceso a todos los métodos y atributos específicos del objeto
        <strong>
            subclase
        </strong>
        tendrás que realizar una
        <strong>
            conversión explícita
        </strong>
        (
        <strong>
         <span lang="en">
          casting
         </span>
        </strong>
        ) que convierta la referencia más general
        (
        <strong>
            superclase
        </strong>
        ) en la del tipo específico del objeto (
        <strong>
            subclase
        </strong>
        ).
    </p>
    <p>
        Para que puedas realizar conversiones entre distintas clases es obligatorio que exista una
        relación de
        <strong>
            herencia
        </strong>
        entre ellas (una debe ser clase derivada de la otra). Se
        realizará una
        <strong>
            conversión implícita o automática
        </strong>
        de
        <strong>
            subclase
        </strong>
        a
        <strong>
            superclase
        </strong>
        siempre que sea necesario, pues un objeto de tipo
        <strong>
            subclase
        </strong>
        siempre contendrá toda la información necesaria para ser considerado
        un objeto de la
        <strong>
            superclase
        </strong>
        .
    </p>
    <p>
        Ahora bien, la conversión en sentido contrario (de
        <strong>
            superclase
        </strong>
        a
        <strong>
            subclase
        </strong>
        ) debe hacerse de forma
        <strong>
            explícita
        </strong>
        y según el caso
        podría dar lugar a errores por falta de información (atributos) o de métodos. En tales casos se
        produce una
        <strong>
            excepción
        </strong>
        de&nbsp;tipo
        <strong>
            ClassCastException
        </strong>
        .
    </p>
    <p>
        Por ejemplo, imagina que tienes una clase
        <strong>
            A
        </strong>
        y una clase
        <strong>
            B
        </strong>
        ,
        <strong>
            subclase
        </strong>
        de
        <strong>
            A
        </strong>
        :
    </p>
    <div class="highlighted-code language-java">
        <div>
         <pre>class ClaseA &#123;
     public int atrib1;
&#125;

class ClaseB extends ClaseA &#123;
     public int atrib2;
&#125; </pre>
        </div>
    </div>
    <p>
        <span style="font-size: 1em;">
         A continuación declaras una variable referencia a la clase
        </span>
        <strong style="font-size: 1em;">
            A
        </strong>
        <span style="font-size: 1em;">
         (
        </span>
        <strong style="font-size: 1em;">
            superclase
        </strong>
        <span style="font-size: 1em;">
         ) pero sin embargo le asignas una referencia a un objeto de la clase
        </span>
        <strong style="font-size: 1em;">
            B
        </strong>
        <span style="font-size: 1em;">
         (
        </span>
        <strong style="font-size: 1em;">
            subclase
        </strong>
        <span style="font-size: 1em;">
         ) haciendo uso del
        </span>
        <strong style="font-size: 1em;">
            polimorfismo
        </strong>
        <span style="font-size: 1em;">
         :
        </span>
    </p>
    <div class="highlighted-code language-java hightlight-2">
        <div>
         <pre>A obj ;  // Referencia a objetos de la clase A
obj = new B() ; // Referencia a objetos clase A, pero apunta realmente a objeto clase B (polimorfismo)</pre>
        </div>
    </div>
    <p>
        <span style="font-size: 1em;">
         El objeto que acabas de crear como
        </span>
        <strong style="font-size: 1em;">
            instancia de la clase B
        </strong>
        <span style="font-size: 1em;">
         (
        </span>
        <strong style="font-size: 1em;">
            subclase
        </strong>
        <span style="font-size: 1em;">
         de
        </span>
        <strong style="font-size: 1em;">
            A
        </strong>
        <span style="font-size: 1em;">
         ) contiene más información que la que la referencia
        </span>
        <strong style="font-size: 1em;">
            obj
        </strong>
        <span style="font-size: 1em;">
         te permite en principio acceder sin que el compilador genere un error (pues es de clase
        </span>
        <strong style="font-size: 1em;">
            A
        </strong>
        <span style="font-size: 1em;">
         ). En concreto los objetos de la clase
        </span>
        <strong style="font-size: 1em;">
            B
        </strong>
        <span style="font-size: 1em;">
         disponen de
        </span>
        <strong style="font-size: 1em;">
            atrib1
        </strong>
        <span style="font-size: 1em;">
         y
        </span>
        <strong style="font-size: 1em;">
            atrib2
        </strong>
        <span style="font-size: 1em;">
         , mientras que los objetos de la clase
        </span>
        <strong style="font-size: 1em;">
            A
        </strong>
        <span style="font-size: 1em;">
         sólo de
        </span>
        <strong style="font-size: 1em;">
            atrib1
        </strong>
        <span style="font-size: 1em;">
         . Para acceder a esa información adicional de la clase especializada (
        </span>
        <strong style="font-size: 1em;">
            atrib2
        </strong>
        <span style="font-size: 1em;">
         ) tendrás que realizar una
        </span>
        <strong style="font-size: 1em;">
            conversión explícita
        </strong>
        <span style="font-size: 1em;">
         (
        </span>
        <strong style="font-size: 1em;">
         <span lang="en">
          casting
         </span>
        </strong>
        <span style="font-size: 1em;">
         ):
        </span>
    </p>
    <div class="highlighted-code language-java hightlight-2">
        <div>
         <pre>// Casting del tipo A al tipo B (funcionará bien porque el objeto es realmente del tipo B)
System.out.printf ("obj.atrib2=%d", ((B) obj).atrib2);</pre>
        </div>
    </div>
    <p>
        Sin embargo si se hubiera tratado de una
        <strong>
            instancia de la clase A
        </strong>
        y hubieras
        intentado acceder al miembro
        <strong>
            atrib2
        </strong>
        , se habría producido una
        <strong>
            excepción
        </strong>
        de tipo
        <strong>
            ClassCastException
        </strong>
        :
    </p>
    <div class="highlighted-code language-java hightlight-2and7and10">
        <div>
         <pre>A obj;  // Referencia a objetos de la clase A
obj = new A() ;  // Referencia a objetos de la clase A, y apunta realmente a un objeto de la clase A

// Casting del tipo A al tipo B (puede dar problemas porque el objeto es realmente del tipo A):

// Funciona (la clase A tiene atrib1)
System.out.printf ("obj.atrib1=%d", ((B) obj).atrib1);

// ¡Error en ejecución! (la clase A no tiene atrib2). Producirá una ClassCastException.
System.out.printf ("obj.atrib2=%d", ((B) obj).atrib2);  </pre>
        </div>
    </div>
</div><h1 class="title">
    Anexo I.- Elaboración de los constructores de la clase
    Rectangulo.
</h1>
<div class="iDevice_content">
    <p>

        <strong>
            ENUNCIADO
        </strong>
    </p>
    <p>
        Intenta rescribir los constructores de la clase
        <strong>
            Rectangulo
        </strong>
        teniendo en cuenta
        ahora su nueva estructura de atributos (dos objetos de la clase
        <strong>
            Punto
        </strong>
        , en lugar
        de cuatro elementos de tipo
        <strong>
            double
        </strong>
        ):
    </p>
    <ol start="1" type="1">
        <li>
            Un constructor sin parámetros (para sustituir al constructor por defecto) que haga que los
            valores iniciales de las esquinas del rectángulo sean (0,0) y (1,1).
        </li>
        <li>
            Un constructor con cuatro parámetros,
            <strong>
                x1
            </strong>
            ,
            <strong>
                y1
            </strong>
            ,
            <strong>
                x2
            </strong>
            ,
            <strong>
                y2
            </strong>
            , que cree un rectángulo con los vértices (x1, y1) y
            (x2, y2).
        </li>
        <li>
            Un constructor con dos parámetros,
            <strong>
                punto1
            </strong>
            ,
            <strong>
                punto2
            </strong>
            , que
            rellene los valores iniciales de los atributos del rectángulo con los valores proporcionados
            a través de los parámetros.
        </li>
        <li>
            Un constructor con dos parámetros,
            <strong>
                base
            </strong>
            y
            <strong>
                altura
            </strong>
            , que cree
            un rectángulo donde el vértice inferior derecho esté ubicado en la posición (0,0) y que
            tenga una base y una altura tal y como indican los dos parámetros proporcionados.
        </li>
        <li>
            Un constructor copia.
        </li>
    </ol>
    <p>
    </p>
    <p>
        <strong>
            POSIBLE SOLUCIÓN
        </strong>
    </p>
    <p>
        Durante el proceso de creación de un objeto (
        <strong>
            constructor
        </strong>
        ) de la
        <strong>
            clase
            contenedora
        </strong>
        (en este caso
        <strong>
            Rectangulo
        </strong>
        ) hay que tener en cuenta también
        la creación (llamada a
        <strong>
            constructores
        </strong>
        ) de aquellos objetos que son contenidos
        (en este caso objetos de la clase
        <strong>
            Punto
        </strong>
        ).
    </p>
    <p>
        En el caso del primer
        <strong>
            constructor
        </strong>
        , habrá que crear dos
        <strong>
            puntos
        </strong>
        con las coordenadas (0,0) y (1,1) y asignarlos a los atributos correspondientes (
        <strong>
            vertice1
        </strong>
        y
        <strong>
            vertice2
        </strong>
        ):
    </p>
    <div class="codigo elemento_centrado" style="width: 25.8em;">
        <div class="texto_izquierda">
         <pre>public Rectangulo () &#123;
</pre>
            <pre>     this.vertice1= new Punto (0,0);
</pre>
            <pre>     this.vertice2= new Punto (1,1);
</pre>
            <pre>&#125;
</pre>
        </div>
    </div>
    <p>
    </p>
    <p>
        Para el segundo
        <strong>
            constructor
        </strong>
        habrá que crear dos puntos con las coordenadas
        <strong>
            x1
        </strong>
        ,
        <strong>
            y1
        </strong>
        ,
        <strong>
            x2
        </strong>
        ,
        <strong>
            y2
        </strong>
        que han sido
        pasadas como parámetros:
    </p>
    <div class="codigo elemento_centrado" style="width: 40.1em;">
        <div class="texto_izquierda">
         <pre>public Rectangulo (double x1, double y1, double x2, double y2) &#123;
</pre>
            <pre>     this.vertice1= new Punto (x1, y1);
</pre>
            <pre>     this.vertice2= new Punto (x2, y2);
</pre>
            <pre>&#125;
</pre>
        </div>
    </div>
    <p>
    </p>
    <p>
        En el caso del tercer
        <strong>
            constructor
        </strong>
        puedes utilizar directamente los dos puntos
        que se pasan como parámetros para construir los vértices del rectángulo:
    </p>
    <div class="codigo elemento_centrado" style="width: 33.5em;">
        <div class="texto_izquierda">
         <pre>public Rectangulo (Punto vertice1, Punto vertice2) &#123;
</pre>
            <pre>     this.vertice1= vertice1;
</pre>
            <pre>     this.vertice2= vertice2;
</pre>
            <pre>&#125;
</pre>
        </div>
    </div>
    <p>
    </p>
    <p>
        Ahora bien, esto podría ocasionar un
        <strong>
            efecto colateral
        </strong>
        no deseado si esos objetos
        de tipo
        <strong>
            Punto
        </strong>
        son modificados en el futuro desde el código cliente del
        <strong>
            constructor
        </strong>
        (no sabes si esos puntos fueron creados especialmente para ser usados por el rectángulo o si
        pertenecen a otro objeto que podría modificarlos más tarde).
    </p>
    <p>
        Por tanto, para este caso quizá fuera recomendable crear dos nuevos puntos a imagen y semejanza
        de los puntos que se han pasado como parámetros. Para ello tendrías dos opciones:
    </p>
    <ol start="1" type="1">
        <li>
            Llamar al
            <strong>
                constructor
            </strong>
            de la clase
            <strong>
                Punto
            </strong>
            con los valores de
            los atributos (x, y).
        </li>
        <li>
            Llamar al
            <strong>
                constructor copia
            </strong>
            de la clase
            <strong>
                Punto
            </strong>
            , si es que
            se dispone de él.
        </li>
    </ol>
    <p>
        Aquí tienes las dos posibles versiones:
    </p>
    <p>
        <strong>
            Constructor
        </strong>
        que “extrae” los atributos de los parámetros y crea nuevos objetos:
    </p>
    <div class="codigo elemento_centrado" style="width: 46.7em;">
        <div class="texto_izquierda">
         <pre>public Rectangulo (Punto vertice1, Punto vertice2) &#123;
</pre>
            <pre>     this.vertice1= new Punto (vertice1.getX(), vertice1.getY() );
</pre>
            <pre>     this.vertice2= new Punto (vertice2.getX(), vertice2.getY() );
</pre>
            <pre>&#125;
</pre>
        </div>
    </div>
    <p>
    </p>
    <p>
        Constructor que crea los nuevos objetos mediante el
        <strong>
            constructor copia
        </strong>
        de los
        parámetros:
    </p>
    <div class="codigo elemento_centrado" style="width: 46.7em;">
        <div class="texto_izquierda">
         <pre>public Rectangulo (Punto vertice1, Punto vertice2) &#123;
</pre>
            <pre>     this.vertice1= new Punto (vertice1);
</pre>
            <pre>     this.vertice2= new Punto (vertice2);
</pre>
            <pre>&#125;
</pre>
        </div>
    </div>
    <p>
    </p>
    <p>
        En este segundo caso puedes observar la utilidad de los
        <strong>
            constructores de copia
        </strong>
        a
        la hora de tener que
        <strong>
            clonar
        </strong>
        objetos (algo muy habitual en las
        inicializaciones).
    </p>
    <p>
        Para el caso del
        <strong>
            constructor
        </strong>
        que recibe como parámetros la base y la altura,
        habrá que crear sendos vértices con valores (0,0) y (0 + base, 0 + altura), o lo que es lo
        mismo: (0,0) y (base, altura).
    </p>
    <div class="codigo elemento_centrado" style="width: 33.5em;">
        <div class="texto_izquierda">
         <pre>public Rectangulo (double base, double altura) &#123;
</pre>
            <pre>     this.vertice1= new Punto (0,0);
</pre>
            <pre>     this.vertice2= new Punto (base, altura);
</pre>
            <pre>&#125;
</pre>
        </div>
    </div>
    <p>
    </p>
    <p>
        Quedaría finalmente por implementar el
        <strong>
            constructor copia
        </strong>
        :
    </p>
    <div class="codigo elemento_centrado" style="width: 34.6em;">
        <div class="texto_izquierda">
         <pre>// Constructor copia
</pre>
            <pre>public Rectangulo (Rectangulo r) &#123;
</pre>
            <pre>    this.vertice1= new Punto (r.getVertice1() );
</pre>
            <pre>    this.vertice2= new Punto (r.getVertice2() );
</pre>
            <pre>&#125;
</pre>
        </div>
    </div>
    <p>
    </p>
    <p>
        En este caso nuevamente volvemos a
        <strong>
            clonar
        </strong>
        los atributos
        <strong>
            vertice1
        </strong>
        y
        <strong>
            vertice2
        </strong>
        del objeto
        <strong>
            r
        </strong>
        que se ha
        pasado como parámetro para evitar tener que compartir esos atributos en los dos rectángulos.
    </p>
</div><h1 class="title">
    Anexo II.- Métodos para las clases heredadas Alumno y
    Profesor.
</h1>
<div class="iDevice_content">
    <p>

        <strong>
            ENUNCIADO
        </strong>
    </p>
    <p>
        Dadas las clases
        <strong>
            Alumno
        </strong>
        y
        <strong>
            Profesor
        </strong>
        que has utilizado
        anteriormente, implementa en ellas métodos
        <strong>
         <span lang="en">
          get
         </span>
        </strong>
        y
        <strong>
         <span lang="en">
          set
         </span>
        </strong>
        para trabajar con sus cinco atributos (tres
        heredados más dos específicos).
    </p>
    <p>
        <strong>
            POSIBLE SOLUCIÓN
        </strong>
    </p>
    <ol>
        <li>
            <p>
                <strong>
                    Clase Alumno.
                </strong>
            </p>
            <p>
                Se trata de heredar de la clase
                <strong>
                    Persona
                </strong>
                y por tanto utilizar con
                normalidad sus atributos heredados como si pertenecieran a la propia clase (de hecho se
                puede considerar que le pertenecen, dado que los ha heredado).
            </p>
            <div class="codigo elemento_centrado" style="width: 41.75em;">
                <div class="texto_izquierda">
                    <div style="background: #ffffff; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
            <pre>/**
 * Clase que representa a un alumno.
 * Hereda de la clase Persona.
 */
public class Alumno extends Persona  &#123;
    protected String grupo;
    protected double notaMedia;


    // Constructor
    // -----------
    /**
     * Constructor de la clase Alumno
     * &#64;param nombre            Nombre del alumno
     * &#64;param apellidos         Apellidos del alumno
     * &#64;param fechaNacimiento   Fecha de nacimiento del alumno
     * &#64;param grupo             Grupo al que pertenece el alumno
     * &#64;param notaMedia         Nota media del alumno
     */
    public Alumno (String nombre, String apellidos,
            LocalDate fechaNacimiento, String grupo, double notaMedia) &#123;
        super (nombre, apellidos, fechaNacimiento);
        this.grupo= grupo;
        this.notaMedia= notaMedia;
    &#125;


    /**
     * Getter del grupo
     * &#64;return Grupo al que pertenece el alumno
     */
    public String getGrupo ()&#123;
        return grupo;
    &#125;

    /**
     * Getter de la nota media
     * &#64;return Nota Nota media del alumno
     */
    public double getNotaMedia ()&#123;
        return notaMedia;
    &#125;

    /**
     * Setter del grupo
     * &#64;param grupo Grupo al que pertenece el alumno
     */
    public void setGrupo (String grupo)&#123;
        this.grupo= grupo;
    &#125;

    /**
     * Setter de la nota media
     * &#64;param notaMedia Nota media del alumno
     */
    public void setNotaMedia (double notaMedia)&#123;
        this.notaMedia= notaMedia;
    &#125;</pre>
                        <pre>&#125;</pre>
                        <pre> </pre>
                    </div>
                </div>
            </div>
            <p>
                Si te fijas, puedes utilizar sin problema la referencia
                <strong>
                    this
                </strong>
                a la propia
                clase con esos atributos heredados, pues pertenecen a la clase:
                <strong>
                    this.nombre
                </strong>
                ,
                <strong>
                    this.apellidos
                </strong>
                ,
                <abbr title="etcétera">
                    etc
                </abbr>
                .
                Ahora bien, los métodos
                <strong>
           <span lang="en">
            get
           </span>
                </strong>
                y
                <strong>
           <span lang="en">
            set
           </span>
                </strong>
                para los atributos heredados no tiene mucho
                sentido implementarlos, pues ya los tienes disponibles en la clase padre (
                <strong>
                    Persona
                </strong>
                ).
                Sólo tendría sentido hacer una redefinición o rescritura del método (&#64;Override) si
                queremos hacer algún tipo de cambio.
            </p>
        </li>
        <li>
            <p>
                <strong>
                    Clase Profesor.
                </strong>
            </p>
            <p>
                Seguimos exactamente el mismo procedimiento que con la clase
                <strong>
                    Alumno
                </strong>
                .
            </p>
            <div class="codigo elemento_centrado" style="width: 41.75em;">
                <div class="texto_izquierda">
                    <div style="background: #ffffff; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
            <pre>/**
 * Clase Profesor
 * Clase que contiene los atributos que representan a un profesor
 */
public class Profesor extends Persona &#123;
    String especialidad;
    double salario;

    // Constructor
    // -----------

    /**
     * Constructor de la clase Persona
     * &#64;param nombre            Nombre del profesor
     * &#64;param apellidos         Apellidos del profesor
     * &#64;param fechaNacimiento   Fecha de nacimiento del profesor
     * &#64;param especialidad      Especialidad del profesor
     * &#64;param salario           Salario del profesor
     */
    public Profesor (String nombre, String apellidos,
            LocalDate fechaNacimiento, String especialidad, double salario) &#123;
        super (nombre, apellidos, fechaNacimiento);
        this.especialidad= especialidad;
        this.salario= salario;
    &#125;


    /**
     * Getter de la especialidad del profesor
     * &#64;return Especialidad del profesor
     */
    public String getEspecialidad ()&#123;
        return especialidad;
    &#125;

    /**
     * Getter del salario del profesor
     * &#64;return Salario del profesor
     */
    public double getSalario ()&#123;
        return salario;
    &#125;

    /**
     * Setter del salario del profesor
     * &#64;param salario Salario del profesor
     */
    public void setSalario (double salario)&#123;
        this.salario= salario;
    &#125;

    /**
     * Setter de la especialidad del profesor
     * &#64;param especialidad Especialidad del profesor
     */
    public void setESpecialidad (String especialidad)&#123;
        this.especialidad= especialidad;
    &#125;&#125;
</pre>
                    </div>
                </div>
            </div>
            <p>
                Si te fijas, no es necesario escribir los métodos
                <strong>
           <span lang="en">
            get
           </span>
                </strong>
                y
                <strong>
           <span lang="en">
            set
           </span>
                </strong>
                para los
                tres atributos heredados, pues si defines esos seis métodos en la clase base, estas dos
                clases derivadas hubieran también heredado esos métodos. De esa manera evitas tener que
                escribir seis métodos en la clase
                <strong>
                    Alumno
                </strong>
                y otros seis en la clase
                <strong>
                    Profesor
                </strong>
                . Recuerda que
                <strong>
                    se pueden heredar tanto los atributos
                    como los métodos
                </strong>
                .
            </p>
            <p>
                Aquí tienes un ejemplo de cómo podrías haber definido la clase
                <strong>
                    Persona
                </strong>
                para
                que luego se hubieran podido heredar de ella sus métodos (y no sólo sus atributos):
            </p>
            <div class="codigo elemento_centrado" style="width: 41.75em;">
                <div class="texto_izquierda">
                    <div style="background: #ffffff; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
            <pre>/**
 * Clase abastracta Persona
 * Clase que representa a una persona.
 * No es instanciable.
 */
public abstract class Persona &#123;
    protected String nombre;
    protected String apellidos;
    protected LocalDate fechaNacimiento;

    // Constructores
    // -------------

    /**
     * Constructor de la clase Persona
     * &#64;param nombre            Nombre de la persona
     * &#64;param apellidos         Apellidos de la persona
     * &#64;param fechaNacimiento   Fecha de nacimiento de la persona
     */
    public Persona (String nombre, String apellidos,
            LocalDate fechaNacimiento) &#123;
        this.nombre= nombre;
        this.apellidos= apellidos;
        this.fechaNacimiento= fechaNacimiento;
    &#125;

    /**
     * Getter del atributo nombre
     * &#64;return Nombre de la persona
     */
    protected String getNombre ()&#123;
        return nombre;
    &#125;

    /**
     * Getter del atributo apellidos
     * &#64;return Apellidos de la persona
     */
    protected String getApellidos ()&#123;
        return apellidos;
    &#125;

    /**
     * Getter de la fecha de nacimiento
     * &#64;return Fecha de nacimiento de la persona
     */
    protected LocalDate getFechaNacimiento ()&#123;
        return this.fechaNacimiento;
    &#125;

    /**
     * Setter del nombre
     * &#64;param nombre Nombre de la persona
     */
    protected void setNombre (String nombre)&#123;
        this.nombre= nombre;
    &#125;

    /**
     * Setter de los apellidos
     * &#64;param apellidos Apellidos de la persona
     */
    protected void setApellidos (String apellidos)&#123;
        this.apellidos= apellidos;
    &#125;

    /**
     * ¨Setter de la fecha de nacimiento
     * &#64;param fechaNacim Fecha de nacimiento de la persona
     */
    protected void setFechaNacimiento (LocalDate fechaNacimiento)&#123;
        this.fechaNacimiento= fechaNacimiento;
    &#125;
</pre>
                    </div>
                </div>
            </div>
        </li>
    </ol>
</div><h1 class="title">
    Anexo III.- Métodos para los atributos de las clases Alumno y
    Profesor.
</h1>
<div class="iDevice_content">
    <p>

        <strong>
            ENUNCIADO
        </strong>
    </p>
    <p>
        Dadas las clases
        <strong>
            Persona
        </strong>
        ,
        <strong>
            Alumno
        </strong>
        y
        <strong>
            Profesor
        </strong>
        que has utilizado anteriormente, implementa métodos
        <strong>
         <span lang="en">
          get
         </span>
        </strong>
        y
        <strong>
         <span lang="en">
          set
         </span>
        </strong>
        en la clase
        <strong>
            Persona
        </strong>
        para trabajar
        con sus tres atributos y en las clases
        <strong>
            Alumno
        </strong>
        y
        <strong>
            Profesor
        </strong>
        para
        trabajar con sus cinco atributos (tres heredados más dos específicos), teniendo en cuenta que
        los métodos que ya hayas definido para
        <strong>
            Persona
        </strong>
        van a ser heredados en
        <strong>
            Alumno
        </strong>
        y en
        <strong>
            Profesor
        </strong>
        .
    </p>
    <p>
        <strong>
            POSIBLE SOLUCIÓN
        </strong>
    </p>
    <ol>
        <li>
            <p>
                <strong>
                    Clase Persona.
                </strong>
            </p>
            <div class="codigo elemento_centrado" style="width: 41.75em;">
                <div class="texto_izquierda">
                    <div style="background: #ffffff; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
            <pre>/**
 * Clase abastracta Persona
 * Clase que representa a una persona.
 * No es instanciable.
 */
public abstract class Persona &#123;
    protected String nombre;
    protected String apellidos;
    protected LocalDate fechaNacimiento;

    // Constructores
    // -------------

    /**
     * Constructor de la clase Persona
     * &#64;param nombre            Nombre de la persona
     * &#64;param apellidos         Apellidos de la persona
     * &#64;param fechaNacimiento   Fecha de nacimiento de la persona
     */
    public Persona (String nombre, String apellidos,
            LocalDate fechaNacimiento) &#123;
        this.nombre= nombre;
        this.apellidos= apellidos;
        this.fechaNacimiento= fechaNacimiento;
    &#125;

    /**
     * Getter del atributo nombre
     * &#64;return Nombre de la persona
     */
    protected String getNombre ()&#123;
        return nombre;
    &#125;

    /**
     * Getter del atributo apellidos
     * &#64;return Apellidos de la persona
     */
    protected String getApellidos ()&#123;
        return apellidos;
    &#125;

    /**
     * Getter de la fecha de nacimiento
     * &#64;return Fecha de nacimiento de la persona
     */
    protected LocalDate getFechaNacimiento ()&#123;
        return this.fechaNacimiento;
    &#125;

    /**
     * Setter del nombre
     * &#64;param nombre Nombre de la persona
     */
    protected void setNombre (String nombre)&#123;
        this.nombre= nombre;
    &#125;

    /**
     * Setter de los apellidos
     * &#64;param apellidos Apellidos de la persona
     */
    protected void setApellidos (String apellidos)&#123;
        this.apellidos= apellidos;
    &#125;

    /**
     * ¨Setter de la fecha de nacimiento
     * &#64;param fechaNacim Fecha de nacimiento de la persona
     */
    protected void setFechaNacimiento (LocalDate fechaNacimiento)&#123;
        this.fechaNacimiento= fechaNacimiento;
    &#125;&#125;
</pre>
                    </div>
                </div>
            </div>
            <p>
            </p>
        </li>
        <li>
            <p>
                <strong>
                    Clase Alumno.
                </strong>
            </p>
            <p>
                Al heredar de la clase
                <strong>
                    Persona
                </strong>
                tan solo es necesario escribir métodos
                para los nuevos atributos (
                <strong>
                    métodos especializados
                </strong>
                de acceso a los
                <strong>
                    atributos especializados
                </strong>
                ), pues los
                <strong>
                    métodos genéricos
                </strong>
                (de acceso a los
                <strong>
                    atributos genéricos
                </strong>
                ) ya forman parte de la clase al
                haberlos heredado.
            </p>
            <div class="codigo elemento_centrado" style="width: 34.6em;">
                <div class="texto_izquierda">
                    <div style="background: #ffffff; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
            <pre>/**
 * Clase que representa a un alumno.
 * Hereda de la clase Persona.
 */
public class Alumno extends Persona  &#123;
    protected String grupo;
    protected double notaMedia;


    // Constructor
    // -----------
    /**
     * Constructor de la clase Alumno
     * &#64;param nombre          Nombre del alumno
     * &#64;param apellidos       Apellidos del alumno
     * &#64;param fechaNacimiento Fecha de nacimiento del alumno
     * &#64;param grupo           Grupo al que pertenece el alumno
     * &#64;param notaMedia       Nota media del alumno
     */
    public Alumno (String nombre, String apellidos,
            LocalDate fechaNacimiento, String grupo,
            double notaMedia) &#123;
        super (nombre, apellidos, fechaNacimiento);
        this.grupo= grupo;
        this.notaMedia= notaMedia;
    &#125;


    /**
     * Getter del grupo
     * &#64;return Grupo al que pertenece el alumno
     */
    public String getGrupo ()&#123;
        return grupo;
    &#125;

    /**
     * Getter de la nota media
     * &#64;return Nota Nota media del alumno
     */
    public double getNotaMedia ()&#123;
        return notaMedia;
    &#125;

    /**
     * Setter del grupo
     * &#64;param grupo Grupo al que pertenece el alumno
     */
    public void setGrupo (String grupo)&#123;
        this.grupo= grupo;
    &#125;

    /**
     * Setter de la nota media
     * &#64;param notaMedia Nota media del alumno
     */
    public void setNotaMedia (double notaMedia)&#123;
        this.notaMedia= notaMedia;
    &#125;&#125;
</pre>
                    </div>
                </div>
            </div>
            <p>
            </p>
            <p>
                Aquí tienes una demostración práctica de cómo la herencia permite una reutilización
                eficiente del código, evitando tener que repetir atributos y métodos. Sólo has tenido
                que escribir cuatro métodos en lugar de diez.
            </p>
        </li>
        <li>
            <p>
                <strong>
                    Clase Profesor.
                </strong>
            </p>
            <p>
                Seguimos exactamente el mismo procedimiento que con la clase
                <strong>
                    Alumno
                </strong>
                .
            </p>
            <div class="codigo elemento_centrado" style="width: 37.9em;">
                <div class="texto_izquierda">
                    <div style="background: #ffffff; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
            <pre>/**
 * Clase Profesor
 * Clase que contiene los atributos que representan a un profesor
 */
public class Profesor extends Persona &#123;
    String especialidad;
    double salario;

    // Constructor
    // -----------

    /**
     * Constructor de la clase Persona
     * &#64;param nombre          Nombre del profesor
     * &#64;param apellidos       Apellidos del profesor
     * &#64;param fechaNacimiento Fecha de nacimiento del profesor
     * &#64;param especialidad    Especialidad del profesor
     * &#64;param salario         Salario del profesor
     */
    public Profesor (String nombre, String apellidos,
            LocalDate fechaNacimiento, String especialidad,
            double salario) &#123;
        super (nombre, apellidos, fechaNacimiento);
        this.especialidad= especialidad;
        this.salario= salario;
    &#125;


    /**
     * Getter de la especialidad del profesor
     * &#64;return Especialidad del profesor
     */
    public String getEspecialidad ()&#123;
        return especialidad;
    &#125;

    /**
     * Getter del salario del profesor
     * &#64;return Salario del profesor
     */
    public double getSalario ()&#123;
        return salario;
    &#125;

    /**
     * Setter del salario del profesor
     * &#64;param salario Salario del profesor
     */
    public void setSalario (double salario)&#123;
        this.salario= salario;
    &#125;

    /**
     * Setter de la especialidad del profesor
     * &#64;param especialidad Especialidad del profesor
     */
    public void setESpecialidad (String especialidad)&#123;
        this.especialidad= especialidad;
    &#125;
&#125;
</pre>
                    </div>
                </div>
            </div>
            <p>
            </p>
        </li>
    </ol>
</div><h1 class="title">
    Anexo IV.- Contextos del modificador final.
</h1>
<div class="iDevice_content">
    <p>

    </p>
    <table class="tabla">
        <caption>
            Distintos contextos en los que puede aparecer el modificador final
        </caption>
        <thead>
        <tr>
            <th scope="col">
                Lugar
            </th>
            <th scope="col">
                Función
            </th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>
                Como modificador de clase.
            </td>
            <td>
                La clase no puede tener subclases.
            </td>
        </tr>
        <tr>
            <td>
                Como modificador de atributo.
            </td>
            <td>
                El atributo no podrá ser modificado una vez que tome un valor. Sirve para definir
                constantes.
            </td>
        </tr>
        <tr>
            <td>
                Como modificador al declarar un método
            </td>
            <td>
                El método no podrá ser redefinido en una clase derivada.
            </td>
        </tr>
        <tr>
            <td>
                Como modificador al declarar una variable referencia.
            </td>
            <td>
                Una vez que la variable tome un valor referencia (un objeto), no se podrá cambiar. La
                variable siempre apuntará al mismo objeto, lo cual no quiere decir que ese objeto no
                pueda ser modificado internamente a través de sus métodos. Pero la variable no podrá
                apuntar a otro objeto diferente.
            </td>
        </tr>
        <tr>
            <td>
                Como modificador en un parámetro de un método.
            </td>
            <td>
                El valor del parámetro (ya sea un tipo primitivo o una referencia) no podrá modificarse
                dentro del código del método.
            </td>
        </tr>
        </tbody>
    </table>
    <p>
    </p>
    <p>
        Veamos un ejemplo de cada posibilidad:
    </p>
    <ol>
        <li>
            <strong>
                <strong>
                    Modificador de una clase.
                    <br>
                    <br/></strong>
            </strong>
            <div class="highlighted-code language-java">
                <div>
           <pre>public final class ClaseSinDescendencia &#123;     // Clase “no heredable”
     …
&#125;</pre>
                </div>
            </div>
        </li>
        <li>
            <strong>
                <strong>
                    Modificador de un atributo.
                    <br>
                    <br/></strong>
            </strong>
            <div class="highlighted-code language-java">
                <div>
           <pre>public class ClaseEjemplo &#123;
   // Valor constante conocido en tiempo de compilación
   final double PI= 3.14159265;

   // Valor constante conocido solamente en tiempo de ejecución
   final int SEMILLA= (int) Math.random()*10+1;
   …
&#125;</pre>
                </div>
            </div>
        </li>
        <li>
            <strong>
                <strong>
                    Modificador de un método.
                    <br>
                    <br/></strong>
            </strong>
            <div class="highlighted-code language-java">
                <div>
           <pre>public final metodoNoRedefinible (int parametro1) &#123;   // Método “no redefinible”
     …
&#125;</pre>
                </div>
            </div>
        </li>
        <li>
            <strong>
                <strong>
                    Modificador en una variable referencia.
                    <br>
                    <br/></strong>
            </strong>
            <div class="highlighted-code language-java">
                <div>
           <pre>// Referencia constante: siempre se apuntará al mismo objeto Alumno recién creado,
// aunque este  objeto pueda sufrir modificaciones.
final Alumno PRIMER_ALUMNO= new Alumno (“Pepe”, “Torres”, 9.55);   // Ref. constante

// Si la variable no es una referencia (tipo primitivo), sería una constante más
// (como un atributo constante).
final int NUMERO_DIEZ= 10;     // Valor constante (dentro del ámbito de vida de la variable) </pre>
                </div>
            </div>
        </li>
        <li>
            <strong>
                <strong>
                    Modificador en un parámetro de un método.
                    <br>
                    <br/></strong>
            </strong>
            <div class="highlighted-code language-java">
                <div>
           <pre>void metodoConParametrosFijos (final int par1, final int par2) &#123;
     // Los parámetros “par1” y “par2” no podrán sufrir modificaciones aquí dentro
     …
&#125;</pre>
                </div>
            </div>
        </li>
    </ol>
</div><h1 class="title">
    Condiciones y términos de uso de los materiales
</h1>
<div class="iDevice_content">
    <div title="Información acerca de la licencia de los materiales">
        <p align="center" style="margin: 2px 2px;">
            <strong>
                Materiales desarrollados inicialmente por
                el Ministerio de Educación, Cultura y Deporte y actualizados por el profesorado de la
                Junta de Andalucía bajo licencia Creative Commons
                <abbr title="Reconocimiento-NoComercial-CompartirIgual">
                    BY-NC-SA.
                </abbr>
            </strong>
        </p>
        <p align="center" style="font-size: 0.8em; margin: 2px 2px;">
            <strong>
            </strong>
        </p>
        <p align="center" style="font-size: 0.8em; margin: 2px 2px;">
          <span>
           Antes de cualquier uso leer detenidamente el siguente
          </span>
            Aviso
            legal
        </p>
    </div>
</div>

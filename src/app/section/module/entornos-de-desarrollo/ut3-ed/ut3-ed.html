<h1 class="title">
    Diseño y realización de pruebas.
</h1><div class="iDevice_content">
</div><h1 class="title">
    1.- Planificación de las pruebas.
</h1><div class="iDevice_content">
    <p>
    </p>
</div><h1 class="title">
    2.- Tipos de prueba.
</h1><div class="iDevice_content">
</div><h1 class="title">
    2.1.- Funcionales.
</h1><div class="iDevice_content">
    <p>
    </p>
    <p>
        Estamos ante pruebas de la caja negra. Se trata de probar, si las salidas que devuelve la
        aplicación, o parte de ella, son las esperadas, en función de los parámetros de entrada que
        le pasemos. No nos interesa la implementación del
        software,


        Software

        Parte lógica del
        ordenador formado por un conjunto de instrucciones.
        solo si realiza las
        funciones que se esperan de él.
    </p>
    <p>
        Las pruebas funcionales siguen el enfoque de las pruebas de Caja Negra. Comprenderían
        aquellas actividades cuyo objetivo sea verificar una acción específica o funcional dentro
        del código de una aplicación. Las pruebas funcionales intentarían responder a las preguntas
        ¿puede el usuario hacer esto? o ¿funciona esta utilidad de la aplicación?
    </p>
    <p>
        Su principal cometido, va a consistir, en comprobar el correcto funcionamiento de los
        componentes de la aplicación informática. Para realizar este tipo de pruebas, se deben
        analizar las entradas y las salidas de cada componente, verificando que el resultado es el
        esperado. Solo se van a considerar las entradas y salidas del sistema, sin preocuparnos por
        la estructura interna del mismo.
    </p>
    <p>
        Si por ejemplo, estamos implementando una aplicación que realiza un determinado cálculo
        científico, en el enfoque de las pruebas funcionales, solo nos interesa verificar que ante
        una determinada entrada a ese programa el resultado de la ejecución del mismo devuelve como
        resultado los datos esperados. Este tipo de prueba, no consideraría, en ningún caso, el
        código desarrollado, ni el
        algoritmo


        Algoritmo

        Conjunto ordenado de pasos a seguir para la resolución
        de un problema.
        , ni la eficiencia, ni si hay partes del código
        innecesarias, etc.
    </p>
    <p>
        Dentro de las pruebas funcionales, podemos indicar tres tipos de pruebas:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Particiones equivalentes
            </strong>
            : La idea de este tipo de pruebas funcionales,
            es considerar el menor número posible de casos de pruebas, para ello, cada caso de
            prueba tiene que abarcar el mayor número posible de entradas diferentes. Lo que se
            pretende, es crear un conjunto de clases de equivalencia, donde la prueba de un valor
            representativo de la misma, en cuanto a la verificación de errores, sería extrapolable
            al que se conseguiría probando cualquier valor de la clase.
        </li>
        <li>
            <strong>
                Análisis de valores límite
            </strong>
            : En este caso, a la hora de implementar un
            caso de prueba, se van a elegir como valores de entrada, aquellos que se encuentra en el
            límite de las clases de equivalencia.
        </li>
        <li>
            <strong>
                Pruebas aleatorias
            </strong>
            : Consiste en generar entradas aleatorias para la
            aplicación que hay que probar. Se suelen utilizar generadores de prueba, que son capaces
            de crear un volumen de casos de prueba al azar, con los que será alimentada la
            aplicación. Esta tipo de pruebas, se suelen utilizar en
            aplicaciones


            Aplicaciones

            Conjuntos de programas informáticos que
            realizan tareas concretas.
            que no sean interactivas, ya que es muy
            difícil generar las secuencias de entrada adecuadas de prueba, para entornos
            interactivos.
        </li>
    </ul>
    <p>
        Existe otros tipos de pruebas funcionales, aunque todas comparten un mismo objetivo, y es
        comprobar, solo actuando en la interfaz de la aplicación, que los resultados que produce son
        los correctos en función de las entradas que se le introducen para probarlos.
    </p>
</div><h1 class="title">
    2.2.- Estructurales.
</h1><div class="iDevice_content">
    <br>
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>
    </div>
    <p>
        Ya
        hemos visto que las pruebas funcionales se centran en resultados, en
        lo que la aplicación hace, pero no en cómo lo hace.
    </p>
    <p>
        Para ver cómo el programa se va ejecutando, y así comprobar su
        corrección, se utilizan las pruebas estructurales, que se fijan en
        los caminos que se pueden recorrer:
    </p>
    <p>
        Las
        pruebas estructurales son el conjunto de pruebas de la Caja Blanca.
        Con este tipo de pruebas, se pretende verificar la estructura interna
        de cada componente de la aplicación, independientemente de la
        funcionalidad establecida para el mismo. Este tipo de pruebas, no
        pretenden comprobar la corrección de los resultados producidos por
        los distintos componentes, su función es comprobar que se van a
        ejecutar todas la instrucciones del programa, que no hay código no
        usado, comprobar que los caminos lógicos del programa se van a
        recorrer, etc.
    </p>
    <p>
        Este
        tipo de pruebas, se basan en unos criterios de cobertura lógica,
        cuyo cumplimiento determina la mayor o menor seguridad en la
        detección de errores. Los criterios de cobertura que se siguen son:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Cobertura
                de sentencias
            </strong>
            : se han de generar casos de pruebas suficientes
            para que cada instrucción del programa sea ejecutada, al menos, una
            vez.
        </li>
        <li>
            <strong>
                Cobertura
                de decisiones
            </strong>
            : se trata de crear los suficientes casos de prueba
            para que cada opción resultado de una prueba lógica del programa,
            se evalúe al menos una vez a cierto y otra a falso.
        </li>
        <li>
            <strong>
                Cobertura
                de condiciones
            </strong>
            : se trata de crear los suficientes casos de
            prueba para que cada elemento de una condición, se evalúe al menos
            una vez a falso y otra a verdadero.
        </li>
        <li>
            <strong>
                Cobertura
                de condiciones y decisiones
            </strong>
            : consiste en cumplir simultáneamente
            las dos anteriores.
        </li>
        <li>
            <strong>
                Cobertura
                de caminos
            </strong>
            : es el criterio más importante. Establece que se
            debe ejecutar al menos una vez cada secuencia de sentencias
            encadenadas, desde la sentencia inicial del programa, hasta su
            sentencia final. La ejecución de este conjunto de sentencias, se
            conoce como camino. Como el número de caminos que puede tener una
            aplicación, puede ser muy grande, para realizar esta prueba, se
            reduce el número a lo que se conoce como camino prueba.
        </li>
        <li>
            <strong>
                Cobertura
                del camino de prueba
            </strong>
            : Se pueden realizar dos variantes, una
            indica que cada bucle se debe ejecutar sólo una vez, ya que hacerlo
            más veces no aumenta la efectividad de la prueba y otra que
            recomienda que se pruebe cada bucle tres veces: la primera sin
            entrar en su interior, otra ejecutándolo una vez y otra más
            ejecutándolo dos veces.
        </li>
    </ul>
    <br/></div><h1 class="title">
    2.3.- Regresión.
</h1><div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>
    </div>
    <p>
        Durante el proceso de prueba, tendremos éxito si detectamos un posible fallo o error. La
        consecuencia directa de ese descubrimiento, supone la modificación del componente donde se
        ha detectado. Esta modificación, puede generar errores colaterales, que no existían antes.
        Como consecuencia, la modificación realizada nos obliga a repetir pruebas que hemos
        realizado con anterioridad.
    </p>
    <p>
        El objetivo de las pruebas de regresión, es comprobar que los cambios sobre un componente de
        una aplicación, no introduce un comportamiento no deseado o errores adicionales en otros
        componentes no modificados.
    </p>
    <p class="lista_verificacion">
        Las pruebas de
        regresión


        Regresión

        Pruebas que se
        diseña para detectar errores, cuando el software sufre modificaciones, a
        consecuencia de errores detectados en pruebas anteriores.
        se deben llevar
        a cabo cada vez que se hace un cambio en el sistema, tanto para corregir un error, como para
        realizar una mejora. No es suficiente probar sólo los componentes modificados o añadidos, o
        las
        funciones


        Función

        Partes de código
        muy pequeñas con una finalidad muy concreta.
        que en ellos se realizan,
        sino que también es necesario controlar que las modificaciones no produzcan efectos
        negativos sobre el mismo u otros componentes.
    </p>
    <p>
        Normalmente, este tipo de pruebas implica la repetición de las pruebas que ya se hayan
        realizado previamente, con el fin de asegurar que no se introducen errores que puedan
        comprometer el funcionamiento de otros componentes que no han sido modificados y confirmar
        que el sistema funciona correctamente una vez realizados los cambios.
    </p>
    <p>
        En un contexto más amplio, las pruebas de software con éxito, son aquellas que dan como
        resultado el descubrimiento de errores. Como consecuencia del descubrimiento de errores, se
        procede a su corrección, lo que implica la modificación de algún componente del software que
        se está desarrollando, tanto del programa, de la documentación y de los datos que lo
        soportan. La prueba de regresión es la que nos ayuda a asegurar que estos cambios no
        introducen un comportamiento no deseado o errores adicionales. La prueba de regresión se
        puede hacer manualmente, volviendo a realizar un subconjunto de todos los casos de prueba o
        utilizando herramientas automáticas.
    </p>
    <p>
        El conjunto de pruebas de regresión contiene tres clases diferentes de clases de prueba:
    </p>
    <ul class="lista_verificacion">
        <li>
            Una muestra representativa de pruebas que ejercite todas las funciones del software;
        </li>
        <li>
            Pruebas adicionales que se centran en las funciones del software que se van a ver
            probablemente afectadas por el cambio;
        </li>
        <li>
            Pruebas que se centran en los componentes del software que han cambiado.
        </li>
    </ul>
    <p>
        Para evitar que el número de pruebas de regresión crezca demasiado, se deben de diseñar para
        incluir sólo aquellas pruebas que traten una o más clases de errores en cada una de las
        funciones principales del programa. No es práctico ni eficiente volver a ejecutar cada
        prueba de cada función del programa después de un cambio.
    </p>
</div><h1 class="title">
    3.- Procedimientos y casos de prueba.
</h1><div class="iDevice_content">
    <p>
    </p>
    <p>
        En BK, ya tienen el proyecto bastante avanzado. Ahora llega una parte clave: definir
        las partes del sistema que se van a probar y establecer los casos de prueba para
        realizarla. Ana va a participar, pero cuando se habla de
        procedimientos


        Procedimiento

        Igual
        que las funciones, pero al ejecutarse no devuelven ningún valor.
        y casos de prueba, se siente perdida. A ella le va a tocar ejecutar los casos de
        prueba.
    </p>
</div><h1 class="title">
    4.- Herramientas de depuración.
</h1><div class="iDevice_content">
</div><h1 class="title">
    4.1.- Puntos de ruptura.
</h1><div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">

        </div>
    </div>
    <p>
        Dentro
        del menú de depuración, nos encontramos con la opción insertar
        punto de ruptura (
        <span lang="en">
         breakpoint
        </span>
        ).
        Se selecciona la línea de código donde queremos que el programa se
        pare, para a partir de ella, inspeccionar variables, o realizar una
        ejecución paso a paso, para verificar la corrección del código
    </p>
    <p>
        Durante la prueba de un
        programa, puede ser interesante la verificación de determinadas
        partes del código. No nos interesa probar todo el programa, ya que
        hemos delimitado el punto concreto donde inspeccionar. Para ello,
        utilizamos los puntos de ruptura.
    </p>
    <p>
        Los puntos de ruptura son
        marcadores que pueden establecerse en cualquier línea de código
        ejecutable (no sería válido un comentario, o una línea en blanco).
        Una vez insertado el punto de ruptura, e iniciada la depuración, el
        programa a evaluar se ejecutaría hasta la línea marcada con el
        punto de ruptura. En ese momento, se pueden realizar diferentes
        labores, por un lado, se pueden examinar las variables, y comprobar
        que los valores que tienen asignados son correctos, o se pueden
        iniciar una depuración paso a paso, e ir comprobando el camino que
        toma el programa a partir del punto de ruptura. Una vez realiza la
        comprobación, podemos abortar el programa, o continuar la ejecución
        normal del mismo.
    </p>
    <p>
        Dentro de una aplicación,
        se pueden insertar varios puntos de ruptura, y se pueden eliminar con
        la misma facilidad con la que se insertan.
    </p>
</div><h1 class="title">
    4.2.- Tipos de ejecución.
</h1><div class="iDevice_content">
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>
    </div>
    <p>
        Para poder depurar un
        programa, podemos ejecutar el programa de diferentes formas, de
        manera que en función del problema que queramos solucionar, nos
        resulte más sencillo un método u otro. Nos encontramos con lo
        siguientes tipo de ejecución: paso a paso por instrucción, paso a
        paso por procedimiento, ejecución hasta una instrucción, ejecución
        de un programa hasta el final del programa,
    </p>
    <ul class="lista_verificacion">
        <li>
            Algunas veces es
            necesario ejecutar un programa línea por línea, para buscar y
            corregir errores lógicos. El
            <strong>
                avance paso a paso
            </strong>
            a lo largo
            de una parte del programa puede ayudarnos a verificar que el código
            de un método se ejecute en forma correcta.
        </li>
        <li>
            El
            <strong>
                paso a paso
                por procedimientos
            </strong>
            , nos permite introducir los parámetro que
            queremos a un método o función de nuestro programa, pero en vez de
            ejecutar instrucción por instrucción ese método, nos devuelve su
            resultado. Es útil, cuando hemos comprobado que un procedimiento
            funciona correctamente, y no nos interese volver a depurarlo, sólo
            nos interesa el valor que devuelve.
        </li>
        <li>
            En la
            <strong>
                ejecución
                hasta una instrucción
            </strong>
            , el depurador ejecuta el programa, y se
            detiene en la instrucción donde se encuentra el cursor, a partir de
            ese punto, podemos hacer una depuración paso a paso o por
            procedimiento.
        </li>
        <li>
            En la
            <strong>
                ejecución
                de un programa hasta el final
            </strong>
            del programa, ejecutamos las
            instrucciones de un programa hasta el final, sin detenernos en las
            instrucciones intermedias.
        </li>
    </ul>
</div><h1 class="title">
    4.3.- Examinadores de variables.
</h1><div class="iDevice_content">
    <p>
        Durante el proceso de
        implementación y prueba de software, una de las maneras más comunes
        de comprobar que la aplicación funciona de manera adecuada, es
        comprobar que las variables vayan tomando los valores adecuados en
        cada momento.
    </p>
    <p>
        Los examinadores de
        variables, forman uno de los elementos más importantes del proceso
        de depuración de un programa. Iniciado el proceso de depuración,
        normalmente con la ejecución paso a paso, el programa avanza
        instrucción por instrucción. Al mismo tiempo, las distintas
        variables, van tomando diferentes valores. Con los examinadores de
        variables, podemos comprobar los distintos valores que adquiere las
        variables, así como su tipo. Esta herramienta es de gran utilidad
        para la detección de errores.
    </p>
    <div class="elemento_derecha">
        <div class="elemento_centrado">

        </div>
    </div>
    <p>
        En el caso del entorno de
        desarrollo
        <span lang="en">
         NetBeans
        </span>
        ,
        nos encontramos con un panel llamado Ventana de Inspección. En la
        ventana de inspección, se pueden ir agregando todas aquellas
        variables de las que tengamos interés en inspeccionar su valor.
        Conforme el programa se vaya ejecutando,
        <span lang="en">
         NetBeans
        </span>
        irá mostrando los valores que toman las variables en al ventana de
        inspección.
    </p>
    <p>
        Como podemos apreciar, en
        una ejecución paso a paso, el programa llega a una función de
        nombre potencia. Esta función tiene definida tres variables. A lo
        largo de la ejecución del bucle, vemos como la variable
        <strong>
            result
        </strong>
        ,
        van cambiando de valor. Si con valores de entrada para los que
        conocemos el resultado, la función no devuelve el valor esperado,
        "Examinando las variables" podremos encontrar la instrucción
        incorrecta.
    </p>
</div><h1 class="title">
    5.- Validaciones.
</h1><div class="iDevice_content">
</div><h1 class="title">
    6.- Pruebas de código.
</h1><div class="iDevice_content">
</div><h1 class="title">
    6.1.- Cubrimiento.
</h1><div class="iDevice_content">
    <p>
        Esta tarea la realiza el programador
        o programadora y consiste en comprobar que los caminos definidos en
        el código, se pueden llegar a recorrer.
    </p>
</div><h1 class="title">
    6.2.- Valores límite.
</h1><div class="iDevice_content">
    <div class="elemento_izquierda">
        <div class="elemento_centrado">

        </div>
    </div>
    <p>
        En el código Java adjunto, aparecen dos funciones
        que reciben el parámetro x. En la
        <strong>
            función1
        </strong>
        ,
        el parámetro es de tipo real y en la
        <strong>
            función2
        </strong>
        ,
        el parámetro es de tipo entero.
    </p>
    <p>
        Como se aprecia, el código de las dos funciones es
        el mismo, sin embargo, los casos de prueba con valores límite va a
        ser diferente.
    </p>
    <p>
        La experiencia ha
        demostrado que los casos de prueba que obtienen una mayor
        probabilidad de éxito, son aquellos que trabajan con valores límite.
    </p>
    <p>
        Esta técnica, se suele
        utilizar como complementaria de las particiones equivalentes, pero se
        diferencia, en que se suelen seleccionar, no un conjunto de valores,
        sino unos pocos, en el límite del rango de valores aceptado por el
        componente a probar.
    </p>
    <p>
        Cuando hay que
        seleccionar una valor para realizar una prueba, se escoge aquellos
        que están situados justo en el límite de los valores admitidos.
    </p>
    <div style="clear: both">
    </div>
    <p>
        Por ejemplo, supongamos
        que queremos probar el resultado de la ejecución de una función,
        que recibe un parámetro x:
    </p>
    <ul class="lista_verificacion">
        <li>
            Si el parámetro x
            de entrada tiene que ser mayor estricto que 5, y el valor es real,
            los valores límite pueden ser 4,99 y 5,01.
        </li>
        <li>
            Si el parámetro de
            entrada x está comprendido entre -4 y +4, suponiendo que son
            valores enteros, los valores límite serán -5, -4 ,-3,3, 4 y 5.
        </li>
    </ul>
</div><h1 class="title">
    6.3.- Clases de equivalencia.
</h1><div class="iDevice_content">
    <p>
        Las clases de
        equivalencia, es un tipo de prueba funcional, en donde cada caso de
        prueba, pretende cubrir el mayor número de entradas posible.
    </p>
    <p>
        El dominio de valores de
        entrada, se divide en número finito de clases de equivalencia. Como
        la entrada está dividida en un conjunto de clases de equivalencia,
        la prueba de un valor representativo de cada clase, permite suponer
        que el resultado que se obtiene con él, será el mismo que con
        cualquier otro valor de la clase.
    </p>
    <p>
        Cada clase de
        equivalencia debe cumplir:
    </p>
    <ul class="lista_verificacion">
        <li>
            Si un parámetro de
            entrada debe estar comprendido entre un determinado rango, hay tres
            clases de equivalencia: por debajo, en y por encima.
        </li>
        <li>
            Si una entrada
            requiere un valor entre los de un conjunto, aparecen dos clase de
            equivalencia: en el conjunto o fuera de él.
        </li>
        <li>
            Si una entrada es
            booleana, hay dos clases: sí o no.
        </li>
        <li>
            Los mismos criterios
            se aplican a las salidas esperadas: hay que intentar generar
            resultados en todas y cada una de las clases.
        </li>
    </ul>
    <p>
        En este ejemplo, las clase de equivalencia serían:
    </p>
</div><h1 class="title">
    7.- Normas de calidad.
</h1><div class="iDevice_content">
    <p>
    </p>
    <p>
        Las aplicaciones que desarrolla BK Programación, se caracterizan por cumplir todos
        los estándares de calidad de la industria. Como no podía ser de otro modo, a la hora
        de realizar las pruebas, también van a seguir los estándares más actuales del
        mercado. Ada se va a encargar de supervisar el cumplimiento de los estándares más
        actuales.
    </p>
</div><h1 class="title">
    8.- Pruebas unitarias.
</h1><div class="iDevice_content">
</div><h1 class="title">
    8.1..- Herramientas para Java.
</h1><div class="iDevice_content">
    <p>
        Entre la herramientas que nos podemos encontrar en el mercado, para poder realizar las
        pruebas, las más destacadas serían:
    </p>
    <p>
    </p>
    <ul class="lista_verificacion">
        <li>
         <span lang="en">
          Jtiger
         </span>
            :
            <ul>
                <li>
           <span lang="en" title="Marco de trabajo o máquina virtual">
            Framework
           </span>
                    de
                    pruebas unitarias para Java (1.5).
                </li>
                <li>
                    Es de código abierto.
                </li>
                <li>
                    Capacidad para exportar informes en
                    <abbr title="HyperText Markup Language">
                        HTML
                    </abbr>
                    ,
                    <abbr title="Extensible Markup Language">
                        XML
                    </abbr>
                    o texto plano.
                </li>
                <li>
                    Es posible ejecutar casos de prueba de
                    <span lang="en">
            Junit
           </span>
                    mediante un
                    <span lang="en">
            plugin
           </span>
                    .
                </li>
                <li>
                    Posee una completa variedad de aserciones como la comprobación de cumplimiento
                    del contrato en un método.
                </li>
                <li>
                    Los
                    <strong>
                        metadatos


                        Metadatos

                        Conjunto
                        de datos que se utilizan para describir otros datos.
                    </strong>
                    de los casos de prueba son especificados como anotaciones del lenguaje
                    Java
                </li>
                <li>
                    Incluye una tarea de
                    <span lang="en">
            Ant
           </span>
                    para automatizar las pruebas.
                </li>
                <li>
                    Documentación muy completa en JavaDoc, y una pagina web con toda la información
                    necesaria para comprender su uso, y utilizarlo con IDE como Eclipse.
                </li>
                <li>
                    El
                    <strong>
                        Framework


                        Framework

                        Estructura
                        conceptual y tecnológica de soporte definida, normalmente con
                        módulos de software concretos, con base en la cual otro proyecto de
                        software puede ser organizado y desarrollado.
                    </strong>
                    incluye pruebas unitarias sobre sí mismo.
                </li>
            </ul>
        </li>
        <li>
         <span lang="en">
          TestNG
         </span>
            :
            <ul>
                <li>
                    Esta inspirado en
                    <span lang="en">
            JUnit
           </span>
                    y
                    <span lang="en">
            NUnit
           </span>
                    .
                </li>
                <li>
                    Está diseñado para cubrir todo tipo de pruebas, no solo las unitarias, sino
                    también las funcionales, las de integración ...
                </li>
                <li>
                    Utiliza las anotaciones de Java 1.5 (desde mucho antes que Junit).
                </li>
                <li>
                    Es compatible con pruebas de
                    <span lang="en">
            Junit
           </span>
                    .
                </li>
                <li>
                    Soporte para el paso de parámetros a los métodos de pruebas.
                </li>
                <li>
                    Permite la distribución de pruebas en maquinas esclavas.
                </li>
                <li>
                    Soportado por gran variedad de
                    <span lang="en">
            plug-ins
           </span>
                    (Eclipse,
                    <span lang="en">
            NetBeans
           </span>
                    , IDEA ...)
                </li>
                <li>
                    Los clases de pruebas no necesitan implementar ninguna interfaz ni extender
                    ninguna otra clase.
                </li>
                <li>
                    Una vez compiladas la pruebas, estas se pueden invocar desde la linea de
                    comandos con una tarea de
                    <span lang="en">
            Ant
           </span>
                    o con un fichero XML.
                </li>
                <li>
                    Los métodos de prueba se organizan en grupos (un método puede pertenecer a uno o
                    varios grupos).
                </li>
            </ul>
        </li>
        <li>
            Junit:
            <ul>
                <li>
                    Framework de pruebas unitarias creado por
                    <span lang="en">
            Erich Gamma
           </span>
                    y
                    <span lang="en">
            Kent Beck
           </span>
                    .
                </li>
                <li>
                    Es una herramienta de código abierto.
                </li>
                <li>
                    Multitud de documentación y ejemplos en la web.
                </li>
                <li>
                    Se ha convertido en el estándar de hecho para las pruebas unitarias en Java.
                </li>
                <li>
                    Soportado por la mayoría de los IDE como eclipse o
                    <span lang="en">
            Netbeans
           </span>
                    .
                </li>
                <li>
                    Es una implementación de la arquitectura
                    <span lang="en">
            xUnit
           </span>
                    para los
                    <span lang="en">
            frameworks
           </span>
                    de pruebas unitarias.
                </li>
                <li>
                    Posee una comunidad mucho mayor que el resto de los
                    <span lang="en">
            frameworks
           </span>
                    de pruebas en Java.
                </li>
                <li>
                    Soporta múltiples tipos de aserciones.
                </li>
                <li>
                    Desde la versión 4 utiliza las anotaciones del
                    <span lang="en">
            JDK
           </span>
                    1.5 de
                    Java.
                </li>
                <li>
                    Posibilidad de crear informes en HTML.
                </li>
                <li>
                    Organización de las pruebas en
                    <span lang="en">
            Suites
           </span>
                    de pruebas.
                </li>
                <li>
                    Es la herramienta de pruebas más extendida para el lenguaje Java.
                </li>
                <li>
                    Los entornos de desarrollo para Java,
                    <span lang="en">
            NetBeans
           </span>
                    y Eclipse,
                    incorporan un
                    <span lang="en">
            plugin
           </span>
                    para
                    <span lang="en">
            Junit
           </span>
                    .
                </li>
            </ul>
        </li>
    </ul>
</div><h1 class="title">
    8.2.- Herramientas para otros lenguajes.
</h1><div class="iDevice_content">
</div><h1 class="title">
    9.- Automatización de la prueba.
</h1><div class="iDevice_content">
    <p>
    </p>
    <p>
        Juan está realizando pruebas de la unidad, es decir, comprueba el correcto
        funcionamiento de los métodos que ha implantado. Para ello, utiliza las herramienta
        de prueba incorporadas en el entorno de desarrollo. En su caso, ya que está
        utilizando
        <span lang="en">
           NetBeans
          </span>
        , se decanta por
        <span lang="en">
           Junit
          </span>
        . Ana está muy interesada en conocer esta herramienta, que
        ayuda notablemente en el proceso de pruebas.
    </p>
</div><h1 class="title">
    10.- Documentación de la prueba.
</h1><div class="iDevice_content">
</div><h1 class="title">
    11.- Enlaces de refuerzo y ampliación.
</h1><div class="iDevice_content">
    <p style="text-align: center;">
          <span style="text-decoration: underline;">
           <strong>
            Diseño
											y realización de pruebas en Java con las herramientas de depuración de
											NetBeans y el framework de pruebas unitarias JUnit
           </strong>
          </span>
    </p>
    <ul class="lista_verificacion">
        <li>
            JUnit Lambda:
            http://junit.org/index.html
        </li>
    </ul>
    <ul class="lista_verificacion">
        <li>
            Tutorial de JUnit con un ejemplo:
            https://dzone.com/articles/junit-tutorial-beginners
        </li>
    </ul>
    <ul class="lista_verificacion">
        <li>
            Explicación y ejemplos de uso de las herramientas de depuración del IDE
            NetBeans:
            http://puntocomnoesunlenguaje.blogspot.com.es/2014/11/netbeans-debugger-java.html

        </li>
    </ul>
    <p>
    </p>
    <p style="text-align: center;">
          <span style="text-decoration: underline;">
           <strong>
            <br style="clear: both;">
            Diseño y realización de pruebas en JavaScript con
            <strong>
             las herramientas de depuración&nbsp;Firefox Developer
												Tools
            </strong>
            y/o&nbsp;Chrome&nbsp;DevTools junto con
											el
            <strong>
             el framework de pruebas unitarias
												QUnit
            </strong>
           <br/></strong>
          </span>
    </p>
    <ul class="lista_verificacion">
        <li>
            Devtools, Herramientas de depuración con el navegador Chrome
            https://developers.google.com/web/tools/chrome-devtools/
        </li>
    </ul>
    <ul class="lista_verificacion">
        <li>
            Firefox Developer Tools, Herramientas de depuración con el navegador Firefox
            https://developer.mozilla.org/en-US/docs/Tools
        </li>
    </ul>
    <ul class="lista_verificacion">
        <li>
            QUnit, Un framework para pruebas unitarias con código JavaScript.:
            https://qunitjs.com/
        </li>
    </ul>
    <p>
    </p>
</div><h1 class="title">
    Anexo I.- Norma ISO/IEC 29119.
</h1><div class="iDevice_content">
    <div class="elemento_centrado">
        <p>

        </p>
    </div>
    <p>
        La norma ISO/IEC 29119 se compone la siguientes partes:
    </p>
    <ul class="lista_verificacion">
        <li>
            Parte 1. Conceptos y vocabulario:
            <ul class="lista_verificacion">
                <li>
                    Introducción a la prueba.
                </li>
                <li>
                    Pruebas basadas en riesgo.
                </li>
                <li>
                    Fases de prueba (unidad, integración, sistema, validación) y tipos de prueba
                    (estática, dinámica, no funcional, …).
                </li>
                <li>
                    Prueba en diferentes ciclos de vida del software.
                </li>
                <li>
                    Roles y responsabilidades en la prueba.
                </li>
                <li>
                    Métricas y medidas.
                </li>
            </ul>
        </li>
        <li>
            Parte 2. Procesos de prueba:
            <ul class="lista_verificacion">
                <li>
                    Política de la organización.
                </li>
                <li>
                    Gestión del proyecto de prueba.
                </li>
                <li>
                    Procesos de prueba estática.
                </li>
                <li>
                    Procesos de prueba dinámica.
                </li>
            </ul>
        </li>
        <li>
            Parte 3. Documentación
            <ul class="lista_verificacion">
                <li>
                    Contenido.
                </li>
                <li>
                    Plantilla.
                </li>
            </ul>
        </li>
        <li>
            Parte 4. Técnicas de prueba:
            <ul class="lista_verificacion">
                <li>
                    Descripción y ejemplos.
                </li>
                <li>
                    Estáticas: revisiones, inspecciones, etc.
                </li>
                <li>
                    Dinámicas: Caja negra, caja blanca, Técnicas de prueba no funcional (Seguridad,
                    rendimiento, usabilidad, etc) .
                </li>
            </ul>
        </li>
    </ul>
</div><h1 class="title">
    Anexo.- Licencias de recuros.
</h1><div class="iDevice_content">
    <table class="tabla">
        <caption>
            Licencias de recursos utilizados en la Unidad de Trabajo.
        </caption>
        <tbody>
        <tr>
            <th scope="col">
                Recurso (1)
            </th>
            <th scope="col">
                Datos del recurso (1)
            </th>
            <th scope="col">
                Recurso (2)
            </th>
            <th scope="col">
                Datos del recurso (2)
            </th>
        </tr>
        <tr>
            <td class="texto_centrado">
            </td>
            <td>
                <p>
                    Autoría:Ebnz
                </p>
                <p>
                    Licencia:Creative Commons. Genérica de Atribución/Compartir-Igual 3,0
                </p>
                <p>
                    Procedencia:Montaje sobre http://es.wikipedia.org/
                </p>
            </td>
            <td class="texto_centrado">
            </td>
            <td>
                <p>
                    Autoría: Oracle Corporation
                </p>
                <p>
                    Licencia:Copyright cita
                </p>
                <p>
                    Procedencia:Captura de pantalla de Netbeans
                </p>
            </td>
        </tr>
        <tr>
            <td class="texto_centrado">
            </td>
            <td>
                <p>
                    Autoría:Oracle Corporation
                </p>
                <p>
                    Licencia: Copyright cita
                </p>
                <p>
                    Procedencia: Captura de pantalla de Netbeans
                </p>
            </td>
            <td class="texto_centrado">
            </td>
            <td>
                <p>
                    Autoría:Oracle Corporation
                </p>
                <p>
                    Licencia:Copyright cita
                </p>
                <p>
                    Procedencia:Captura de pantalla de Netbeans
                </p>
            </td>
        </tr>
        <tr>
            <td class="texto_centrado">
            </td>
            <td>
                <p>
                    Autoría:Oracle Corporation
                </p>
                <p>
                    Licencia:Copyright cita
                </p>
                <p>
                    Procedencia:Captura de pantalla de Netbeans
                </p>
            </td>
            <td class="texto_centrado">
            </td>
            <td>
                <p>
                    Autoría:Scott Schram.
                </p>
                <p>
                    Licencia:CC by dominio público.
                </p>
                <p>
                    Procedencia:www.flickr.com
                </p>
            </td>
        </tr>
        <tr>
            <td class="texto_centrado">
            </td>
            <td>
                <p>
                    Autoría:Oracle Corporation
                </p>
                <p>
                    Licencia:Copyright cita
                </p>
                <p>
                    Procedencia:Captura de pantalla de Netbeans
                </p>
            </td>
            <td class="texto_centrado">
            </td>
            <td>
                <p>
                    Autoría:JaulaDeArdilla
                </p>
                <p>
                    Licencia:CC by-nc-nd
                </p>
                <p>
                    Procedencia:http://www.flickr.com/photos/jauladeardilla/2285620559/
                </p>
            </td>
        </tr>
        </tbody>
    </table>
</div><h1 class="title">
    Condiciones y términos de uso de los materiales
</h1><div class="iDevice_content">
    <div title="Información acerca de la licencia de los materiales">
        <p style="margin: 2px 2px;">
            <strong>
                Materiales desarrollados inicialmente
                por el Ministerio de Educación, Cultura y Deporte y actualizados por el
                profesorado de la Junta de Andalucía bajo licencia Creative Commons
                <abbr title="Reconocimiento-NoComercial-CompartirIgual">
                    BY-NC-SA.
                </abbr>
            </strong>
        </p>
        <p style="font-size: 0.8em; margin: 2px 2px;">
            <strong>
            </strong>
        </p>
        <p style="font-size: 0.8em; margin: 2px 2px;">
          <span>
           Antes de cualquier
										uso leer detenidamente el siguente
          </span>
            Aviso
            legal
        </p>
    </div>
</div>

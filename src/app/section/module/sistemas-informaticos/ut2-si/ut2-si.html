<h1 class="title">
    Software de un sistema informático.
</h1><div class="iDevice_content">
    <p>
    </p>

    <p>
        <br>
        Ya conoces la empresa
        <strong>
            BK Programación
        </strong>
        , en la que nuestros
        protagonistas desarrollan su trabajo como profesionales del sector de la
        informática. Recordemos el perfil de cada uno.
        <br/></p>
    <p>
        <strong>
            Ada
        </strong>
        es la fundadora de la empresa y tiene una gran experiencia en
        programación. Junto a ella han empezado a trabajar en BK Programación dos técnicos
        superiores informáticos:
        <strong>
            María
        </strong>
        , dedicada a la implantación de
        servidores y manteniendo páginas web, y
        <strong>
            Juan
        </strong>
        , cuyo trabajo
        principal consiste en desarrollar aplicaciones web e instalar servicios de Internet.
    </p>
    <p>
        Por otro lado, tenemos a
        <strong>
            Ana
        </strong>
        y
        <strong>
            Carlos
        </strong>
        , dos jóvenes
        que quieren mejorar su formación profesional en la rama de informática.
        <strong>
            Ana
        </strong>
        , a quien le apasiona el diseño gráfico, parece decantarse por
        estudiar el ciclo de Desarrollo de Aplicaciones Informáticas Multiplataforma, puesto
        que le vendría muy bien para mejorar a nivel profesional.
        <strong>
            Carlos
        </strong>
        está pensando estudiar el ciclo de Desarrollo de Aplicaciones Web, ya que se ajusta
        mejor a su perfil y tiene curiosidad por aprender a programar en entornos web.
    </p>
    <p>
        Ana ha colaborado profesionalmente en varias ocasiones con BK Programación. Ha
        realizado retoque gráfico para algunos de los recursos que aparecen en los sitios
        web que ha creado y mantiene la empresa. Ana le ha comentado a Carlos que le
        gustaría realizar las prácticas de empresa en BK Programación, ya que podría
        aprender bastante y meterse más de lleno en el desarrollo de aplicaciones web. A
        Carlos le parece una buena idea y decide acompañar a Ana para ir a hablar con la
        responsable de la empresa, Ada.
    </p>
</div><h1 class="title">
    1.- Software de un sistema informático.
</h1><div class="iDevice_content">

    <p>
        <strong>
            Ana
        </strong>
        y
        <strong>
            Carlos
        </strong>
        acaban de llegar a BK Programación y
        preguntan por
        <strong>
            Ada,
        </strong>
        ella los recibe en su oficina y se alegra de
        saludar de nuevo a Ana, colaboradora ocasional de BK Programación. Ana y Carlos le
        comentan su intención de estudiar ciclos formativos de informática y su interés por
        realizar, si fuera posible, las prácticas en la empresa. Ada encuentra interesante
        la posibilidad de incorporar personal con nuevas ideas, ilusión y con conocimientos
        actualizados. Cree que puede ser una buena experiencia en la que ambas partes,
        estudiantes y empresa, se beneficien.
    </p>
    <p>
        —Entonces, BK Programación se centra en la parte software de los sistemas
        informáticos, ¿o también realizáis tareas relacionadas con hardware? —pregunta
        <strong>
            Carlos
        </strong>
        , tras escuchar atentamente a Ada.
    </p>
    <p>
        —En BK programación desarrollamos y mantenemos aplicaciones y servicios web. Sin
        embargo, en ocasiones, a petición de nuestros clientes y contando con trabajadores
        cualificados para ello, también instalamos y configuramos físicamente servidores,
        impartimos formación sobre las aplicaciones desarrolladas, actuamos como soporte
        técnico y asesoramos en la compra de equipos informáticos —comenta Ada.
    </p>
</div><h1 class="title">
    1.1.- Tipos de aplicaciones informáticas.
</h1><div class="iDevice_content">

    <p>
        <strong>
            <br>
            Ana
            <br/></strong>
        y
        <strong>
            Carlos
        </strong>
        acaban de terminar su reunión con
        <strong>
            Ada
        </strong>
        . De camino a casa, a
        <strong>
            Carlos
        </strong>
        le surgen algunas
        dudas sobre el
        <strong>
            tipo de softwar
        </strong>
        e con el que trabajan en BK
        Programación.
        <strong>
            Ana
        </strong>
        , que tiene algunos conocimientos más sobre
        informática que
        <strong>
            Carlos
        </strong>
        , le comenta que existen varias
        clasificaciones de aplicaciones o programas informáticos. Una de las que conoce
        responde al ámbito en el que se utilizan esas aplicaciones.
    </p>
</div><h1 class="title">
    1.2.- Requisitos e instalación de una aplicación.
</h1><div class="iDevice_content">
    <p>
    </p>
    <p>
        En
        <strong>
            BK Programación
        </strong>
        el
        <span lang="en">
           software
          </span>
        que utilizan
        es el que los clientes demandan, aunque también hay empresas que piden asesoramiento
        sobre ello. Por ello, nuestros protagonistas tienen que conocer a fondo todos los
        <strong>
            productos
            <span lang="en">
            software
           </span>
        </strong>
        que el mercado ofrece en
        cuanto al área de las tecnologías web, sistemas operativos y demás aplicaciones de
        usuario relacionadas; ya que antes de poner en marcha una aplicación web, con
        frecuencia, hay que instalar y configurar los servidores que alojarán la aplicación
        y atenderán las peticiones.
    </p>
    <p>
        María, encargada en muchas ocasiones de implantar los servicios web de los clientes,
        siempre se preocupa de conocer a fondo los requisitos y peculiaridades de
        instalación y configuración de las aplicaciones con las que trabaja, documentándose
        para ello.
    </p>
</div><h1 class="title">
    1.2.1.- Determinación del equipo necesario.
</h1><div class="iDevice_content">

    <p>
        Lo primero que debemos hacer es conocer
        <strong>
            qué necesita la aplicación
        </strong>
        para que
        funcione adecuadamente en el ordenador, es decir, qué
        <strong>
            características o requisitos
        </strong>
        tendrá que tener el sistema informático.&nbsp;Cada desarrollador crea sus
        aplicaciones enfocadas a plataformas concretas, con unas necesidades de
        <span lang="en">
         hardware
        </span>
        y
        <span lang="en">
         software
        </span>
        necesarias para su
        funcionamiento. Una aplicación creada para una plataforma no podrá ser instalada en otra
        distinta. Tampoco podrá ser instalada si nuestro sistema informático no cumple los
        requisitos mínimos. Antes de proceder a la instalación de una aplicación tendrá que reunir
        la información sobre el
        <span lang="en">
         hardware
        </span>
        de su ordenador y deberá verificar
        que su
        <span lang="en">
         hardware
        </span>
        le permite realizar el tipo de instalación que desea
        efectuar.
    </p>
    <p>
        Las
        <strong>
            características para que la aplicación se
        </strong>
        <strong>
            ejecute
            adecuadamente
        </strong>
        pueden ser de
        <strong>
            naturaleza
            <span lang="en">
          hardware
         </span>
        </strong>
        :
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Plataforma
                <span lang="en">
           hardware
          </span>
                :
            </strong>
            <abbr title="Personal Computer">
                PC
            </abbr>
            , Mac,
            <abbr title="Etcétera.">
                etc
            </abbr>
            .
        </li>
        <li>
            <strong>
                Procesador:
            </strong>
            Fabricante y velocidad (generalmente se indica el inferior
            posible de la gama con el que la aplicación funciona adecuadamente).
        </li>
        <li>
            <strong>
                Memoria
                <abbr title="Random-access memory">
                    RAM
                </abbr>
                mínima
            </strong>
            .
        </li>
        <li>
            <strong>
                Espacio mínimo disponible en el soporte de almacenamiento:
            </strong>
            En disco
            duro o en una unidad de almacenamiento externa para
            aplicaciones portables


            Aplicación
            portable

            Es una aplicación informática que puede ser utilizada en
            cualquier ordenador que posea el sistema operativo para el que fue programada
            sin instalación previa; esto significa que no es necesaria la instalación en el
            sistema para su funcionamiento. Las aplicaciones portátiles pueden ejecutarse
            directamente desde una memoria USB.
            .
        </li>
        <li>
            <strong>
                Tarjeta gráfica:
            </strong>
            La memoria gráfica necesaria para el buen
            funcionamiento de la aplicación.
        </li>
        <li>
            <strong>
                Resolución recomendada del monitor.
            </strong>
        </li>
    </ul>
    <p>
        Y de carácter
        <strong>
         <span lang="en">
          software
         </span>
        </strong>
        :
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Plataforma
                <span lang="en">
           software
          </span>
                :
            </strong>
            Sistema operativo bajo el
            que funciona la aplicación, como
            <span lang="en">
          Windows
         </span>
            , Linux, etc.
        </li>
        <li>
            <strong>
                Otros paquetes
                <span lang="en">
           software
          </span>
                adicionales
            </strong>
            necesarios,
            tales como
            actualizaciones


            Actualización

            Revisión
            difundida por un fabricante de software para un problema concreto que resuelve
            un fallo o vulnerabilidad en un sistema.
            concretas de seguridad para
            el sistema operativo, la
            JVM


            JVM

            (Java Virtual Machine) o
            Máquina Virtual de Java es una de las piezas fundamentales de la plataforma
            Java. Básicamente se sitúa en un nivel superior al hardware del sistema sobre el
            que se pretende ejecutar la aplicación, y este actúa como un puente que entiende
            tanto el bytecode (código binario especial), como el sistema sobre el que se
            pretende ejecutar.
            (máquina virtual de Java), el Flash
            <span lang="en">
          Player
         </span>
            , etc. Por ejemplo, para instalar el editor de imágenes de
            <span lang="en">
          Microsoft
         </span>
            te indica que debes tener instalado varios componentes
            de
            <span lang="en">
          Microsoft
         </span>
            .
        </li>
    </ul>
    <p>
        Teniendo en cuenta lo visto anteriormente, los fabricantes de aplicaciones informáticas
        suelen establecer
        <strong>
            tres niveles de requisitos
        </strong>
        para la instalación de sus
        aplicaciones:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Equipo básico.
            </strong>
        </li>
        <li>
            <strong>
                Equipo opcional.
            </strong>
        </li>
        <li>
            <strong>
                Equipo en red.
            </strong>
        </li>
    </ul>
    <p>
        ¿Qué supone cada uno de los niveles anteriores? Veamos las características de cada nivel de
        requisitos
        <span lang="en">
         software
        </span>
        a través de la siguiente presentación:
    </p>
    <div class="elemento_centrado">
        <div class="elemento_centrado">
            <div class="exe-fx exe-carousel" id="exe-carousel-0">
                <div class="fx-carousel-content fx-C2 fx-current" id="exe-carousel-0-0">
                    <h2>
                        Niveles de requisitos para la implantación de aplicaciones
                    </h2>
                    <ol>
                        <li style="text-align: left;">
                            <p>
                                <b>
                                    Equipo básico
                                </b>
                            </p>
                        </li>
                        <li style="text-align: left;">
                            <p>
                                <b>
                                    Equipo opcional
                                </b>
                            </p>
                        </li>
                        <li style="text-align: left;">
                            <b>
                                Equipo en red
                            </b>
                        </li>
                    </ol>
                </div>
                <div class="fx-carousel-content fx-C2" id="exe-carousel-0-1">
                    <h2>
                        1. Equipo básico
                    </h2>
                    <p style="text-align: left;">
                        En las
                        <b>
                            especificaciones básicas
                        </b>
                        del
                        fabricante aparecerán los siguientes elementos:
                    </p>
                    <ul class="lista_verificacion" style="text-align: left;">
                        <li>
                            Plataforma hardware.
                        </li>
                        <li>
                            Tipo de microprocesador.
                        </li>
                        <li>
                            RAM mínima necesaria.
                        </li>
                        <li>
                            Espacio mínimo necesariamente disponible en el soporte de
                            almacenamiento.
                        </li>
                        <li>
                            Plataforma software.
                        </li>
                        <li>
                            Resolución recomendada del monitor
                        </li>
                        <li>
                            Tarjeta gráfica necesaria.
                        </li>
                    </ul>
                    <p style="text-align: left;">
                        Veamos como ejemplo los requisitos mínimos de las
                        últimas versiones del conocido paquete Microsoft Office:
                    </p>
                    <p style="text-align: center;">
                    </p>
                </div>
                <div class="fx-carousel-content fx-C2" id="exe-carousel-0-2">
                    <h2>
                        2. Equipo opcional
                    </h2>
                    <p style="text-align: left;">
                        Además de los requisitos mínimos, los fabricantes
                        suelen especificar configuraciones de equipos que convengan para conseguir
                        un funcionamiento eficaz de la aplicación. En muchos casos, la configuración
                        básica (requisitos mínimos) no permite funcionar a la aplicación con un
                        rendimiento satisfactorio. Entre las recomendaciones suelen aparecer:
                    </p>
                    <ul class="lista_verificacion" style="text-align: left;">
                        <li style="text-align: left;">
                            Plataforma hardware recomendada.
                        </li>
                        <li style="text-align: left;">
                            Cantidad de memoria adicional recomendada.
                        </li>
                        <li style="text-align: left;">
                            Presencia de coprocesador matemático (para
                            aplicaciones que realicen gran cantidad de cálculos).
                        </li>
                        <li style="text-align: left;">
                            Tipo de impresora.
                        </li>
                        <li style="text-align: left;">
                            Capacidad recomendada para la tarjeta gráfica.
                        </li>
                    </ul>
                </div>
                <div class="fx-carousel-content fx-C2" id="exe-carousel-0-3">
                    <h2>
                        3. Equipo en red
                    </h2>
                    <p style="text-align: left;">
                        Actualmente muchos fabricantes diseñan las
                        aplicaciones para su funcionamiento en red. El fabricante indicará, si la
                        aplicación se ha diseñado para trabajar en red, las
                        <b>
                            configuraciones para
                            el servidor y los clientes
                        </b>
                        (ordenadores que hacen peticiones al
                        servidor), así como los
                        <b>
                            sistemas operativos en red
                        </b>
                        bajo los que puede
                        trabajar. La
                        <b>
                            configuración de la red
                        </b>
                        (tarjetas de comunicación y
                        topología) no depende de la aplicación sino del sistema operativo.
                    </p>
                    <p style="text-align: left;">
                        El&nbsp; fabricante indicará además si existe
                        alguna limitación en cuanto al
                        <b>
                            número máximo de clientes
                        </b>
                        que pueden
                        trabajar con la aplicación. Así, por cada estación en la&nbsp; que se
                        instale la aplicación habría que adquirir una licencia de uso para los
                        ordenadores cliente.
                    </p>
                    <p style="text-align: left;">
                        <b>
                            Por ejemplo,
                        </b>
                        en el sistema operativo
                        <em>
                            Windows Server
                        </em>
                        se limita el número de ordenadores clientes a los
                        que atiende en función del número de licencias que exista para ello, esta
                        opción de configuración se especifica durante la instalación del servidor.
                    </p>
                </div>
                <div class="fx-carousel-content fx-C2" id="exe-carousel-0-4">
                    <h2>
                        3. Equipo en red
                    </h2>
                    <p style="text-align: left;">
                        En la imagen siguiente podemos ver los requisitos
                        mínimos, opcionales y en red para la instalación de una aplicación de
                        gestión jurídica,
                        <em>
                            InfoLex
                        </em>
                        , que funciona tanto en un equipo local
                        como en red.
                    </p>
                    <p style="text-align: center;">
                    </p>
                </div>
                <ul class="fx-pagination fx-carousel-pagination">
                    <li class="fx-carousel-prev-next fx-carousel-prev fx-disabled fx-C2" id="exe-carousel-0-prev">
                        ◄


                        Anterior
                    </li>
                    <li class="fx-current fx-C1" id="exe-carousel-0-0-link">
                        1
                    </li>
                    <li id="exe-carousel-0-1-link">
                        2
                    </li>
                    <li id="exe-carousel-0-2-link">
                        3
                    </li>
                    <li id="exe-carousel-0-3-link">
                        4
                    </li>
                    <li id="exe-carousel-0-4-link">
                        5
                    </li>
                    <li class="fx-carousel-prev-next fx-carousel-next fx-C2" id="exe-carousel-0-next">
                        ►


                        Siguiente
                    </li>
                </ul>
            </div>
        </div>

    </div>
</div><h1 class="title">
    1.2.2.- Ejecución del programa de instalación.
</h1><div class="iDevice_content">
    <p>
        Por la instalación de un programa o aplicación informática entendemos el conjunto de pasos
        que nos van a permitir copiar los archivos necesarios, configurar, implantar y poner en
        funcionamiento una aplicación en un sistema informático.
    </p>
    <p>
        La mayoría de las aplicaciones presentan dos niveles en función de los conocimientos del
        usuario:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Instalación básica:
            </strong>
            Este nivel está diseñado para usuarios con pocos
            conocimientos informáticos. El programa realizará una instalación en función de los
            elementos que detecte en el equipo y según unos parámetros básicos establecidos por
            defecto por el fabricante.
        </li>
        <li>
            <strong>
                Instalación personalizada o avanzada:
            </strong>
            Permite a un usuario experto
            incluir o eliminar elementos de la aplicación con el fin de optimizar los recursos
            sistema informático, instalando sólo aquellos elementos de la aplicación que se van a
            utilizar. Por ejemplo, la instalación personalizada del paquete
            <span lang="en">
          Microsoft Office
         </span>
            permite elegir los programas a instalar (
            <span lang="en">
          Microsoft Word, Excel, PowerPoint, Frontpage,
         </span>
            etc.).
        </li>
    </ul>

    <p>
        Cuando se adquiere una aplicación informática, nos encontramos con un grupo de manuales y de
        <abbr title="Digital Versatile  Disc">
            DVD
        </abbr>
        o
        <abbr title="Disco compacto">
            CD
        </abbr>
        . La aplicación se encuentra normalmente en formato
        comprimido. El traspaso del programa al soporte de almacenamiento de nuestro ordenador,
        normalmente el disco duro, se realiza a través del
        <strong>
            programa de instalación
        </strong>
        (su nombre puede ser
        <span lang="en">
         setup
        </span>
        ,
        <span lang="en">
         install
        </span>
        , instalar,
        etc.), y es el encargado de
        <strong>
            extraer los bloques de la aplicación
        </strong>
        de los
        discos, descomprimiéndolos si es necesario;
        <strong>
            crear la estructura de directorios
            necesaria,
        </strong>
        <strong>
            ubicar los archivos
        </strong>
        de la aplicación donde
        corresponda, y, si fuera necesario,
        <strong>
            modificar el registro del sistema
        </strong>
        .
    </p>
    <p>
        En la actualidad, la mayoría de los fabricantes distribuyen también sus aplicaciones en
        formato DVD, CD o con posibilidad de descarga de los archivos de instalación o en
        imágenes ISO


        Imagen
        ISO

        Es un archivo donde se almacena una copia o imagen exacta de un sistema
        de ficheros, normalmente un disco óptico. Se rige por el estándar

        ISO

        9660
        que le da nombre. Algunos de los usos más comunes incluyen la distribución de
        sistemas operativos, tales como sistemas Linux, BSD o Live CD.
        (por
        ejemplo: muchas distribuciones de Linux pueden descargarse en este formato).
    </p>
    <p>
        En las versiones actuales de Windows disponemos de la herramienta
        <em>
            Microsoft Store
        </em>
        para la instalación de software y en Linux la forma más común para la instalación de
        software es a través de repositorios oficiales con ayuda de la herramienta
        <em>
            Ubuntu
            Software
        </em>
        o aplicaciones como
        <strong>
        </strong>
        <em>
         <span lang="en">
          Synaptic
         </span>
        </em>
        que es un
        sistema de gestor de paquetes
        . Estas
        herramientas se conectan a un repositorio como puede ser el de la distribución Ubuntu en
        http://archive.ubuntu.com/
        que contienen

        binarios
        o paquetes precompilados por ejemplo .
        deb
        en distribuciones Debian/Ubuntu y se
        encargan de realizar la instalación de la aplicación en nuestro sistema automáticamente
        descargando cualquier paquete del que dependa. Actualmente existen paquetes universales que
        funcionan en cualquier distribución
        <span lang="en">
         Linux
        </span>
        sin necesidad de ser
        instalados en el sistema como
        <strong>
         <span lang="en">
          AppImage
         </span>
        </strong>
        o
        <strong>
         <span lang="en">
          Snap.
         </span>
        </strong>
    </p>
</div><h1 class="title">
    1.2.3.- Configuración de la aplicación.
</h1><div class="iDevice_content">
    <p>
        Una vez realizado correctamente el proceso de instalación sólo queda configurar las opciones
        de la aplicación, a veces también del sistema operativo, y configurar el entorno de trabajo.
        En la configuración se pueden modificar los parámetros establecidos por defecto para la
        aplicación. Algunas aplicaciones pueden generar una serie de archivos de configuración con
        los datos introducidos por los usuarios. El usuario debe realizar una última tarea antes de
        comenzar a utilizar la aplicación:
        <strong>
            configurar el entorno de trabajo
        </strong>
        . Esto
        consiste en definir una serie de parámetros de funcionamiento que adecuen el funcionamiento
        de la aplicación a las exigencias del usuario. Este proceso se realizará en el caso que no
        sea satisfactoria la configuración establecida por defecto por el programa. Entre estos
        <strong>
            parámetros
        </strong>
        aparecen:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Ajuste y distribución de la pantalla
            </strong>
            (tamaños de las ventanas, colores,
            tipos de letras, cambio de resolución, etc.).
        </li>
        <li>
            <strong>
                Definición de directorios de trabajo
            </strong>
            (directorios para los archivos,
            proyectos, plantillas, etc.).
        </li>
    </ul>
    <div style="width: 100%;">


        <br>
        <br>
        <br/><br/></div>
    <div style="clear: both;">
    </div>
    <p>
        Como ejemplo de configuración dentro de las opciones de la parte servidora de la aplicación
        de
        control remoto


        Control
        remoto

        Existen aplicaciones informáticas que permiten conectarse de forma
        remota a un ordenador en red y operar sobre el mismo como si fuera de forma local.
        Ejemplos de este tipo de aplicaciones son UltraVNC, Remote Desktop Control,
        etc.
        UltraVNC, se nos permite cambiar la contraseña de administrador,
        cambiar los puertos por defecto, etc. Por otro lado, algunas aplicaciones web requieren la
        activación de
        cookies


        Cookie

        Es un fragmento de
        información que se almacena en el disco duro del visitante de una página web por
        medio de su navegador, bajo petición del servidor de la página. Esta información
        puede ser recuperada más tarde por el servidor en posteriores visitas. Entre sus
        funciones están la de llevar el control de usuarios y conseguir información de
        hábitos de navegación del usuario.
        y la modificación de la configuración
        de seguridad de nuestro navegador.
    </p>
    <p>
        Tras este último paso de configuración la aplicación ya está lista para empezar a funcionar
        adecuadamente.
    </p>
</div><h1 class="title">
    1.3.- Licencias software.
</h1><div class="iDevice_content">

    <p>
        <strong>
            <br>
            María,
            <br/></strong>
        como asesora en la implantación de aplicaciones software,
        prefiere la opción de
        <strong>
            software libre
        </strong>
        , siempre que sea posible y el
        cliente esté de acuerdo. Sin embargo,
        <strong>
            Juan
        </strong>
        parece decantarse por la
        alternativa de
        <strong>
            software propietario
        </strong>
        que, según su criterio,
        garantiza un soporte técnico más profesional y fiable. ¡Así que, como os podéis
        imaginar, el debate está a la orden del día!
    </p>
</div><h1 class="title">
    1.3.1.- Licencias de software con código abierto.
</h1><div class="iDevice_content">

    <p>
        <br>
        Las
        <strong>
            licencias de software con&nbsp;código abierto
        </strong>
        ponen a disposición de
        los usuarios el
        <strong>
            código fuente
        </strong>
        con el que está construido el
        software. Encontramos dos subtipos:
        <br/></p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Licencias permisivas (con permisos).
            </strong>
            El software puede modificarse o
            dar lugar a otro nuevo (redistribuirse), sin que el resultado tenga que mantener la
            misma licencia del software original. Ejemplos: Apache Software License, PHP License,
            Perl License, Python License, W3C Software Notice and License, BSD License, MIT License,
            Open LDAP License, Perl License, VMS License.
        </li>
        <li>
            <strong>
                Licencias no permisivas (con restricciones),
            </strong>
            también llamadas
            <strong>
                <em>
                    copyleft
                </em>
                .
            </strong>
            Pueden ser:
            <ul>
                <li>
                    <strong>
                        Fuertes o con
                        <em>
                            copyleft fuerte
                        </em>
                        :
                    </strong>
                    El software puede
                    modificarse o dar lugar a otro nuevo, pero el resultado deberá mantener la misma
                    licencia del software original. Este tipo de licencias suelen estar unidas al
                    concepto de
                    <strong>
                        <em>
                            s
                        </em>
                        <em>
                            oftware libre
                        </em>
                    </strong>
                    .
                    <br>
                    Ejemplos:
                    Common Public License, GNU General Public License, Eclipse Public License,
                    Sleepycat Software Product License, Affero License, OpenSSL License.
                    <br/></li>
                <li>
                    <strong style="font-size: 1em;">
                        Débiles o con
                        <em>
                            copyleft
                            débil
                        </em>
                        :
                    </strong>
                    <span style="font-size: 1em;">
            Las
											modificaciones que se realicen del
           </span>
                    software
                    <span style="font-size: 1em;">
            original deberán mantener la misma licencia, pero si
											da lugar a otro software nuevo, éste si podría tener distinta licencia del
											software original.
            <br>
           <br/></span>
                    Ejemplos: GNU Lesser General Public License,
                    Mozilla Public License, Open Source License, Apple Source License, CDDL, EUPL.
                </li>
            </ul>
        </li>
    </ul>
</div><h1 class="title">
    1.3.2.- Licencias de software con código cerrado.
</h1><div class="iDevice_content">

    <p>
        <span>
         <br>
         Las
        <br/></span>
        <strong>
            licencias de software con&nbsp;código
            cerrado
        </strong>
        <span>
         n
        </span>
        <span style="font-size: 1em;">
         o permiten la
								distribución del
        </span>
        <strong>
            código fuente
        </strong>
        <span style="font-size: 1em;">
         con el que está construido el software. También suelen llamarse
        </span>
        <strong style="font-size: 1em;">
            <em>
                software propietario
            </em>
        </strong>
        <span style="font-size: 1em;">
         o
        </span>
        <strong style="font-size: 1em;">
            <em>
                privativo
            </em>
        </strong>
        <span style="font-size: 1em;">
         .
        </span>
    </p>
    <p>
        En estas licencias los propietarios limitan las posibilidades que tienen los usuarios para
        utilizar, copiar, modificar, redistribuir o ceder el software. Si no se cumpliera lo que hay
        estipulado en los términos y condiciones de la licencia estaríamos hablando de
        <strong>
            <em>
                piratería de Software
            </em>
        </strong>
        .
    </p>
    <p>
        Además, suelen ofrecer servicios de soporte técnico y actualizaciones durante el tiempo de
        vida del producto otorgado en la licencia.
    </p>
    <p>
        Como ejemplos de estas licencias tenemos:
    </p>
    <ul>
        <li>
            <strong>
                <em>
                    Licencias
                </em>
                <em>
                    <abbr title="Acuerdo de Licencia de Usuario Final">
                        ALUF
                    </abbr>
                </em>
            </strong>
            , en
            algunos países llamadas
            <em>
                <strong>
                    <abbr title="Contrato de Licencia para Usuario Final">
                        CLUF
                    </abbr>
                </strong>
            </em>
            o
            en inglés
            <strong>
                <em>
                    <abbr title="End User License Agreement">
                        EULA
                    </abbr>
                </em>
            </strong>
            : El uso del
            software sólo está permitido para un único usuario
            <span>
          (el
									comprador).
         </span>
        </li>
        <li>
            <strong>
                <em>
                    Freeware
                </em>
                :
            </strong>
            Se aplica a software que se distribuye
            gratuitamente y por tiempo indefinido.&nbsp;Es posible que requiera que nos registremos,
            pero siempre de forma gratuita. Normalmente está permitida su redistribución, pero no la
            modificación. No suele incluir el código fuente.
        </li>
        <li>
            <strong>
                <em>
                    Shareware
                </em>
            </strong>
            : Permite que el software se evalúe, aunque puede
            limitar el tiempo de uso o algunas de sus funcionalidades. Para disponer del producto
            sin limitaciones habría que pagarlo.
        </li>
    </ul>
    <p>
        Las
        <em>
            licencias propietarias
        </em>
        o
        <em>
            privativas
        </em>
        pueden
        adquirirse a través de diferentes vías:
    </p>
    <ul>
        <li>
            <strong>
                <em>
                    Retail
                </em>
            </strong>
            ,&nbsp;también llamada
            <strong>
                <em>
                    <abbr title="Full Packaged Product">
                        FPP
                    </abbr>
                </em>
            </strong>
            : Esta es la forma
            habitual en la que un usuario compraría un software en un establecimiento. Normalmente,
            está dirigida a usuarios que no necesitan más de cinco licencias y pueden encontrarse
            dos variantes:
        </li>
    </ul>
    <ul>
        <li style="list-style-type: none;">
            <ul>
                <li style="list-style-type: none;">
                    <ul>
                        <li>
                            Producto completo: No requiere una versión previa del software para su
                            instalación en el ordenador del usuario.
                        </li>
                        <li>
                            Actualización&nbsp;(Upgrade): Parte de una versión previa del software
                            para la que ya tenemos licencia. Normalmente, este tipo de licencias
                            tienen un coste menor.
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    <ul>
        <li>
            <strong>
                <em>
                    <abbr title="Original Equipment Manufacturer">
                        OEM
                    </abbr>
                </em>
            </strong>
            : Es
            la licencia del software que viene&nbsp;preinstalado cuando se adquiere un equipo
            nuevo
            <span>
          , estando prohibida explícitamente su venta si no forma parte de un todo.
									El
         </span>
            <span lang="en">
          software
         </span>
            <span>
          no podrá utilizarse ni tan
									siquiera en el caso de hacer una sustitución del equipo por otro, salvo que ésta sea
									por motivos de garantía.
         </span>
            Lo que sí suele estar permitido es ceder el equipo
            completo (
            <em>
                hardware
            </em>
            y
            <em>
                software
            </em>
            ) a un usuario
            diferente.
        </li>
        <li>
            <strong>
                Licencias por volumen:
            </strong>
            Los fabricantes de software suelen tener
            contratos dirigidos a entidades o empresas, de diferentes tamaños, que necesiten un
            número de licencias mayor que un usuario normal. El contrato puede incluir derechos
            específicos, como por ejemplo, los derechos de transferencia a determinados usuarios que
            cumplan con unas características concretas.
            <br>
            En este tipo de licencias también
            encontramos las opciones de producto completo o actualización. Además, es frecuente que
            dispongamos de derechos de
            <strong style="font-size: 1em;">
                <em>
                    downgrade
                </em>
            </strong>
            <span style="font-size: 1em;">
          ,
									para dar soporte a sistemas más antiguos.
         </span>
            <br/></li>
    </ul>
    <p>
    </p>
</div><h1 class="title">
    2.- El Sistema operativo.
</h1><div class="iDevice_content">

    <p>
        En
        <strong>
            BK Programación
        </strong>
        , los protagonistas de nuestra historia deben
        conocer a fondo todos los productos que el mercado ofrece en cuanto a software de
        sistema, y así aconsejar con garantías cuál se adecua mejor a las necesidades y
        situaciones que su clientela le pueda plantear.
    </p>
    <p>
        <strong>
            Juan
        </strong>
        dice que deben conocer a fondo la teoría en la que están
        basados los desarrollos de los sistemas operativos. Conociendo cómo funcionan los
        sistemas “por dentro” podrán llegar a ser unos buenos profesionales con criterio
        propio, capaces de valorar las características de cada sistema. Y lo que es más
        importante, conociendo los entresijos de las máquinas y el software que van a
        utilizar podrán sacarles el máximo partido.
    </p>
    <p>
        En BK Programación existen diferentes posturas como vimos en un apartado anterior.
        Esa es la razón de que no se cierren a ninguna opción, por ello, la empresa cuenta
        con personal especializado en sistemas
        <strong>
            Linux
        </strong>
        y para los sistemas
        <strong>
            Windows
        </strong>
        de
        <strong>
            Microsoft
        </strong>
        y
        <strong>
            Mac
        </strong>
        de
        <strong>
            Apple
        </strong>
        .
    </p>
    <p>
        En
        <strong>
            BK Programación
        </strong>
        conocen la importancia de estar al día de los
        productos software del mercado y los nuevos que aparecerán. Para comprender y
        valorar lo particular de estos productos deben conocer antes lo general. Por lo que
        tanto
        <strong>
            Juan
        </strong>
        como
        <strong>
            María
        </strong>
        están al día de estos
        conocimientos técnicos para saber comparar las posibilidades que un sistema ofrece
        frente a otro.
    </p>
</div><h1 class="title">
    2.1.- Objetivos y evolución de los sistemas operativos.
</h1><div class="iDevice_content">

    <p>
        Los principales
        <strong>
            objetivos de los
        </strong>
        <strong>
            sistemas operativos
        </strong>
        son:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Abstraer al usuario de la complejidad del hardware
            </strong>
            : El sistema
            operativo hace que el ordenador sea más fácil de utilizar.
        </li>
        <li>
            <strong>
                Eficiencia
            </strong>
            : Permite que los recursos del ordenador se utilicen de la
            forma más eficiente posible. Por ejemplo, se deben
            <strong>
                optimizar
            </strong>
            los
            accesos a disco para acelerar las operaciones de entrada y salida.
        </li>
        <li>
            <strong>
                Permitir la ejecución de programas
            </strong>
            : Cuando un usuario quiere ejecutar
            un programa, el sistema operativo realiza todas las tareas necesarias para ello, tales
            como cargar las instrucciones y datos del programa en memoria, iniciar dispositivos de
            entrada/salida y preparar otros recursos.
        </li>
        <li>
            <strong>
                Acceder a los dispositivos entrada/salida
            </strong>
            : El sistema operativo
            suministra una interfaz homogénea para los dispositivos de entrada/salida para que el
            usuario pueda utilizar de forma más sencilla los mismos.
        </li>
        <li>
            <strong>
                Proporcionar una estructura y conjunto de operaciones
            </strong>
            para el
            <strong>
                sistema de archivos.
            </strong>
        </li>
        <li>
            <strong>
                Controlar el acceso al sistema y los recursos
            </strong>
            : En el caso de sistemas
            compartidos, proporcionando protección a los recursos y los datos frente a usuarios no
            autorizados.
        </li>
        <li>
            <strong>
                Detección
            </strong>
            <strong>
                y respuesta ante errores
            </strong>
            : El sistema
            operativo debe
            <strong>
                p
            </strong>
            <strong>
                rever
            </strong>
            todas las posibles
            <strong>
                situaciones críticas y resolverlas,
            </strong>
            si es que se producen.
        </li>
        <li>
            <strong>
                Capacidad de adaptación
            </strong>
            : Un sistema operativo debe ser construido de
            manera que pueda evolucionar a la vez que surgen actualizaciones hardware y software.
        </li>
        <li>
            <strong>
                Gestionar las comunicaciones en red:
            </strong>
            El sistema operativo debe
            permitir al usuario manejar con facilidad todo lo referente a la instalación y uso de
            las redes de ordenadores.
        </li>
        <li>
            <strong>
                Permitir a los usuarios compartir recursos y datos
            </strong>
            : Este aspecto está
            muy relacionado con el anterior y daría al sistema operativo el papel de gestor de los
            recursos de una red.
        </li>
    </ul>
    <p>

    </p>
    <p>
        <strong>
            ¿Sabes cómo han ido cambiando los sistemas operativos desde sus inicios?
        </strong>
        Resulta interesante conocer la evolución histórica que han sufrido los sistemas operativos
        para comprender mejor las características que explicaremos más adelante. Lee este
        interesante documento:
    </p>
    <div class="enlace_centrado">
        <span style="color: #0000ff;">
         Ver Anexo I.- Evolución histórica de
								los sistemas operativos
        </span>
    </div>
</div><h1 class="title">
    2.2.- Tipos de sistemas operativos.
</h1><div class="iDevice_content">
    <p>
        Ahora vamos a clasificar los sistemas operativos en base a su estructura interna, los
        servicios que ofrecen y la forma en la que ofrecen los servicios.
    </p>
    <table class="tabla">
        <caption>
            Tipos de sistemas operativos
        </caption>
        <thead>
        <tr>
            <th scope="col">
                Estructura interna
            </th>
            <th scope="col">
                Servicios que ofrecen
            </th>
            <th scope="col">
                Forma de ofrecer los servicios
            </th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>
                Monolítico
            </td>
            <td>
                Monousuario
            </td>
            <td rowspan="2">
                <br>
                Centralizado
                <br/></td>
        </tr>
        <tr>
            <td>
                Jerárquico
            </td>
            <td>
                Multiusuario
            </td>
        </tr>
        <tr>
            <td>
                Máquina Virtual
            </td>
            <td>
                Monotarea
            </td>
            <td rowspan="2">
           <span>
            En red
           </span>
            </td>
        </tr>
        <tr>
            <td>
                Microkernel o Cliente-Servidor
            </td>
            <td>
                Multitarea
            </td>
        </tr>
        <tr>
            <td rowspan="2">
                Híbrido
            </td>
            <td>
                Monoprocesador
            </td>
            <td rowspan="2">
           <span>
            Distribuido
           </span>
            </td>
        </tr>
        <tr>
            <td>
                Multiprocesador
            </td>
        </tr>
        </tbody>
    </table>
</div><h1 class="title">
    2.2.1.- Sistemas operativos según su estructura interna.
</h1><div class="iDevice_content">
    <p>
        Esta clasificación se basa en cómo se diseñan los sistemas a la hora de ser creados.&nbsp;Hay
        que tener en cuenta que, en la mayoría de los casos, estas concepciones de diseño no se
        aplican aisladas, sino que puede haber interrelación entre ellas:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Monolítico:
            </strong>
            Es la estructura utilizada en los primeros sistemas
            operativos en la que todas las funciones se implementaban en el núcleo. El sistema
            operativo consistía en un único programa desarrollado con rutinas entrelazadas que
            podían llamarse entre sí. Por lo general, eran sistemas operativos hechos a medida, pero
            difíciles de mantener.
        </li>
    </ul>

    <ul class="lista_verificacion">
        <li>
            <strong>
                Jerárquico:
            </strong>
            Conforme las necesidades de los usuarios aumentaron, los
            sistemas operativos fueron creciendo en complejidad y funciones. Esto llevó a que se
            hiciera necesaria una mayor organización del software del sistema operativo,
            dividiéndose en partes más pequeñas (llamados niveles) , diferenciadas por funciones y
            con una interfaz clara para interoperar con los demás elementos. Cada uno de los niveles
            se comunica con el nivel inmediatamente inferior y superior de tal forma que todos ellos
            están&nbsp;coordinados y consiguen el objetivo del sistema operativo. Un ejemplo de este
            tipo de sistemas operativos fue MULTICS.
        </li>
    </ul>

    <ul class="lista_verificacion">
        <li>
            <strong>
                Máquina Virtual:
            </strong>
            El objetivo de los sistemas operativos es el de
            integrar distintos sistemas operativos dando la sensación de ser varias máquinas
            diferentes. Presentan una interfaz a cada proceso, mostrando una máquina que parece
            idéntica a la máquina real subyacente. Estas máquinas no son máquinas extendidas, son
            una réplica de la máquina real, de manera que en cada una de ellas se pueda ejecutar un
            sistema operativo diferente, que será el que ofrezca la máquina extendida al usuario.
            <abbr title="Virtual Machine ware.">
                VMware
            </abbr>
            y
            <abbr title="Virtual Machine Control Program">
                VM/CMS
            </abbr>
            son ejemplos de
            este tipo de sistemas operativos.
        </li>
    </ul>

    <ul class="lista_verificacion">
        <li>
            <strong>
                Microkernel o Cliente-Servidor:
            </strong>
            El modelo del núcleo de estos sistemas
            operativos distribuye las diferentes tareas en porciones de código modulares y
            sencillas. El objetivo es aislar del sistema, su núcleo, las operaciones de
            entrada/salida, gestión de memoria, del sistema de archivos, etc. Esto incrementa la
            tolerancia a fallos, la seguridad y la portabilidad entre plataformas de hardware.
            Algunos ejemplos son Mach, MINIX 3&nbsp;o
            <abbr title="Advanced Interactive eXecutive">
                AIX
            </abbr>
            .
        </li>
    </ul>
    <p>
    </p>

    <ul class="lista_verificacion">
        <li>
            <strong style="font-size: 1em;">
                Híbrido:
            </strong>
            E
            <span style="font-size: 1em;">
          sta
									estructura es en realidad una combinación entre la monolítica y la microkernel con
									la idea de incluir en el núcleo ciertas funciones para que se ejecuten más rápido de
									lo que se haría si estuviera en espacio de usuario.
         </span>
            <span style="font-size: 0.8em;">
         </span>
        </li>
    </ul>

</div><h1 class="title">
    2.2.2.- Sistemas operativos según los servicios que ofrecen.
</h1><div class="iDevice_content">

    <p>
        Esta clasificación podemos dividirla a su vez en:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Según el número de usuarios:
            </strong>
            <ul>
                <li>
                    <strong>
                        Monousuario:
                    </strong>
                    son aquellos que soportan a un usuario a la
                    vez, sin importar el número de procesos o tareas que el usuario pueda ejecutar
                    en un mismo instante de tiempo. Ejemplos de sistemas operativos de este tipo son
                    <abbr title="MicroSoft Disk Operating System">
                        MS-DOS
                    </abbr>
                    , Microsoft
                    Windows 9x y ME, MAC OS, entre otros.
                </li>
                <li>
                    <strong>
                        Multiusuario:
                    </strong>
                    son capaces de dar servicio a más de un usuario a
                    la vez, ya sea por medio de varios terminales conectadas al ordenador o por
                    medio de sesiones remotas en una red de comunicaciones. No importa el número de
                    procesadores en la máquina ni el número de procesos que puede ejecutar cada
                    usuario simultáneamente. Algunos ejemplos serán UNIX, GNU/Linux, Microsoft
                    Windows Server o MAC OS X.
                </li>
            </ul>
        </li>
        <li>
            <strong>
                Según el número de procesos o tareas:
            </strong>
            <ul>
                <li>
                    <strong>
                        Monotarea:
                    </strong>
                    sólo permiten una tarea a la vez por usuario. Se
                    puede dar el caso de un sistema multiusuario y monotarea, en el cual se admiten
                    varios usuarios simultáneamente pero cada uno de ellos puede ejecutar sólo una
                    tarea en un instante dado. Ejemplos de sistemas monotarea son MS-DOS, Microsoft
                    Windows 3.x y 95 (estos últimos sólo simulan la multitarea).
                </li>
                <li>
                    <strong>
                        Multitarea:
                    </strong>
                    permite al usuario realizar varias tareas al
                    mismo tiempo. Algunos ejemplos son MAC OS, UNIX, Linux, Microsoft Windows 98,
                    2000, XP, Vista y 7.
                </li>
            </ul>
        </li>
        <li>
            <strong>
                Según el número de procesadores:
            </strong>
            <ul>
                <li>
                    <strong>
                        Monoprocesador:
                    </strong>
                    es aquel capaz de manejar sólo un
                    procesador, de manera que si el ordenador tuviese más de uno le sería inútil.
                    MS-DOS y MAC OS son ejemplos de este tipo de sistemas operativos.
                </li>
                <li>
                    <strong>
                        Multiprocesador:
                    </strong>
                    es capaz de manejar varios procesadores del
                    sistema para distribuir su carga de trabajo e incrementar así el poder de
                    procesamiento. Estos sistemas trabajan de dos formas:
                    <strong>
                        simétricamente
                    </strong>
                    (los procesos son enviados indistintamente a
                    cualquiera de los procesadores disponibles) y
                    <strong>
                        asimétricamente
                    </strong>
                    (uno de los procesadores actúa como maestro o servidor y distribuye la
                    carga de procesos a los demás).
                </li>
            </ul>
        </li>
    </ul>
</div><h1 class="title">
    2.2.3.- Sistemas operativos según la forma en la que ofrecen los servicios.
</h1><div class="iDevice_content">
    <p>
    </p>
    <p>
        Por la forma de ofrecer los servicios, los sistemas operativos pueden ser:
    </p>
    <ul class="lista_verificacion">
        <li class="Default">
            <strong>
                Sistemas operativos centralizados:
            </strong>
            Permite
            utilizar los recursos de un solo ordenador, es decir, su memoria, CPU, disco y
            periféricos. Se denomina así porque el ordenador es único y no necesita trabajar en
            paralelo con ningún otro. En estos sistemas hay un uso ocasional de la red, como para
            transferir ficheros o logins remotos, pero son utilidades o funciones agregadas que
            permite realizar el sistema operativo centralizado, sin llegar a ser lo que buscaba como
            objetivo principal el sistema al ser diseñado. Hasta que los ordenadores personales no
            tuvieron un precio accesible y suficiente potencia, la mayoría de los sistemas
            utilizaban el sistema de proceso centralizado. Hoy en día son muy conocidos los sistemas
            centralizados con los que contamos, basta con empezar por los que tenemos instalados en
            nuestros ordenadores: Windows, Linux, Mac OS, Unix, etc.
        </li>
        <li>
            <strong>
                Sistemas operativos en red:
            </strong>
            Estos sistemas tienen la capacidad de
            interactuar con los sistemas operativos de otras máquinas a través de la red, con el
            objeto de intercambiar información, transferir archivos, etc. La clave de estos sistemas
            es que el usuario debe conocer la ubicación de los recursos en red a los que desee
            acceder. Los sistemas operativos modernos más comunes pueden considerarse sistemas en
            red, por ejemplo: Novell, Windows Server, Linux, etc.
        </li>
        <li>
            <strong>
                Sistemas operativos distribuidos:
            </strong>
            Abarcan los servicios de red,
            las funciones se distribuyen entre diferentes ordenadores, logrando integrar recursos
            (impresoras, unidades de respaldo, memoria, procesos, etc.) en una sola máquina virtual
            que es a la que el usuario accede de forma transparente. En este caso, el usuario no
            necesita saber la ubicación de los recursos, sino que los referencia por su nombre y los
            utiliza como si fueran locales a su lugar de trabajo habitual. MOSIX es un ejemplo de
            estos sistemas operativos.
        </li>
    </ul>
</div><h1 class="title">
    2.3.- Funciones del sistema operativo.
</h1><div class="iDevice_content">

    <p>
        El sistema operativo necesita administrar los recursos para tener control sobre las funciones
        básicas del ordenador. Pero,
        <strong>
            ¿cuáles son los recursos que gestiona el sistema
            operativo?
        </strong>
        Los principales recursos que administra el sistema operativo son:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                El procesador.
            </strong>
        </li>
        <li>
            <strong>
                La memoria.
            </strong>
        </li>
        <li>
            <strong>
                Los dispositivos de entrada/salida.
            </strong>
        </li>
        <li>
            <strong>
                El sistema de archivos.
            </strong>
        </li>
    </ul>
    <p>
        Para gestionar todos estos recursos, existe
        <strong>
            una parte muy importante
        </strong>
        del
        sistema operativo,
        <strong>
            el núcleo o kernel
        </strong>
        . El núcleo normalmente
        <strong>
            representa sólo una pequeña parte de todo lo que es el sistema operativo
        </strong>
        ,
        pero es una de las partes que más se utiliza. Por esta razón, el
        <strong>
            núcleo reside
        </strong>
        por lo general
        <strong>
            en la memoria principal
        </strong>
        , mientras que otras partes
        del sistema operativo son cargadas en la memoria principal sólo cuando se necesitan.
    </p>
    <p>

    </p>
    <p>
        Resumiendo, el
        <strong>
            núcleo
        </strong>
        supone la
        <strong>
            parte principal
        </strong>
        del
        código
        <strong>
            de un sistema operativo
        </strong>
        y se encarga de
        <strong>
            controlar y
            administrar los servicios y peticiones de recursos
        </strong>
        . Para ello se divide en
        distintos
        <strong>
            niveles
        </strong>
        :
    </p>
</div><h1 class="title">
    3.- Gestión de procesos.
</h1><div class="iDevice_content">

    <p>
        <strong>
            <br>
            Ana
            <br/></strong>
        y
        <strong>
            Carlos
        </strong>
        tienen dudas sobre lo que afecta a
        la eficiencia de un ordenador.
        <strong>
            María
        </strong>
        y
        <strong>
            Juan
        </strong>
        les
        explican que el rendimiento efectivo de un ordenador no sólo se basa en sus
        prestaciones hardware, sino también en el software que se ejecute y en el tipo de
        carga de trabajo que procese. La ejecución de los distintos programas que se lanzan
        en un equipo se traduce en multitud de procesos que requieren recursos. Uno de los
        principales recursos del ordenador es el
        <strong>
            procesador
        </strong>
        .
    </p>
    <p>
        María y Juan le comentan a Ana y Carlos con más de detalle en qué consiste la
        <strong>
            gestión de procesos
        </strong>
        y qué opciones existen.
    </p>
</div><h1 class="title">
    3.1.- Planificación del procesador.
</h1><div class="iDevice_content">

    <p>
        En la planificación del procesador
        <strong>
            se decide cuánto tiempo de ejecución se le asigna
            a cada proceso del sistema y en qué momento
        </strong>
        . Si el sistema operativo es
        monousuario y monotarea no habrá que decidir, pero en el resto de los sistemas multitarea
        esta decisión es fundamental para el buen funcionamiento del sistema, ya que determinará la
        correcta ejecución de los distintos programas de aplicación que se estén ejecutando.
    </p>
    <p>
        El sistema operativo almacena en una tabla denominada
        <strong>
            tabla de control de
            procesos
        </strong>
        ,&nbsp;la información relativa a cada proceso que se está ejecutando en
        el procesador. Ésta es:
    </p>
    <ul class="lista_verificacion">
        <li>
            Identificación del
            <strong>
                proceso
            </strong>
            .
        </li>
        <li>
            Identificación del
            <strong>
                proceso padre
            </strong>
            .
        </li>
        <li>
            Información sobre el
            <strong>
                usuario y grupo
            </strong>
            que lo han lanzado.
        </li>
        <li>
            <strong>
                Estado del procesador:
            </strong>
            El contenido de los registros internos,
            contador de programa, etc. Es decir, el entorno volátil del proceso.
        </li>
        <li>
            Información de
            <strong>
                control de proceso.
            </strong>
        </li>
        <li>
            Información del
            <strong>
                planificador
            </strong>
            .
        </li>
        <li>
            <strong>
                Segmentos de memoria asignados
            </strong>
            .
        </li>
        <li>
            <strong>
                Recursos asignados
            </strong>
            .
        </li>
    </ul>
    <p>
        Una
        <strong>
            estrategia de planificación
        </strong>
        debe buscar que los procesos obtengan sus
        turnos de ejecución de forma apropiada (
        <strong>
            momento en que se le asigna el uso de la
            <abbr title="unidad central de procesamiento">
                CPU
            </abbr>
        </strong>
        ), junto con un
        buen rendimiento y minimización de la sobrecarga (
        <span lang="en">
         overhead
        </span>
        ) del
        planificador mismo. En general, se buscan
        <strong>
            cinco objetivos principales
        </strong>
        :
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Equidad:
            </strong>
            Todos los procesos en algún momento obtienen su turno de
            ejecución o intervalos de tiempo de ejecución hasta su terminación con éxito.
        </li>
        <li>
            <strong>
                Rendimiento:
            </strong>
            El sistema debe finalizar el mayor número de procesos por
            unidad tiempo.
        </li>
        <li>
            <strong>
                Tiempo de respuesta:
            </strong>
            El usuario no percibirá tiempos de espera
            demasiado largos.
        </li>
        <li>
            <strong>
                Tiempo de retorno:
            </strong>
            Evitar el aplazamiento indefinido, los procesos
            deben terminar en un plazo finito de tiempo. Esto es, el usuario no debe percibir que su
            programa se ha parado o “colgado”.
        </li>
        <li>
            <strong>
                Eficacia:
            </strong>
            <strong>
            </strong>
            El procesador debe estar ocupado el
            100% del tiempo.
        </li>
    </ul>

    <p>
        <strong>
            La carga de trabajo de un sistema informático a otro puede variar
        </strong>
        considerablemente, esto depende de las
        <strong>
            características de los
            procesos
        </strong>
        . Nos podemos encontrar:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Procesos
            </strong>
            que hacen un
            <strong>
                uso intensivo de la
                <abbr title="Unidad central de proceso">
                    CPU
                </abbr>
            </strong>
            <strong>
                .
            </strong>
        </li>
        <li>
            <strong>
                Procesos
            </strong>
            que realizan una gran cantidad de
            <strong>
                operaciones de
                Entrada/Salida.
            </strong>
        </li>
        <li>
            <strong>
                Procesos por lotes, procesos interactivos, procesos en tiempo real.
            </strong>
        </li>
        <li>
            <strong>
                Procesos de menor o mayor duración.
            </strong>
        </li>
    </ul>
    <p>
        En función de cómo sean la mayoría de los procesos habrá algoritmos de planificación que den
        un mejor o peor rendimiento al sistema.
    </p>
</div><h1 class="title">
    3.2.- Planificación apropiativa y no apropiativa.
</h1><div class="iDevice_content">
    <p>
        La
        <strong>
            planificación no apropiativa
        </strong>
        (en inglés, no
        <span lang="en">
         preemptive
        </span>
        ) es aquélla en la que, cuando a un proceso le toca su turno
        de ejecución, ya
        <strong>
            no puede ser suspendido;
        </strong>
        es decir, no se le puede
        arrebatar el uso de la CPU, hasta que el proceso no lo determina no se podrá ejecutar otro
        proceso. Este esquema
        <strong>
            tiene sus problemas
        </strong>
        , puesto que si el proceso
        contiene
        <strong>
            ciclos infinitos
        </strong>
        , el resto de los procesos pueden quedar aplazados
        indefinidamente. Otro caso puede ser el de los procesos largos que penalizarían a los cortos
        si entran en primer lugar.
        <br>
        <br>
        La
        <strong>
            planificación apropiativa
        </strong>
        (en
        inglés,
        <span lang="en">
         preemptive
        </span>
        ) supone que el sistema operativo
        <strong>
            puede
            arrebatar el uso de la CPU
        </strong>
        a un proceso que esté ejecutándose. En la
        planificación apropiativa existe un reloj que lanza interrupciones periódicas en las cuales
        el planificador toma el control y se decide si el mismo proceso seguirá ejecutándose o se le
        da su turno a otro proceso.
        <br/><br/></p>
    <p>
        En ambos enfoques de planificación se pueden establecer distintos algoritmos de planificación
        de ejecución de procesos. Algunos de los
        <strong>
            algoritmos para decidir el orden de
            ejecución de los procesos en el sistema son
        </strong>
        :
    </p>
    <p>

    </p>
    <p>
        A continuación puedes ver una serie de vídeos con ejemplos simples explicados en los que se
        muestra el funcionamiento básico de estos algoritmos de planificación. Puedes visualizar los
        vídeos directamente en YouTube para verlos a mayor tamaño y con mejor resolución:
    </p>
    <p>
        <strong>
            <br style="clear: both;">
            Round Robin:
            <br/></strong>
    </p>

    <p>
        <strong>
            <br style="clear: both;">
            Por prioridades:
            <br/></strong>
    </p>

    <p>
        <br style="clear: both;">
        <strong>
            El trabajo más corto primero:
        </strong>
        <br/></p>

    <p>
        <br style="clear: both;">
        <strong>
            El primero en llegar, primero en ejecutarse:
        </strong>
        <br/></p>

    <p>
        <br style="clear: both;">
        <strong>
            El tiempo restante más corto primero:
        </strong>
        <br/></p>

</div><h1 class="title">
    4.- Gestión de memoria.
</h1><div class="iDevice_content">

    <p>
        <strong>
            <br>
            Ana
            <br/></strong>
        y
        <strong>
            Carlos
        </strong>
        tras entender la importancia de
        una adecuada gestión de procesos, preguntan: —¿Qué ocurre con la memoria principal?
        ¿Cómo la utiliza el sistema operativo para poder ejecutar los procesos
        de&nbsp;manera equilibrada? —
        <strong>
            Juan
        </strong>
        les explica que existen
        diferentes posibilidades en la gestión de la memoria que hace el sistema operativo.
        Pero lo primero es tener claro ciertos conceptos sobre el uso de la memoria. Juan
        comienza su explicación...
    </p>
</div><h1 class="title">
    4.1.- Gestión de memoria en sistemas operativos monotarea.
</h1><div class="iDevice_content">
    <p>
        En sus orígenes los sistemas operativos no incluían ningún gestor de memoria, y el
        programador tenía un control completo sobre el espacio total de memoria. La memoria real se
        utiliza para almacenar el programa que se esté ejecutando en un momento dado. Conforme los
        procesos se ejecutan secuencialmente a medida que van terminando los anteriores.
    </p>

    <p class="texto_centrado">
        <strong>
            Gestión de memoria en sistemas operativos monotarea
        </strong>
    </p>
    <p>
        Se trata del esquema más sencillo, en cada momento la memoria alberga un solo proceso y
        reserva otra zona de la memoria para el sistema operativo. Por ello, se necesita un
        <strong>
            mecanismo de protección
        </strong>
        para evitar accesos a la parte del sistema
        operativo de los procesos de usuario.
    </p>
</div><h1 class="title">
    4.2.- Gestión de memoria en sistemas operativos multitarea.
</h1><div class="iDevice_content">
    <p>
        Actualmente la mayoría de los sistemas operativos son sistemas multitarea, en los que va a
        haber varios procesos simultáneamente en ejecución. Para que esto sea posible, todos estos
        procesos deberán estar también simultáneamente en memoria, pues ésta es una condición
        necesaria para que un proceso pueda ejecutarse. Por tanto, deberá haber
        <strong>
            mecanismos
            de gestión para distribuir la memoria principal entre todos estos procesos que quieren
            ejecutarse
        </strong>
        .
    </p>

    <p class="texto_centrado">
        <strong>
            Gestión de memoria en sistemas operativos multitarea
        </strong>
    </p>
    <p>
        <strong>
            Intercambio o
            <span lang="en">
          swapping
         </span>
        </strong>
    </p>

    <p>
        Como sabemos la memoria principal es un recurso limitado, por ello puede ocurrir que
        <strong>
            haya más procesos esperando a ser cargados en memoria que zonas libres
        </strong>
        en
        la misma. En estos casos, el gestor de memoria sacará de la memoria algunos procesos
        (bloqueados, suspendidos, que estén esperando a que finalice una operación de
        entrada/salida, etc.) y los llevará a un área de disco (memoria secundaria), conocida como
        <strong>
            área de intercambio o de
            <span lang="en">
          swap
         </span>
        </strong>
        . A esta operación se
        la denomina
        <strong>
            intercambio o
            <span lang="en">
          swapping
         </span>
        </strong>
        . Los procesos
        permanecerán allí hasta que existan huecos libres en memoria y puedan ser recuperados de
        disco y reubicados en memoria principal.
    </p>

</div><h1 class="title">
    4.2.1.- Asignación de particiones fijas.
</h1><div class="iDevice_content">
    <p>
        Hemos estudiado que el gestor de memoria necesita reservar un espacio de memoria para el
        sistema operativo y que el resto de la memoria queda para los procesos de usuarios.
        <strong>
            Cuando existen varios procesos que requieren ser cargados en memoria el gestor de
            memoria tiene que organizar el espacio
        </strong>
        para ubicarlos.
    </p>
    <p>
        Hay varias alternativas, la primera de ellas es
        <strong>
            dividir el espacio de memoria en
            particiones fijas
        </strong>
        . Estas particiones podrán ser todas del mismo tamaño o tener
        distintos tamaños. Estas particiones se establecen de forma lógica por el sistema operativo
        y
        <strong>
            están predefinidas antes de que lleguen los procesos. El número de particiones se
            mantiene fijo en el tiempo, así como el tamaño de cada una de las particiones.
        </strong>
    </p>
    <p>
        La gestión y asignación de particiones a los procesos se puede hacer siguiendo dos tipos de
        organización:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Una cola por partición.
            </strong>
            <p>
                Se tiene
                <strong>
                    una
                </strong>
                <strong>
                    cola
                </strong>
                <strong>
                    por cada
                    partición
                </strong>
                y se coloca cada trabajo en la cola de la partición más
                pequeña en que quepa dicho trabajo, a fin de desperdiciar el menor espacio
                posible.
                <br>
                <strong>
                    La planificación de cada cola se hace por separado
                </strong>
                y,
                como cada cola tiene su propia partición, no hay competencia entre las colas por la
                memoria. La desventaja de este método se hace evidente cuando la cola de una
                partición grande está vacía y la cola de una partición pequeña está llena.
                <br/></p>

        </li>
        <li>
            <strong>
                Una única cola común a todas las particiones.
            </strong>
            <p>
                Se tiene una única cola común para todas las particiones.
                <strong>
                    El sistema
                    operativo decidirá en que partición se ubica cada proceso
                </strong>
                . En función
                de la disponibilidad de particiones y las necesidades del proceso en cuestión.
            </p>

        </li>
    </ul>
    <p>
        En ambos casos, utilización de una cola por partición o uso de una única cola para los
        procesos, el gestor de memoria establecerá
        <strong>
            mecanismos para impedir que un proceso
            pueda acceder a una zona de memoria que está fuera de la memoria correspondiente a la
            partición en la que se encuentra
        </strong>
        .
    </p>
    <p>
        Además de esto, puede surgir el problema de la
        <strong>
            fragmentación
        </strong>
        , la cual se
        produce, cuando en la memoria hay áreas ocupadas intercaladas con áreas libres; es decir,
        cuando no hay una única área ocupada ni una única área libre.
    </p>
</div><h1 class="title">
    4.2.2.- Asignación de particiones variables.
</h1><div class="iDevice_content">

    <p>
        Con la asignación de particiones fijas se tiene la desventaja de que no se aprovecha, con
        frecuencia, todo el tamaño de cada partición, ya que el proceso se adapta a los tamaños
        fijos ya preestablecidos en memoria. En este punto se plantea una segunda alternativa, la
        asignación de memoria a los procesos mediante particiones variables. La idea es
        <strong>
            crear las particiones dinámicamente, conforme llegan los procesos y en función de
            los tamaños de estos.
        </strong>
        Este método de gestión de memoria se conoce con el nombre
        de
        <strong>
            asignación de la memoria con particiones variables
        </strong>
        . Es una técnica más
        realista que aprovecha mejor el espacio de la memoria.
    </p>
    <ul class="lista_verificacion">
        <li>
            Este mecanismo se ajusta a la realidad de que el número y tamaño de los procesos varía
            dinámicamente y, por tanto, lo lógico es que no se está sujeto a un número fijo de
            particiones que pudieran ser muy grandes o demasiado pequeñas, con lo que
            <strong>
                se
                consigue un mejor uso de la memoria aunque a costa de una mayor
                complejidad
            </strong>
            .
        </li>
        <li>
            En la asignación de particiones variables, el sistema operativo debe llevar el control
            de qué partes de la memoria están disponibles y cuáles libres.
        </li>
    </ul>

</div><h1 class="title">
    4.2.3.- Memoria virtual.
</h1><div class="iDevice_content">

    <p>
        Hasta este momento los procesos se cargaban enteros en la memoria, pero podría suceder que
        existan procesos grandes que no quepan en las particiones de la memoria y por tanto, no
        puedan ser cargados por completo en la memoria.
    </p>
    <p>
        <strong>
            La memoria virtual
        </strong>
        da una solución a estos casos, ya que
        <strong>
            permite
            dividir los procesos en varias partes y cargar sólo algunas de ellas en memoria. La
            memoria virtual se basa en el uso de las técnicas de paginación o segmentación.
        </strong>
    </p>
    <p>
        ¿En qué consisten las técnica de paginación y segmentación? Conoce su funcionamiento básico
        por medio del siguiente recurso:
    </p>
    <div class="enlace_centrado">
        <span style="color: #0000ff;">
         Ver Anexo II.- Gestión de memoria:
								Técnicas de memoria virtual
        </span>
    </div>
    <p>
        Como hemos comentado, no todas las partes de un proceso pueden estar cargadas en memoria en
        un instante determinado. Por ello, cuando un proceso haga referencia a un parte que no se
        encuentre asignada en memoria provocará un
        <strong>
            fallo de página o segmento,
        </strong>
        y el
        gestor de memoria traerá dicha parte del proceso de disco a memoria.
    </p>
    <p>
        <strong>
            La utilización de las técnicas de paginación o segmentación por parte de la memoria
            virtual se conocen como:
        </strong>
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Memoria Virtual Paginada:
            </strong>
            Sigue el funcionamiento de la paginación
            simple, pero
            <strong>
                no es necesario cargar todas las páginas de un proceso
            </strong>
            para que éste pueda ejecutarse. Las páginas que no se encuentren y se necesiten se
            traerán posteriormente a memoria de manera automática. Reduce la fragmentación
        </li>
        <li>
            <strong>
                Memoria Virtual Segmentada
            </strong>
            : En este caso la operación sería la misma
            que en la segmentación simple, pero tampoco será necesario cargar todos los segmentos de
            un proceso. Si se necesitan más segmentos no asignados en memoria se traerán en el
            momento en que sean referenciados.
        </li>
        <li>
            <strong>
                Combinación de las técnicas de segmentación y paginación
            </strong>
            : En la figura
            siguiente vemos el funcionamiento de la combinación de ambas técnicas.
        </li>
    </ul>

    <p class="texto_centrado">
        Funcionamiento de la Segmentación paginada
    </p>
</div><h1 class="title">
    5.- Gestión de la entrada/salida.
</h1><div class="iDevice_content">

    <p>
        <br>
        Nuestros protagonistas utilizan a diario una gran variedad de periféricos
        (impresora, escáner, teclado, ratón, módem, monitor, dispositivos de almacenamiento
        externo, etc.). Hoy en día, estos dispositivos están preparados en su mayoría para
        enchufar y empezar a funcionar, algunos requieren la instalación de software
        específico para que el ordenador pueda trabajar con ellos adecuadamente.
        <strong>
            Carlos
        </strong>
        , que es un gran aficionado a la edición de música y video
        digitales, no se había planteado hasta este momento cómo interactúan su tarjeta
        capturadora de vídeo o los altavoces, por ejemplo. Al hilo de este tema mantiene una
        interesante conversación con
        <strong>
            Juan
        </strong>
        , que le recuerda que existen
        diferentes tipos de periféricos, le explica para qué sirven los controladores, qué
        estructuras de datos utilizan los dispositivos para la transferencia y recepción de
        información, etc. En definitiva, Juan le descubre a Carlos otra tarea fundamental
        del sistema operativo, la
        <strong>
            gestión de la E/S
        </strong>
        (entrada/salida).
        <br/></p>
</div><h1 class="title">
    5.1.- Controladores de dispositivo.
</h1><div class="iDevice_content">
    <p>
        <strong>
            ¿Cómo pueden entenderse los programas de aplicación con los dispositivos
            periféricos?
        </strong>
        Hay multitud de tipos y fabricantes de periféricos, esto conlleva
        que tanto el sistema operativo como los fabricantes de periféricos deben
        <strong>
            estandarizar el acceso a los dispositivos
        </strong>
        utilizando lo que se denominan
        <strong>
            controladores de dispositivos
        </strong>
        (
        <strong>
         <span lang="en">
          device
									drivers
         </span>
        </strong>
        ).
    </p>
    <p>
        Un periférico siempre tiene dos partes: un
        <strong>
            controlador,
        </strong>
        se encarga de la
        comunicación con la CPU y un
        <strong>
            dispositivo
        </strong>
        mecánico, electromecánico o
        electromagnético. El controlador es un software, generalmente, suministrado por el
        fabricante del dispositivo o bien por el desarrollador del sistema operativo. De esta
        manera, estos controladores actúan como
        <strong>
            interfaz entre los programas y el hardware.
        </strong>
    </p>

    <p class="texto_centrado">
        <strong>
            Funcionamiento de un controlador de dispositivo
        </strong>
    </p>
</div><h1 class="title">
    5.2.- Estructura de datos de la E/S.
</h1><div class="iDevice_content">
    <p>
        Otro punto importante es la
        <strong>
            estructura de datos
        </strong>
        que utilizan los
        dispositivos periféricos para manejar la información y comunicación entre dispositivos o
        entre estos y la CPU. Las más utilizadas son los
        <strong>
         <span lang="en">
          spools
         </span>
        </strong>
        y los
        <strong>
         <span lang="en">
          buffers
         </span>
            .
        </strong>
    </p>

    <ul class="lista_verificacion">
        <li>
            <p>
                <strong>
           <span lang="en">
            Spools
           </span>
                </strong>
                : Los
                <strong>
                    datos de salida se
                    almacenan
                </strong>
                de forma temporal en una
                <strong>
                    cola
                </strong>
                situada en un
                <strong>
                    dispositivo de almacenamiento
                </strong>
                masivo (
                <span lang="en">
           spool
          </span>
                ), hasta que el dispositivo periférico requerido se
                encuentre libre. De este modo se evita que un programa quede retenido porque el
                periférico no esté disponible. El sistema operativo dispone de llamadas para añadir
                y eliminar archivos del
                <strong>
           <span lang="en">
            spool
           </span>
                </strong>
                . Se utiliza en
                <strong>
                    dispositivos que no admiten intercalación
                </strong>
                , como ocurre en la
                impresora, ya que no puede empezar con otro hasta que no ha terminado.
            </p>
        </li>
        <li>
            <p>
                <strong>
           <span lang="en">
            Buffers
           </span>
                </strong>
                <strong>
                    :
                </strong>
                Es para
                <strong>
                    dispositivos que pueden atender peticiones de distintos orígenes
                </strong>
                .
                En este caso
                <strong>
                    .
                </strong>
                los datos no tienen que enviarse completos, pueden
                enviarse porciones que el
                <strong>
           <span lang="en">
            buffer
           </span>
                </strong>
                retiene de
                forma temporal. También se utilizan para acoplar velocidades de distintos
                dispositivos. Así, si un dispositivo lento va a recibir información más rápido de lo
                que puede atenderla se emplea un
                <strong>
           <span lang="en">
            buffer
           </span>
                </strong>
                para
                retener temporalmente la información hasta que el dispositivo pueda asimilarla. Esto
                ocurre entre una grabadora de DVD y el disco duro, ya que la primera funciona a una
                menor velocidad que el segundo.
            </p>
        </li>
    </ul>
</div><h1 class="title">
    5.3.- Técnicas de la E/S.
</h1><div class="iDevice_content">
    <p>
        Vamos a conocer las distintas formas de funcionamiento de la E/S en los sistemas operativos
        según la intervención de la CPU. En estos momentos tenemos:
    </p>
    <table class="tabla">
        <caption>
            Técnicas para realizar la entrada/salida
        </caption>
        <thead>
        <tr>
            <td>
            </td>
            <th scope="col">
                Sin interrupciones
            </th>
            <th scope="col">
                Con interrupciones
            </th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th scope="row">
                Transferencia de E/S a memoria a través de la CPU
            </th>
            <td>
                E/S programada
            </td>
            <td>
                E/S por interrupciones
            </td>
        </tr>
        <tr>
            <th scope="row">
                Transferencia de E/S directa a memoria
            </th>
            <td>
            </td>
            <td>
                Acceso directo a memoria (
                <abbr title="Direct Memory Access.">
                    DMA
                </abbr>
                )
            </td>
        </tr>
        </tbody>
    </table>
    <p>
    </p>

    <ul class="lista_verificacion">
        <li>
            <p>
                <strong>
                    E/S programada
                </strong>
                : la CPU tiene todo el protagonismo ya que inicia y
                lleva a cabo la transferencia. Esta técnica
                <strong>
                    repercute en la velocidad de
                    proceso del ordenador
                </strong>
                porque la CPU debe dejar todo lo que está
                haciendo para ocuparse del proceso de entrada/salida.
            </p>
        </li>
        <li>
            <p>
                <strong>
                    E/S por
                    interrupciones


                    Interrupción

                    Señal
                    que envía un dispositivo de E/S a la CPU para indicar que la operación
                    de la que se estaba ocupando, ya ha terminado.
                    :
                </strong>
                la
                CPU ejecuta la transferencia pero el inicio es pedido por el periférico que indica
                así su disponibilidad. La CPU no pregunta a los dispositivos sino que son estos los
                que la avisan cuando es necesario.
            </p>
        </li>
        <li>
            <p>
                <strong>
                    Acceso directo a memoria (DMA)
                </strong>
                : la transferencia es realizada por un
                controlador especializado. Esta técnica acelera enormemente el proceso de la E/S y
                libera a la CPU de trabajo. Lo habitual es que los datos que se quieren escribir en
                el dispositivo o que son leídos del dispositivo provengan o vayan a la memoria del
                ordenador, pues bien en este caso
                <strong>
                    ,
                </strong>
                la CPU inicia el proceso, pero
                luego este continúa sin necesitar a la CPU, con lo que
                <strong>
                    se acelera mucho el
                    proceso de entrada/salida y se libera a la CPU del proceso
                </strong>
                .
            </p>
        </li>
    </ul>
</div><h1 class="title">
    5.4.- Planificación de discos.
</h1><div class="iDevice_content">
    <p>
        En la anterior unidad estudiamos la estructura y funcionamiento del disco duro, en este
        apartado conoceremos la
        <strong>
            forma u orden
        </strong>
        en que el
        <strong>
            sistema operativo
            atiende las peticiones de lectura/escritura en disco
        </strong>
        . Para ello utiliza lo que
        se conoce como
        <strong>
            algoritmos de planificación del disco.
        </strong>
        Antes de estudiarlas,
        fíjate en la figura sobre el
        <strong>
            funcionamiento de la E/S en una unidad de
            disco
        </strong>
        :
    </p>

    <p class="texto_centrado">
        <strong>
            E/S en disco
        </strong>
    </p>
    <p>
        Los algoritmos de
        <strong>
            planificación del disco
        </strong>
        más importantes son:
    </p>
    <p>

    </p>
    <p>
        ¿Cómo funcionan cada uno de estos algoritmos? Veámoslo con la siguiente animación:
    </p>
    <div class="elemento_centrado">
        <div class="elemento_centrado">
            <div class="exe-fx exe-carousel" id="exe-carousel-1">
                <div class="fx-carousel-content fx-C2 fx-current" id="exe-carousel-1-0">
                    <h2>
                        Algoritmos de planificación de disco
                    </h2>
                    <ul class="lista_verificacion" style="text-align: left;">
                        <li style="text-align: left;">
                            <p>
                                <strong>
                                    Algoritmo FCFS (First Come, First Served)
                                </strong>
                            </p>
                        </li>
                        <li style="text-align: left;">
                            <p>
                                <strong>
                                    Algoritmo SSF (Shortest Seek First)
                                </strong>
                            </p>
                        </li>
                        <li>
                            <p style="text-align: left;">
                                <strong>
                                    Algoritmo Scan o algoritmo del
                                    ascensor
                                </strong>
                                <strong>
                                </strong>
                            </p>
                        </li>
                        <li>
                            <p style="text-align: left;">
                                <strong>
                                    Algoritmo C-Scan o algoritmo Scan
                                    Circular
                                </strong>
                            </p>
                        </li>
                    </ul>
                </div>
                <div class="fx-carousel-content fx-C2" id="exe-carousel-1-1">
                    <h2>
                        Algoritmo FCFS (First Come, First Served)
                    </h2>
                    <p style="text-align: left;">
                        <strong>
                            ‘Primero en llegar, primero en ser
                            servido’
                        </strong>
                        es la planificación más sencilla, emplea una cola tipo
                        <strong>
                            FIFO
                        </strong>
                        (
                        <em>
                            First In, First Out
                        </em>
                        –
                        <strong>
                            Primero en
                            entrar, primero en salir
                        </strong>
                        ).
                    </p>
                    <p style="text-align: left;">
                        Se da servicio a las solicitudes de acceso a disco
                        de la cola según el orden de llegada de dichas solicitudes. Este algoritmo
                        parece justo, pero en promedio, puede dar lugar a
                        <strong>
                            tiempos bastante
                            grandes.
                        </strong>
                    </p>
                </div>
                <div class="fx-carousel-content fx-C2" id="exe-carousel-1-2">
                    <h2>
                        Algoritmo SSF (Shortest Seek First)
                    </h2>
                    <p style="text-align: left;">
                        La planificación
                        <strong>
                            SSF
                        </strong>
                        (
                        <em>
                            Shortest
                            Seek First
                        </em>
                        –
                        <strong>
                            Primero la búsqueda más cercana
                        </strong>
                        )
                        atiende primero la solicitud de la cola de solicitudes pendientes que quiere
                        acceder al cilindro más cercano al de la solicitud actual, que se está
                        procesando.
                    </p>
                    <p style="text-align: left;">
                        Es decir, atiende primero la petición que requiere
                        el menor movimiento de la cabeza de lectura/escritura desde su posición
                        actual.
                    </p>
                    <p style="text-align: left;">
                        Sin embargo, pueden llegar solicitudes que
                        impliquen cilindros próximos al actual, por lo que estas solicitudes serán
                        atendidas enseguida mientras que otras que llegaron antes, con cilindros más
                        alejados, no se atenderán. Esto puede causar un
                        <strong>
                            bloqueo
                            indefinido
                        </strong>
                        .
                    </p>
                </div>
                <div class="fx-carousel-content fx-C2" id="exe-carousel-1-3">
                    <h2>
                        Algoritmo Scan o algoritmo del ascensor
                    </h2>
                    <p style="text-align: left;">
                        La planificación
                        <strong>
                            <em>
                                Scan
                            </em>
                        </strong>
                        ,
                        también conocida como
                        <strong>
                            algoritmo del ascensor
                        </strong>
                        porque va
                        dando servicio a las solicitudes que van encontrando en el sentido en el que
                        se van desplazando las cabezas de lectura/escritura. Cuando no hay más
                        solicitudes en ese sentido, o se llega al extremo, se invierte el sentido
                        para hacer lo mismo otra vez pero yendo hacia el otro lado.
                    </p>
                    <p style="text-align: left;">
                        Por tanto, en este algoritmo es necesario tener un
                        bit que indique el sentido del movimiento.
                    </p>
                    <p style="text-align: left;">
                        Este algoritmo
                        <strong>
                            evita el bloqueo indefinido
                        </strong>
                        que se puede producir con la planificación
                        <strong>
                            SSF
                        </strong>
                        .
                        Este algoritmo es más
                        <strong>
                            apropiado para sistemas que hacen gran uso del
                            disco.
                        </strong>
                    </p>
                </div>
                <div class="fx-carousel-content fx-C2" id="exe-carousel-1-4">
                    <h2>
                        Algoritmo C-Scan o algoritmo Scan Circular
                    </h2>
                    <p style="text-align: left;">
                        En esta planificación la cabeza se mueve de un
                        extremo del disco al otro atendiendo las solicitudes que va encontrando,
                        pero al llegar al extremo opuesto, regresa de inmediato al otro sin servir
                        ninguna solicitud; ya que en la zona próxima a dicho extremo habrá pocas
                        solicitudes, puesto que las solicitudes para acceder a los cilindros de
                        dicha zona acaban de ser atendidas.
                    </p>
                </div>
                <ul class="fx-pagination fx-carousel-pagination">
                    <li class="fx-carousel-prev-next fx-carousel-prev fx-disabled fx-C2" id="exe-carousel-1-prev">
                        ◄


                        Anterior
                    </li>
                    <li class="fx-current fx-C1" id="exe-carousel-1-0-link">
                        1
                    </li>
                    <li id="exe-carousel-1-1-link">
                        2
                    </li>
                    <li id="exe-carousel-1-2-link">
                        3
                    </li>
                    <li id="exe-carousel-1-3-link">
                        4
                    </li>
                    <li id="exe-carousel-1-4-link">
                        5
                    </li>
                    <li class="fx-carousel-prev-next fx-carousel-next fx-C2" id="exe-carousel-1-next">
                        ►


                        Siguiente
                    </li>
                </ul>
            </div>
        </div>

    </div>
</div><h1 class="title">
    6.- Gestión del sistema de archivos.
</h1><div class="iDevice_content">

    <p>
        <strong>
            <br>
            Carlos
            <br/></strong>
        y
        <strong>
            Ana
        </strong>
        están aprendiendo de la mano de
        <strong>
            María
        </strong>
        y
        <strong>
            Juan
        </strong>
        las principales funciones de los
        sistemas operativos. Pero ahora se preguntan, ¿qué ocurre con los archivos y
        directorios? ¿qué información almacena el sistema operativo de estos? ¿qué
        operaciones pueden realizarse sobre los mismos? ¿existen distintas formas de
        referenciar un archivo o directorio? Éstas y otras cuestiones encuentran respuesta
        con las explicaciones de
        <strong>
            Juan
        </strong>
        y
        <strong>
            María
        </strong>
        .
    </p>
</div><h1 class="title">
    6.1.- Organización lógica y física.
</h1><div class="iDevice_content">

    <p>
        Se suele diferenciar entre la
        <strong>
            organización de discos
        </strong>
        a nivel
        <strong>
            físico
        </strong>
        (hardware) y
        <strong>
            lógico
        </strong>
        (software). El nivel físico de
        almacenamiento de datos en un disco duro consiste en el formateo en pistas, sectores,
        cilindros y platos. Pero esto es
        <strong>
            muy dependiente del hardware
        </strong>
        concreto que
        se esté usando y además
        <strong>
            funciona a muy bajo nivel
        </strong>
        .
    </p>
    <p>
        Los
        <strong>
            sistemas de archivos
        </strong>
        deben proveer una capa de
        <strong>
            abstracción
        </strong>
        que
        <strong>
            oculte los detalles puramente hardware
        </strong>
        al
        usuario y le permita utilizar el medio de almacenamiento (disco) de una forma intuitiva y
        cómoda, por supuesto más cercana a los hábitos humanos de organización de la información.
        Éste es el
        <strong>
            nivel lógico
        </strong>
        del sistema de archivos y naturalmente en el que
        estamos más interesados.
    </p>
    <p>
        A esto se le llama
        <strong>
            organización del sistema de archivos
        </strong>
        y suele coincidir en
        todos los sistemas de archivos actuales, utilizando el esquema de almacenamiento en
        <strong>
            archivos
        </strong>
        y la organización en
        <strong>
            carpetas o directorios.
        </strong>
    </p>
    <p>
        ¿
        <strong>
            En qué consisten
        </strong>
        los
        <strong>
            archivos y carpetas
        </strong>
        ? y ¿cómo los
        <strong>
            gestiona el sistema de archivos
        </strong>
        ?
        <br>
        <strong>
            Archivos:
        </strong>
        Es el
        elemento central de la mayoría de programas de aplicación. Los archivos o ficheros son
        estructuras de datos en disco donde se almacena la información y los programas de un
        ordenador. Pueden tener diversas estructuras y ello dependerá del sistema de archivos de
        nuestro sistema operativo y de la extensión del mismo.
        <br/></p>
    <p>
        Cada
        <strong>
            archivo
        </strong>
        de un sistema tendrá unas
        <strong>
            características, o
            atributos,
        </strong>
        que lo identifican y le sirven al sistema de archivos y al sistema
        operativo para manejarlo correctamente. Los
        <strong>
            atributos
        </strong>
        pueden variar de un
        sistema a otro, pero suelen coincidir al menos en los siguientes:
    </p>

    <ul class="lista_verificacion">
        <li>
            <strong>
                Nombre:
            </strong>
            Identificador principal del archivo para el usuario. Cada
            sistema operativo establece las reglas para nombrar a los archivos, en cuanto a longitud
            y caracteres permitidos.
        </li>
        <li>
            <strong>
                Extensión:
            </strong>
            La extensión de un archivo son los caracteres que se colocan
            al final del nombre del un archivo para
            <strong>
                especificar su tipo de
                contenido
            </strong>
            . Por ejemplo, la extensión “.TXT” indica que el archivo es de
            texto o la extensión “.EXE” indica que el archivo es un programa ejecutable.
        </li>
        <li>
            <strong>
                Permisos:
            </strong>
            El sistema de archivos debe controlar qué usuarios están
            autorizados a utilizar cada archivo y qué operaciones pueden realizar. Por ejemplo un
            archivo puede tener permiso de lectura y escritura para un usuario y en cambio otro
            usuario solo podrá utilizar el archivo en modo de lectura.
        </li>
        <li>
            <strong>
                Creador:
            </strong>
            Identificador del usuario que creó el archivo.
        </li>
        <li>
            <strong>
                Propietario:
            </strong>
            Identificador del usuario que es el propietario actual del
            archivo.
        </li>
        <li>
            <strong>
                Fecha de creación:
            </strong>
            Fecha y hora de la creación del archivo.
        </li>
        <li>
            <strong>
                Fecha del último acceso:
            </strong>
            Fecha y hora del último acceso al archivo.
        </li>
        <li>
            <strong>
                Fecha de la última modificación:
            </strong>
            Fecha y hora de la última modificación
            al archivo.
        </li>
        <li>
            <strong>
                Tamaño actual:
            </strong>
            Número de bytes que ocupa el archivo en el disco duro
            del ordenador.
        </li>
    </ul>
    <p>
        <strong>
            Directorios:
        </strong>
        También denominados
        <strong>
            carpetas
        </strong>
        , son archivos
        especiales que cumplen la función de almacenar y organizar en su interior a archivos y otros
        subdirectorios. Son estos los que permiten mantener una cierta organización en el sistema de
        archivos. La organización en directorios mantiene forma de árbol invertido que comienza por
        un
        <strong>
            directorio principal llamado raíz
        </strong>
        y se va
        <strong>
            ramificando
        </strong>
        en otros directorios que pueden contener archivos y otros directorios. Respecto a los
        <strong>
            atributos de un directorio
        </strong>
        , como archivos que son coinciden con los
        atributos de estos.
    </p>
</div><h1 class="title">
    6.2.- Operaciones soportadas por un sistema de archivos.
</h1><div class="iDevice_content">

    <p style="text-align: right;">
        <br>
        <br>
        <br/><br/></p>
    <p>
        Las
        <strong>
            operaciones básicas
        </strong>
        sobre
        <strong>
            archivos
        </strong>
        que la mayoría de
        los sistemas de archivos soportan son:
    </p>
    <ul class="lista_verificacion">
        <li>
            <strong>
                Crear:
            </strong>
            Los archivos se crean sin datos y después el usuario o alguna
            aplicación los van llenando.
        </li>
        <li>
            <strong>
                Borrar:
            </strong>
            Si un archivo ya no es necesario debe eliminarse para liberar
            espacio e n disco.
        </li>
        <li>
            <strong>
                Abrir:
            </strong>
            Antes de utilizar el archivo se debe abrir para que el sistema
            conozca sus atributos, tales como el propietario, fecha de modificación, etc.
        </li>
        <li>
            <strong>
                Cerrar:
            </strong>
            Tras realizar las operaciones deseadas sobre el archivo, éste
            puede cerrarse para asegurar su integridad y liberar recursos de memoria que tuviera
            asignados.
        </li>
        <li>
            <strong>
                Leer:
            </strong>
            Los
            <strong>
                datos se leen del archivo
            </strong>
            ; quien hace la
            llamada (programa) debe especificar la cantidad de datos necesarios y proporcionar un
            <strong>
          <span lang="en">
           buffer
          </span>
            </strong>
            para colocarlos.
        </li>
        <li>
            <strong>
                Escribir:
            </strong>
            Los
            <strong>
                datos se escriben en el archivo
            </strong>
            . El
            tamaño del archivo puede aumentar si se agregan datos nuevos o no si lo que se hace es
            actualizar los existentes.
        </li>
        <li>
            <strong>
                Renombrar:
            </strong>
            Permite
            <strong>
                modificar el atributo nombre
            </strong>
            de un
            archivo ya existente.
        </li>
    </ul>
    <p>
        Los sistemas de archivos también suministran un conjunto
        <strong>
            de operaciones para los
            directorios
        </strong>
        , las más comunes son:
        <strong>
            crear, borrar, abrir, cerrar,
            renombrar
        </strong>
        y
        <strong>
            leer.
        </strong>
        Además existen
        <strong>
            otras dos operaciones
            sobre archivos y directorios
        </strong>
        como son la de
        <strong>
            crear un enlace y
            eliminarlo
        </strong>
        . La operación de crear un enlace se utiliza para poder acceder a un
        archivo o directorio desde distintos puntos de la organización de directorios del sistema
        sin tener que duplicar o copiar el archivo o directorio en cuestión.
    </p>
</div><h1 class="title">
    6.3.- Rutas de acceso.
</h1><div class="iDevice_content">
    <p>
        Los
        <strong>
            sistemas de archivos
        </strong>
        necesitan una forma de determinar la
        <strong>
            localización exacta de un archivo o directorio
        </strong>
        en la estructura del árbol
        de directorios. La ruta de acceso a un archivo o directorio se indica nombrando todos los
        directorios y subdirectorios que tienen que atravesarse hasta llegar al elemento concreto.
        Dependiendo del sistema operativo con el que se trabaje cambiará la forma de establecer la
        ruta de acceso. Por ejemplo, en Windows se utiliza la barra invertida “\” para separar los
        directorios y en Linux se utiliza la barra “/”.
        <br>
        Existen
        <strong>
            dos tipos de rutas de
            acceso
        </strong>
        :
        <br/></p>
    <ul class="lista_verificacion">
        <li>
            <p>
                <strong>
                    Ruta de Acceso Absoluta:
                </strong>
                Se comienza desde el
                <strong>
                    directorio
                    raíz
                </strong>
                y se va descendiendo en la estructura de directorios
                <strong>
                    hasta
                    llegar al archivo o directorio buscado
                </strong>
                . En las rutas de acceso
                absolutas se conoce la ubicación exacta. En sistemas Windows las rutas absolutas
                comienzan con una letra de una unidad seguida del carácter ':' (ejemplo:
                "D:\Documentos"). En sistemas Linux las rutas absolutas comienzan con la barra '/',
                que marca el inicio de la estructura de directorios (ejemplo:
                "/home/luisa/Escritorio/Documento.odt").
            </p>
        </li>
    </ul>


    <ul class="lista_verificacion">
        <li>
            <p>
                <strong>
                    Ruta de Acceso Relativa:
                </strong>
                Se utiliza junto con el concepto de
                <strong>
                    directorio de trabajo o directorio activo,
                </strong>
                que es aquel donde
                estamos situados en un momento dado. Consiste en escribir la
                <strong>
                    ruta a partir
                    del directorio activo
                </strong>
                , esto se indica con ‘.’ que hace referencia a la
                localización actual donde nos encontramos y '..' indica el directorio padre. También
                se puede escribir en primer lugar directamente el nombre de un directorio al que
                queremos subir sin usar el punto '.'. En las rutas de acceso relativas no se conoce
                la ubicación exacta del recurso al que se apunta ya que depende de la localización
                del directorio activo. En los siguientes ejemplos primero se baja uno o dos niveles
                usando ".." para luego subir a otros directorios.
            </p>
        </li>
    </ul>


</div><h1 class="title">
    7.- Mecanismos de seguridad y protección.
</h1><div class="iDevice_content">

    <p>
        <strong>
            <br>
            Ada
            <br/></strong>
        , como responsable de la empresa BK Programación, está muy
        concienciada de la relevancia de la seguridad en el ámbito informático. Por ello,
        los trabajadores de la empresa están muy sensibilizados con este tema. Ada decide
        que es hora de que los nuevos compañeros que acaban de llegar a la empresa reciban
        un breve seminario sobre
        <strong>
            seguridad informática
        </strong>
        , en este caso,
        centrándose en la relacionada con los sistemas operativos y otros elementos
        relacionados.
        <strong>
            María
        </strong>
        será la encargada de impartir dicho seminario.
    </p>
</div><h1 class="title">
    8.- Documentación y búsqueda de información técnica.
</h1><div class="iDevice_content">
    <p>
    </p>

    <p>
        <br>
        Cuando en
        <strong>
            BK Programación
        </strong>
        descubren una nueva aplicación
        interesante para su trabajo, no dudan en probarla para ver los resultados que aporta
        y decidir si pueden ofrecerla con garantías a sus clientes.
        <strong>
            María
        </strong>
        es bastante metódica a la hora de empezar a trabajar con un nuevo producto software,
        y siempre le gusta documentarse antes de poner en marcha y utilizar una aplicación.
        Para ello, echa mano de los
        <strong>
            manuales
        </strong>
        suministrados por el
        <strong>
            fabricante de software, tutoriales
        </strong>
        realizados por usuarios expertos
        y otros recursos.
        <strong>
            Juan
        </strong>
        es un experto en la búsqueda de este tipo
        de
        <strong>
            recursos
        </strong>
        y se conoce multitud de
        <strong>
            fuentes
        </strong>
        : foros
        de expertos, sitios web donde otros usuarios vuelcan problemas técnicos y posibles
        soluciones a estos. Incluso, ha creado un
        <strong>
            repositorio online
        </strong>
        de
        <strong>
            manuales
        </strong>
        con toda la documentación útil encontrada.
        <strong>
            Ada
        </strong>
        sabe que la gestión y asesoramiento software de BK Programación
        está en buenas manos.
        <br/></p>
</div><h1 class="title">
    Anexo I.- Evolución histórica de los sistemas operativos.
</h1><div class="iDevice_content">
    <p>

    </p>
    <p>
        El hardware y el software de los sistemas informáticos han evolucionado de forma paralela y
        conjunta en las últimas décadas. Por lo que la evolución que vamos a ver de los sistemas
        operativos está estrechamente relacionada con los avances en la arquitectura de los
        ordenadores que se produjo de cada generación.
    </p>
    <p>

    </p>
    <p>
        <strong>
            Primera generación (1945-1955)
        </strong>
    </p>
    <p>
        Los primeros ordenadores estaban construidos con tubos de vacío. En un principio no existían
        sistemas operativos, se programaba directamente sobre el hardware. Los programas estaban
        hechos directamente en código máquina y el control de las funciones básicas se realiza
        mediante paneles enchufables.
    </p>
    <p>
        Hacia finales de 1950 aparecen las tarjetas perforadas que sustituyen los paneles
        enchufables. Las tarjetas perforadas supusieron un enorme paso ya que permitían codificar
        instrucciones de un programa y los datos en una cartulina con puntos que podía interpretar
        el ordenador. La mayoría de los programas usaban rutinas de E/S y un programa cargador
        (automatizaba la carga de programas ejecutables en la máquina). Esto constituía una forma
        rudimentaria de sistema operativo.
    </p>
    <p>
    </p>
    <p>
        <strong>
            2ª Generación (1955-1965)
        </strong>
    </p>
    <p>
        Esta generación se caracteriza por la aparición de los
        <strong>
            transistores
        </strong>
        que
        permitieron la construcción de ordenadores más pequeños y potentes. La programación se
        realizaba en lenguaje ensamblador y en FORTRAN sobre tarjetas perforadas. Otro aspecto
        importante de esta generación es el
        <strong>
            procesamiento por lotes
        </strong>
        , en el cual
        mientras el sistema operativo está ejecutando un proceso, este último dispone de todos los
        recursos hasta su finalización. La preparación de los trabajos se realiza a través de un
        lenguaje de control de trabajos conocido como
        <span lang="en" title="Job Control Language.">
         JCL
        </span>
        . El sistema operativo residía en memoria y tenía un programa de
        control que interpretaba las tarjetas de control, escritas JCL. Dependiendo del contenido de
        la tarjeta de control el sistema operativo realizaba una acción determinada. Este programa
        de control es un antecedente de los modernos intérpretes de órdenes.
    </p>
    <p>

    </p>
    <p>
        <strong>
            Procesamiento Fuera de línea (Offline)
        </strong>
    </p>
    <p>
        Como mejora del procesamiento por lotes surgió el
        <strong>
            procesamiento fuera de línea
            (off-line)
        </strong>
        , en el cual las operaciones de carga de datos y salida de resultados
        de un proceso podían realizarse de forma externa y sin afectar al tiempo que el procesador
        dedicaba a los procesos. A esto ayudó la aparición de las cintas magnéticas y las impresoras
        de líneas. Ejemplos de sistemas operativos de la época son
        <strong>
            <abbr title="Fortran Monitor System.">
                FMS
            </abbr>
        </strong>
        (Fortran Monitor
        System) y
        <strong>
            IBSYS
        </strong>
        .
    </p>
    <p>
    </p>
    <p>
        <strong>
            3ª Generación (1965-1980)
        </strong>
    </p>
    <p>
        La aparición de los
        <strong>
            circuitos integrados (
            <abbr title="Circuito Integrado.">
                CI
            </abbr>
            )
        </strong>
        supuso una mejora consiguiendo un
        menor tamaño y relación precio/rendimiento respecto de las máquinas de generaciones
        anteriores. En relación con los sistemas operativos, la característica principal de esta
        generación fue el desarrollo de la
        <strong>
            multiprogramación
        </strong>
        y los
        <strong>
            sistemas
            compartidos
        </strong>
        . En los sistemas multiprogramados se cargan varios programas en
        memoria simultáneamente y se alterna su ejecución. Esto maximiza la utilización del
        procesador. Como evolución de aparecen los sistemas de tiempo compartido donde el tiempo del
        procesador se comparte entre programas de varios usuarios pudiendo ser programas
        interactivos. Algunos de los sistemas operativos de esta generación son
        <strong>
            OS/360
        </strong>
        ,
        <strong>
            CTSS
        </strong>
        ,
        <strong>
            MULTICS
        </strong>
        y
        <strong>
            UNIX
        </strong>
        .
    </p>
    <p>
        <strong>
            4ª Generación (1980-hasta hoy)
        </strong>
    </p>
    <p>
        En esta generación se producen grandes avances en la industria hardware como la creación de
        los
        <strong>
            circuitos LSI
        </strong>
        (integrados a gran escala). También aparecen los
        ordenadores personales, entre finales de la anterior generación y principios de la presente.
        Ejemplos de sistemas operativos de los
        <strong>
            primeros ordenadores personales
        </strong>
        son
        <strong>
            MS-DOS
        </strong>
        , desarrollado por
        <strong>
            Microsoft, Inc
        </strong>
        ., para el IBM PC y
        <strong>
            MacOS
        </strong>
        de
        <strong>
            Apple Computer
        </strong>
        , Inc. Steve Jobs, cofundador de
        Apple, apostó por la
        <strong>
            primera interfaz gráfica basada en ventanas, iconos, menús y
            ratón
        </strong>
        a partir de una investigación realizada por Xerox. Siguiendo esta
        filosofía aparecería
        <strong>
            MS Windows
        </strong>
        . Durante los 90 apareció
        <strong>
            Linux
        </strong>
        a partir del núcleo desarrollado por Linus Torvalds. Los sistemas
        operativos evolucionan hacia sistemas interactivos con una interfaz cada vez más amigable al
        usuario. Los sistemas Windows han ido evolucionando, con diferentes versiones tanto para
        escritorio como para servidor (
        <strong>
            Windows 3.x, 98, 2000, XP, Vista, 7, Windows Server
            2003, 2008
        </strong>
        , etc), al igual que lo han hecho Linux (con multitud de
        distribuciones, Ubuntu, Debian, RedHat, Mandrake, etc) y los sistemas Mac (
        <strong>
            Mac OS 8,
            OS 9, OS X, Mac OS X 10.6 "Snow Leopard"
        </strong>
        , entre otros).
    </p>
    <div style="width: 100%;">
        <div style="width: 33%; float: left;">
        </div>
        <div style="width: 34%; float: left;">
            <p>
            </p>
        </div>
        <div style="width: 33%; float: right;">
        </div>
    </div>
    <div style="clear: both;">
    </div>
    <p>
        Un avance importante fue el desarrollo de
        <strong>
            redes de ordenadores
        </strong>
        a mediados de
        los años 80 que ejecutan
        <strong>
            sistemas operativos en red
        </strong>
        y
        <strong>
            sistemas
            operativos distribuidos.
        </strong>
        En un sistema operativo en red los usuarios tienen
        conocimiento de la existencia de múltiples ordenadores y pueden acceder a máquinas remotas y
        copiar archivos de un ordenador a otro. En un sistema distribuido los usuarios no saben
        donde se están ejecutando sus programas o dónde están ubicados sus programas, ya que los
        recursos de procesamiento, memoria y datos están distribuidos entre los ordenadores de la
        red, pero todo esto es transparente al usuario.
    </p>
    <p>
        Actualmente, existen
        <strong>
            sistemas operativos integrados
        </strong>
        , para una gran
        diversidad de dispositivos electrónicos, tales como, teléfonos móviles,
        <abbr title="Personal Digital Assistant.">
            PDA
        </abbr>
        s (Personal Digital
        Assistant, Asistente Digital Personal u ordenador de bolsillo), otros dispositivos de
        comunicaciones e informática y electrodomésticos. Ejemplos de este tipo de sistemas
        operativos son
        <strong>
            PalmOS,
        </strong>
        <strong>
            WindowsCE, Android OS
        </strong>
        , etc. Haremos
        una referencia especial al último, Android OS, se trata de un sistema operativo basado en
        Linux. Fue diseñado en un principio para dispositivos móviles, tales como teléfonos
        inteligentes y tablets, pero actualmente se encuentra en desarrollo para su aplicación
        también en netbooks y PCs.
    </p>
    <div style="width: 100%;">
        <div style="width: 50%; float: left;">
        </div>
        <div style="width: 50%; float: right;">
        </div>
    </div>
    <div style="clear: both;">
    </div>
</div><h1 class="title">
    Anexo II.- Gestión de memoria: Técnicas de memoria virtual.
</h1><div class="iDevice_content">

    <p>
        <strong>
            Paginación pura
        </strong>
    </p>
    <p>
        La idea es la de
        <strong>
            dividir la memoria principal en un conjunto de particiones
            conocidas como “marcos de página”
        </strong>
        de igual tamaño. Cada
        <strong>
            proceso se
            divide a su vez en una serie de partes llamadas “páginas”
        </strong>
        del mismo tamaño que
        los marcos. El proceso se carga en memoria situando todas sus páginas en los marcos de
        página de la memoria, sin embargo, las páginas no tienen porque estar contiguas en memoria.
        Como ventaja
        <strong>
            reduce
        </strong>
        la
        <strong>
            fragmentación externa
        </strong>
        de la memoria
        principal. Sin embargo, puede
        <strong>
            aparecer cierta fragmentación interna
        </strong>
        .
    </p>
    <p>

    </p>
    <p class="texto_centrado">
        Funcionamiento de la Paginación pura
    </p>
    <p>
        <strong>
            Segmentación pura
        </strong>
    </p>
    <p>
        <strong>
            Cada proceso se divide en una serie de segmentos
        </strong>
        . La peculiaridad de estos
        <strong>
            segmentos es que su tamaño no tiene que ser el mismo y puede variar
        </strong>
        hasta
        un límite máximo. Un proceso se carga situando todos sus segmentos en particiones dinámicas
        que no tienen que estar contiguas en memoria. Este sistema
        <strong>
            reduce
        </strong>
        la
        <strong>
            fragmentación interna
        </strong>
        de la memoria principal.
    </p>
    <p>

    </p>
    <p class="texto_centrado">
        Funcionamiento de la Segmentación pura
    </p>
</div><h1 class="title">
    Condiciones y términos de uso de los materiales
</h1><div class="iDevice_content">
    <div title="Información acerca de la licencia de los materiales">
        <p style="margin: 2px 2px;">
            <strong>
                Materiales desarrollados inicialmente
                por el Ministerio de Educación, Cultura y Deporte y actualizados por el
                profesorado de la Junta de Andalucía bajo licencia Creative Commons
                <abbr title="Reconocimiento-NoComercial-CompartirIgual">
                    BY-NC-SA.
                </abbr>
            </strong>
        </p>
        <p style="font-size: 0.8em; margin: 2px 2px;">
            <strong>
            </strong>
        </p>
        <p style="font-size: 0.8em; margin: 2px 2px;">
          <span>
           Antes de cualquier
										uso leer detenidamente el siguente
          </span>
            Aviso
            legal
        </p>
    </div>
</div>
